This is shishi.info, produced by makeinfo version 4.13 from shishi.texi.

This manual is last updated 4 March 2009 for version 0.0.39 of Shishi.

   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Simon
Josefsson.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

INFO-DIR-SECTION GNU utilities
START-INFO-DIR-ENTRY
* shishi: (shishi).		A Kerberos 5 implementation
END-INFO-DIR-ENTRY

INFO-DIR-SECTION GNU Libraries
START-INFO-DIR-ENTRY
* libshishi: (shishi).		Library implementing Kerberos 5.
END-INFO-DIR-ENTRY


File: shishi.info,  Node: Top,  Next: Introduction,  Up: (dir)

Shishi
******

This manual is last updated 4 March 2009 for version 0.0.39 of Shishi.

   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Simon
Josefsson.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

* Menu:

* Introduction::                How to use this manual.
* User Manual::                 Using Shishi as end-user.
* Administration Manual::       Administrating server aspects of Shishi.
* Reference Manual::            Detailed description of config files, etc.
* Programming Manual::          Calling Shishi from a programming language.
* Acknowledgements::            Whom to blame.

Appendices

* Criticism of Kerberos::       Why you maybe shouldn't use Kerberos.
* Protocol Extensions::         Description of protocol extensions used.
* Copying Information::         How you can copy and share Shishi.

Indices

* Function and Data Index::     Index of functions, variables and data types.
* Concept Index::               Index of concepts and programs.


File: shishi.info,  Node: Introduction,  Next: User Manual,  Prev: Top,  Up: Top

1 Introduction
**************

Shishi is an implementation of the Kerberos 5 network authentication
system, as specified in RFC 4120.  Shishi can be used to authenticate
users in distributed systems.

   Shishi contains a library ('libshishi') that can be used by
application developers to add support for Kerberos 5.  Shishi contains
a command line utility ('shishi') that is used by users to acquire and
manage tickets (and more).  The server side, a Key Distribution Center,
is implemented by 'shishid'.  Of course, a manual documenting usage
aspects as well as the programming API is included.

   Shishi currently supports AS/TGS exchanges for acquiring tickets,
pre-authentication, the AP exchange for performing client and server
authentication, and SAFE/PRIV for integrity/privacy protected
application data exchanges.

   Shishi is internationalized; error and status messages can be
translated into the users' language; user name and passwords can be
converted into any available character set (normally including
ISO-8859-1 and UTF-8) and also be processed using an experimental
Stringprep profile.

   Most, if not all, of the widely used encryption and checksum types
are supported, such as 3DES, AES, ARCFOUR and HMAC-SHA1.

   Shishi is developed for the GNU/Linux system, but runs on over 20
platforms including most major Unix platforms and Windows, and many
kind of devices including iPAQ handhelds and S/390 mainframes.

   Shishi is free software licensed under the GNU General Public License
version 3.0 or later.

* Menu:

* Getting Started::
* Features and Status::
* Overview::
* Cryptographic Overview::
* Supported Platforms::
* Getting help::
* Commercial Support::
* Downloading and Installing::
* Bug Reports::
* Contributing::


File: shishi.info,  Node: Getting Started,  Next: Features and Status,  Up: Introduction

1.1 Getting Started
===================

This manual documents the Shishi application and library programming
interface.  All commands, functions and data types provided by Shishi
are explained.

   The reader is assumed to possess basic familiarity with network
security and the Kerberos 5 security system.

   This manual can be used in several ways.  If read from the beginning
to the end, it gives a good introduction into the library and how it
can be used in an application.  Forward references are included where
necessary.  Later on, the manual can be used as a reference manual to
get just the information needed about any particular interface of the
library.  Experienced programmers might want to start looking at the
examples at the end of the manual, and then only read up those parts of
the interface which are unclear.


File: shishi.info,  Node: Features and Status,  Next: Overview,  Prev: Getting Started,  Up: Introduction

1.2 Features and Status
=======================

Shishi might have a couple of advantages over other packages doing a
similar job.

It's Free Software
     Anybody can use, modify, and redistribute it under the terms of
     the GNU General Public License version 3.0 (*note GNU GPL::) or
     later.

It's thread-safe
     The library uses no global variables.

It's internationalized
     It handles non-ASCII username and passwords and user visible
     strings used in the library (error messages) can be translated
     into the users' language.

It's portable
     It should work on all Unix like operating systems, including
     Windows.


   Shishi is far from feature complete, it is not even a full RFC 1510
implementation yet.  However, some basic functionality is implemented.
A few implemented feature are mentioned below.

   * Initial authentication (AS) from raw key or password.  This step
     is typically used to acquire a ticket granting ticket and, less
     commonly, a server ticket.

   * Subsequent authentication (TGS).  This step is typically used to
     acquire a server ticket, by authenticating yourself using the
     ticket granting ticket.

   * Client-Server authentication (AP).  This step is used by clients
     and servers to prove to each other who they are, using negotiated
     tickets.

   * Integrity protected communication (SAFE).  This step is used by
     clients and servers to exchange integrity protected data with each
     other.  The key is typically agreed on using the Client-Server
     authentication step.

   * Ticket cache, supporting multiple principals and realms.  As
     tickets have a life time of typically several hours, they are
     managed in disk files.  There can be multiple ticket caches, and
     each ticket cache can store tickets for multiple clients (users),
     servers, encryption types, etc.  Functionality is provided for
     locating the proper ticket for every use.

   * Most standard cryptographic primitives.  The believed most secure
     algorithms are supported (*note Cryptographic Overview::).

   * Telnet client and server.  This is used to remotely login to other
     machines, after authenticating yourself with a ticket.

   * PAM module.  This is used to login locally on a machine.

   * KDC addresses located using DNS SRV RRs.

   * Modularized low-level crypto interface.  Currently Gnulib and
     Libgcrypt are supported.  If you wish to add support for another
     low-level cryptographic library, you only have to implement a few
     APIs for DES, AES, MD5, SHA1, HMAC, etc. Look at `gl/gc-gnulib.c'
     or `gl/gc-libgcrypt.c' as a starting pointer.


   The following table summarize what the current objectives are (i.e.,
the todo list) and an estimate on how long it will take to implement
the feature, including some reasonable startup-time to get familiar
with Shishi in general.  If you like to start working on anything,
please let me know so work duplication can be avoided.

   * Parse `/etc/krb5.keytab' to extract keys to use for telnetd etc
     (week)

   * Cross-realm support (week).

   * PKINIT (use libksba, weeks)

   * Finish GSSAPI support via GSSLib (weeks) Shishi will not support
     GSSLib natively, but a separate project "GSSLib" is under way to
     produce a generic GSS implementation, and it will use Shishi to
     implement the Kerberos 5 mechanism.

   * Port to cyclone (cyclone need to mature first)

   * Modularize ASN.1 library so it can be replaced (days).  Almost
     done, all ASN.1 functionality is found in lib/asn1.c, although the
     interface is rather libtasn1 centric.

   * KDC (initiated, weeks)

   * LDAP backend for Shisa.

   * Set/Change password protocol (weeks?)

   * Port applications to use Shishi (indefinite)

   * Finish server-realm stuff

   * Improve documentation

   * Improve internationalization

   * Add AP-REQ replay cache (week).

   * Study benefits by introducing a PA-TGS-REP.  This would provide
     mutual authentication of the KDC in a way that is easier to
     analyze.  Currently the mutual authentication property is only
     implicit from successful decryption of the KDC-REP and the 4 byte
     nonce.

   * GUI applet for managing tickets.  This is supported via the
     ticket-applet, of which a Shishi port is published on the Shishi
     home page.

   * Authorization library (months?)  The shishi_authorized_p() is not
     a good solution, better would be to have a generic and flexible
     authorization library.  Possibly based on S-EXP's in tickets?
     Should support non-Kerberos uses as well, of course.

   * Proof read manual.

   * X.500 support, including DOMAIN-X500-COMPRESS.  I will accept
     patches that implement this, if it causes minimal changes to the
     current code.



File: shishi.info,  Node: Overview,  Next: Cryptographic Overview,  Prev: Features and Status,  Up: Introduction

1.3 Overview
============

This section describes RFC 1510 from a protocol point of view(1).

   Kerberos provides a means of verifying the identities of principals,
(e.g., a workstation user or a network server) on an open (unprotected)
network.  This is accomplished without relying on authentication by the
host operating system, without basing trust on host addresses, without
requiring physical security of all the hosts on the network, and under
the assumption that packets traveling along the network can be read,
modified, and inserted at will. (Note, however, that many applications
use Kerberos' functions only upon the initiation of a stream-based
network connection, and assume the absence of any "hijackers" who might
subvert such a connection.  Such use implicitly trusts the host
addresses involved.)  Kerberos performs authentication under these
conditions as a trusted third- party authentication service by using
conventional cryptography, i.e., shared secret key.  (shared secret key
- Secret and private are often used interchangeably in the literature.
In our usage, it takes two (or more) to share a secret, thus a shared
DES key is a secret key.  Something is only private when no one but its
owner knows it.  Thus, in public key cryptosystems, one has a public
and a private key.)

   The authentication process proceeds as follows: A client sends a
request to the authentication server (AS) requesting "credentials" for
a given server.  The AS responds with these credentials, encrypted in
the client's key.  The credentials consist of 1) a "ticket" for the
server and 2) a temporary encryption key (often called a "session
key").  The client transmits the ticket (which contains the client's
identity and a copy of the session key, all encrypted in the server's
key) to the server.  The session key (now shared by the client and
server) is used to authenticate the client, and may optionally be used
to authenticate the server.  It may also be used to encrypt further
communication between the two parties or to exchange a separate
sub-session key to be used to encrypt further communication.

   The implementation consists of one or more authentication servers
running on physically secure hosts.  The authentication servers
maintain a database of principals (i.e., users and servers) and their
secret keys. Code libraries provide encryption and implement the
Kerberos protocol.  In order to add authentication to its transactions,
a typical network application adds one or two calls to the Kerberos
library, which results in the transmission of the necessary messages to
achieve authentication.

   The Kerberos protocol consists of several sub-protocols (or
exchanges).  There are two methods by which a client can ask a Kerberos
server for credentials.  In the first approach, the client sends a
cleartext request for a ticket for the desired server to the AS. The
reply is sent encrypted in the client's secret key. Usually this
request is for a ticket-granting ticket (TGT) which can later be used
with the ticket-granting server (TGS).  In the second method, the
client sends a request to the TGS.  The client sends the TGT to the TGS
in the same manner as if it were contacting any other application
server which requires Kerberos credentials.  The reply is encrypted in
the session key from the TGT.

   Once obtained, credentials may be used to verify the identity of the
principals in a transaction, to ensure the integrity of messages
exchanged between them, or to preserve privacy of the messages.  The
application is free to choose whatever protection may be necessary.

   To verify the identities of the principals in a transaction, the
client transmits the ticket to the server.  Since the ticket is sent
"in the clear" (parts of it are encrypted, but this encryption doesn't
thwart replay) and might be intercepted and reused by an attacker,
additional information is sent to prove that the message was originated
by the principal to whom the ticket was issued.  This information
(called the authenticator) is encrypted in the session key, and
includes a timestamp.  The timestamp proves that the message was
recently generated and is not a replay.  Encrypting the authenticator
in the session key proves that it was generated by a party possessing
the session key.  Since no one except the requesting principal and the
server know the session key (it is never sent over the network in the
clear) this guarantees the identity of the client.

   The integrity of the messages exchanged between principals can also
be guaranteed using the session key (passed in the ticket and contained
in the credentials).  This approach provides detection of both replay
attacks and message stream modification attacks.  It is accomplished by
generating and transmitting a collision-proof checksum (elsewhere
called a hash or digest function) of the client's message, keyed with
the session key.  Privacy and integrity of the messages exchanged
between principals can be secured by encrypting the data to be passed
using the session key passed in the ticket, and contained in the
credentials.

   ---------- Footnotes ----------

   (1) The text is a lightly adapted version of the introduction
section from RFC 1510 by J. Kohl and C. Neuman, September 1993,
copyright likely owned by the RFC 1510 authors or some contributor.


File: shishi.info,  Node: Cryptographic Overview,  Next: Supported Platforms,  Prev: Overview,  Up: Introduction

1.4 Cryptographic Overview
==========================

Shishi implements several of the standard cryptographic primitives.  In
this section we give the names of the supported encryption suites, and
some notes about them, and their associated checksum suite.

   Statements such as "it is weak" should be read as meaning that there
is no credible security analysis of the mechanism available, and/or
that should an attack be published publicly, few people would likely be
surprised.  Also keep in mind that the key size mentioned is the actual
key size, not the effective key space as far as a brute force attack is
concerned.

   As you may infer from the descriptions, there is currently no
encryption algorithm and only one checksum algorithm that inspire great
confidence in its design.  Hopefully this will change over time.

`NULL'
     `NULL' is a dummy encryption suite for debugging.  Encryption and
     decryption are identity functions.  No integrity protection.  It is
     weak.  It is associated with the `NULL' checksum.

`arcfour-hmac'
`arcfour-hmac-exp'
     `arcfour-hmac-*' are a proprietary stream cipher with 56 bit
     (`arcfour-hmac-exp') or 128 bit (`arcfour-hmac') keys, used in a
     proprietary way described in an expired IETF draft
     `draft-brezak-win2k-krb-rc4-hmac-04.txt'.  Deriving keys from
     passwords is supported, and is done by computing a message digest
     (MD4) of a 16-bit Unicode representation of the ASCII password,
     with no salt.  Data is integrity protected with a keyed hash
     (HMAC-MD5), where the key is derived from the base key in a
     creative way.  It is weak.  It is associated with the
     `arcfour-hmac-md5' checksum.

`des-cbc-none'
     `des-cbc-none' is DES encryption and decryption with 56 bit keys
     and 8 byte blocks in CBC mode, using a zero IV.  The keys can be
     derived from passwords by an obscure application specific
     algorithm.  It is weak, because it offers no integrity protection.
     This is typically only used by RFC 1964 GSS-API implementations
     (which try to protect integrity using an ad-hoc solution).  It is
     associated with the `NULL' checksum.

`des-cbc-crc'
     `des-cbc-crc' is DES encryption and decryption with 56 bit keys
     and 8 byte blocks in CBC mode, using the key as IV (*note Key as
     initialization vector::).  The keys can be derived from passwords
     by an obscure application specific algorithm.  Data is integrity
     protected with an unkeyed but encrypted `CRC32'-like checksum.  It
     is weak. It is associated with the `rsa-md5-des' checksum.

`des-cbc-md4'
     `des-cbc-md4' is DES encryption and decryption with 56 bit keys
     and 8 byte blocks in CBC mode, using a zero IV.  The keys can be
     derived from passwords by an obscure application specific
     algorithm.  Data is integrity protected with an unkeyed but
     encrypted MD4 hash.  It is weak. It is associated with the
     `rsa-md4-des' checksum.

`des-cbc-md5'
     `des-cbc-md5' is DES encryption and decryption with 56 bit keys
     and 8 byte blocks in CBC mode, using a zero IV.  The keys can be
     derived from passwords by an obscure application specific
     algorithm.  Data is integrity protected with an unkeyed but
     encrypted MD5 hash.  It is weak.  It is associated with the
     `rsa-md5-des' checksum.  This is the strongest RFC 1510
     interoperable encryption mechanism.

`des3-cbc-none'
     `des3-cbc-none' is DES encryption and decryption with three 56 bit
     keys (effective key size 112 bits) and 8 byte blocks in CBC mode.
     The keys can be derived from passwords by the same algorithm as
     `des3-cbc-sha1-kd'.  It is weak, because it offers no integrity
     protection.  This is typically only used by GSS-API implementations
     (which try to protect integrity using an ad-hoc solution) for
     interoperability with some existing Kerberos GSS implementations.
     It is associated with the `NULL' checksum.

`des3-cbc-sha1-kd'
     `des3-cbc-sha1-kd' is DES encryption and decryption with three 56
     bit keys (effective key size 112 bits) and 8 byte blocks in CBC
     mode.  The keys can be derived from passwords by a algorithm based
     on the paper "A Better Key Schedule For DES-like Ciphers" (1) by
     Uri Blumenthal and Steven M. Bellovin (it is not clear if the
     algorithm, and the way it is used, is used by any other protocols,
     although it seems unlikely).  Data is integrity protected with a
     keyed SHA1 hash in HMAC mode.  It has no security proof, but is
     assumed to provide adequate security in the sense that knowledge
     on how to crack it is not known to the public.  Note that the key
     derivation function is not widely used outside of Kerberos, hence
     not widely studied.  It is associated with the `hmac-sha1-des3-kd'
     checksum.

`aes128-cts-hmac-sha1-96'
`aes256-cts-hmac-sha1-96'
     `aes128-cts-hmac-sha1-96' and `aes256-cts-hmac-sha1-96' is AES
     encryption and decryption with 128 bit and 256 bit key,
     respectively, and 16 byte blocks in CBC mode with Cipher Text
     Stealing.  Cipher Text Stealing means data length of encrypted
     data is preserved (pure CBC add up to 7 pad characters).  The keys
     can be derived from passwords with RSA Laboratories PKCS#5
     Password Based Key Derivation Function 2(2), which is allegedly
     provably secure in a random oracle model.  Data is integrity
     protected with a keyed SHA1 hash, in HMAC mode, truncated to 96
     bits.  There is no security proof, but the schemes are assumed to
     provide adequate security in the sense that knowledge on how to
     crack them is not known to the public.  Note that AES has yet to
     receive the test of time, and the AES cipher encryption mode (CBC
     with Ciphertext Stealing, and a non-standard IV output) is not
     widely standardized (hence not widely studied).  It is associated
     with the `hmac-sha1-96-aes128' and `hmac-sha1-96-aes256' checksums,
     respectively.


   The protocol do not include any way to negotiate which checksum
mechanisms to use, so in most cases the associated checksum will be
used.  However, checksum mechanisms can be used with other encryption
mechanisms, as long as they are compatible in terms of key format etc.
Here are the names of the supported checksum mechanisms, with some
notes on their status and the compatible encryption mechanisms.  They
are ordered by increased security as perceived by the author.

`NULL'
     `NULL' is a dummy checksum suite for debugging.  It provides no
     integrity.  It is weak.  It is compatible with the `NULL'
     encryption mechanism.

`arcfour-hmac-md5'
     `arcfour-hmac-md5' is a keyed HMAC-MD5 checksum computed on a MD5
     message digest, in turn computed on a four byte message type
     indicator concatenated with the application data.  (The `arcfour'
     designation is thus somewhat misleading, but since this checksum
     mechanism is described in the same document as the `arcfour'
     encryption mechanisms, it is not a completely unnatural
     designation.)  It is weak.  It is compatible with all encryption
     mechanisms.

`rsa-md4'
     `rsa-md4' is a unkeyed MD4 hash computed over the message.  It is
     weak, because it is unkeyed.  However applications can, with care,
     use it non-weak ways (e.g., by including the hash in other
     messages that are protected by other means).  It is compatible
     with all encryption mechanisms.

`rsa-md4-des'
     `rsa-md4-des' is a DES CBC encryption of one block of random data
     and a unkeyed MD4 hash computed over the random data and the
     message to integrity protect.  The key used is derived from the
     base protocol key by XOR with a constant.  It is weak. It is
     compatible with the `des-cbc-crc', `des-cbc-md4', `des-cbc-md5'
     encryption mechanisms.

`rsa-md5'
     `rsa-md5' is a unkeyed MD5 hash computed over the message.  It is
     weak, because it is unkeyed.  However applications can, with care,
     use it non-weak ways (e.g., by including the hash in other
     messages that are protected by other means).  It is compatible
     with all encryption mechanisms.

`rsa-md5-des'
     `rsa-md5-des' is a DES CBC encryption of one block of random data
     and a unkeyed MD5 hash computed over the random data and the
     message to integrity protect.  The key used is derived from the
     base protocol key by XOR with a constant.  It is weak.  It is
     compatible with the `des-cbc-crc', `des-cbc-md4', `des-cbc-md5'
     encryption mechanisms.

`hmac-sha1-des3-kd'
     `hmac-sha1-des3-kd' is a keyed SHA1 hash in HMAC mode computed
     over the message.  The key is derived from the base protocol by the
     simplified key derivation function (similar to the password key
     derivation functions of `des3-cbc-sha1-kd', which does not appear
     to be widely used outside Kerberos and hence not widely studied).
     It has no security proof, but is assumed to provide good security.
     The weakest part is likely the proprietary key derivation
     function.  It is compatible with the `des3-cbc-sha1-kd' encryption
     mechanism.

`hmac-sha1-96-aes128'
`hmac-sha1-96-aes256'
     `hmac-sha1-96-aes*' are keyed SHA1 hashes in HMAC mode computed
     over the message and then truncated to 96 bits.  The key is derived
     from the base protocol by the simplified key derivation function
     (similar to the password key derivation functions of
     `aes*-cts-hmac-sha1-96', i.e., PKCS#5).  It has no security proof,
     but is assumed to provide good security.  It is compatible with
     the `aes*-cts-hmac-sha1-96' encryption mechanisms.


   Several of the cipher suites have long names that can be hard to
memorize.  For your convenience, the following short-hand aliases
exists.  They can be used wherever the full encryption names are used.

`arcfour'
     Alias for `arcfour-hmac'.

`des-crc'
     Alias for `des-cbc-crc'.

`des-md4'
     Alias for `des-cbc-md4'.

`des-md5'
`des'
     Alias for `des-cbc-md5'.

`des3'
`3des'
     Alias for `des3-cbc-sha1-kd'.

`aes128'
     Alias for `aes128-cts-hmac-sha1-96'.

`aes'
`aes256'
     Alias for `aes256-cts-hmac-sha1-96'.


   ---------- Footnotes ----------

   (1) `http://www.research.att.com/~smb/papers/ides.pdf'

   (2) `http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/'


File: shishi.info,  Node: Supported Platforms,  Next: Getting help,  Prev: Cryptographic Overview,  Up: Introduction

1.5 Supported Platforms
=======================

Shishi has at some point in time been tested on the following
platforms.  Online build reports for each platforms and Shishi version
is available at `http://autobuild.josefsson.org/shishi/'.

  1. Debian GNU/Linux 3.0 (Woody) 

     GCC 2.95.4 and GNU Make. This is the main development platform.
     `alphaev67-unknown-linux-gnu', `alphaev6-unknown-linux-gnu',
     `arm-unknown-linux-gnu', `armv4l-unknown-linux-gnu',
     `hppa-unknown-linux-gnu', `hppa64-unknown-linux-gnu',
     `i686-pc-linux-gnu', `ia64-unknown-linux-gnu',
     `m68k-unknown-linux-gnu', `mips-unknown-linux-gnu',
     `mipsel-unknown-linux-gnu', `powerpc-unknown-linux-gnu',
     `s390-ibm-linux-gnu', `sparc-unknown-linux-gnu',
     `sparc64-unknown-linux-gnu'.

  2. Debian GNU/Linux 2.1 

     GCC 2.95.4 and GNU Make. `armv4l-unknown-linux-gnu'.

  3. Tru64 UNIX 

     Tru64 UNIX C compiler and Tru64 Make. `alphaev67-dec-osf5.1',
     `alphaev68-dec-osf5.1'.

  4. SuSE Linux 7.1 

     GCC 2.96 and GNU Make. `alphaev6-unknown-linux-gnu',
     `alphaev67-unknown-linux-gnu'.

  5. SuSE Linux 7.2a 

     GCC 3.0 and GNU Make. `ia64-unknown-linux-gnu'.

  6. SuSE Linux 

     GCC 3.2.2 and GNU Make.  `x86_64-unknown-linux-gnu' (AMD64 Opteron
     "Melody").

  7. RedHat Linux 7.2 

     GCC 2.96 and GNU Make. `alphaev6-unknown-linux-gnu',
     `alphaev67-unknown-linux-gnu', `ia64-unknown-linux-gnu'.

  8. RedHat Linux 8.0 

     GCC 3.2 and GNU Make. `i686-pc-linux-gnu'.

  9. RedHat Advanced Server 2.1 

     GCC 2.96 and GNU Make. `i686-pc-linux-gnu'.

 10. Slackware Linux 8.0.01 

     GCC 2.95.3 and GNU Make. `i686-pc-linux-gnu'.

 11. Mandrake Linux 9.0 

     GCC 3.2 and GNU Make. `i686-pc-linux-gnu'.

 12. IRIX 6.5 

     MIPS C compiler, IRIX Make. `mips-sgi-irix6.5'.

 13. AIX 4.3.2 

     IBM C for AIX compiler, AIX Make.  `rs6000-ibm-aix4.3.2.0'.

 14. HP-UX 11 

     HP-UX C compiler and HP Make. `ia64-hp-hpux11.22',
     `hppa2.0w-hp-hpux11.11'.

 15. SUN Solaris 2.8 

     Sun WorkShop Compiler C 6.0 and SUN Make. `sparc-sun-solaris2.8'.

 16. NetBSD 1.6 

     GCC 2.95.3 and GNU Make. `alpha-unknown-netbsd1.6',
     `i386-unknown-netbsdelf1.6'.

 17. OpenBSD 3.1 and 3.2 

     GCC 2.95.3 and GNU Make. `alpha-unknown-openbsd3.1',
     `i386-unknown-openbsd3.1'.

 18. FreeBSD 4.7 and 4.8 

     GCC 2.95.4 and GNU Make. `alpha-unknown-freebsd4.7',
     `alpha-unknown-freebsd4.8', `i386-unknown-freebsd4.7',
     `i386-unknown-freebsd4.8'.

 19. MacOS X 10.2 Server Edition 

     GCC 3.1 and GNU Make. `powerpc-apple-darwin6.5'.

 20. Cross compiled to uClinux/uClibc on Motorola Coldfire.  

     GCC 3.4 and GNU Make `m68k-uclinux-elf'.


   If you use Shishi on, or port Shishi to, a new platform please report
it to the author (*note Bug Reports::).


File: shishi.info,  Node: Getting help,  Next: Commercial Support,  Prev: Supported Platforms,  Up: Introduction

1.6 Getting help
================

A mailing list where users of Shishi may help each other exists, and
you can reach it by sending e-mail to <help-shishi@gnu.org>.  Archives
of the mailing list discussions, and an interface to manage
subscriptions, is available through the World Wide Web at
`http://lists.gnu.org/mailman/listinfo/help-shishi'.


File: shishi.info,  Node: Commercial Support,  Next: Downloading and Installing,  Prev: Getting help,  Up: Introduction

1.7 Commercial Support
======================

Commercial support is available for users of Shishi.  The kind of
support that can be purchased may include:

   * Implement new features.  Such as support for some optional part of
     the Kerberos standards, e.g. PKINIT, hardware token authentication.

   * Port Shishi to new platforms.  This could include porting Shishi
     to an embedded platforms that may need memory or size optimization.

   * Integrate Kerberos 5 support in your existing project.

   * System design of components related to Kerberos 5.


   If you are interested, please write to:

Simon Josefsson Datakonsult
Hagagatan 24
113 47 Stockholm
Sweden

E-mail: simon@josefsson.org

   If your company provide support related to Shishi and would like to
be mentioned here, contact the author (*note Bug Reports::).


File: shishi.info,  Node: Downloading and Installing,  Next: Bug Reports,  Prev: Commercial Support,  Up: Introduction

1.8 Downloading and Installing
==============================

The package can be downloaded from several places, including:

   `ftp://alpha.gnu.org/pub/gnu/shishi/'

   The latest version is stored in a file, e.g., `shishi-0.0.39.tar.gz'
where the `0.0.39' indicate the highest version number.

   The package is then extracted, configured and built like many other
packages that use Autoconf.  For detailed information on configuring
and building it, refer to the `INSTALL' file that is part of the
distribution archive.

   Here is an example terminal session that download, configure, build
and install the package.  You will need a few basic tools, such as
`sh', `make' and `cc'.

     $ wget -q ftp://alpha.gnu.org/pub/gnu/shishi/shishi-0.0.39.tar.gz
     $ tar xfz shishi-0.0.39.tar.gz
     $ cd shishi-0.0.39/
     $ ./configure
     ...
     $ make
     ...
     $ make install
     ...

   After this you should be prepared to continue with the user,
administration or programming manual, depending on how you want to use
Shishi.

   A few `configure' options may be relevant, summarized in the table.

`--disable-des'
`--disable-3des'
`--disable-aes'
`--disable-md'
`--disable-null'
`--disable-arcfour'
     Disable a cryptographic algorithm at compile time.  Usually it is
     better to disable algorithms during run-time with the configuration
     file, but this allows you to reduce the code size slightly.

`--disable-starttls'
     Disable the experimental TLS support for KDC connections.  If you
     do not use a Shishi KDC, this support is of no use so you could
     safely disable it.

`--without-stringprep'
     Disable internationalized string processing.


   For the complete list, refer to the output from `configure --help'.


File: shishi.info,  Node: Bug Reports,  Next: Contributing,  Prev: Downloading and Installing,  Up: Introduction

1.9 Bug Reports
===============

If you think you have found a bug in Shishi, please investigate it and
report it.

   * Please make sure that the bug is really in Shishi, and preferably
     also check that it hasn't already been fixed in the latest version.

   * You have to send us a test case that makes it possible for us to
     reproduce the bug.

   * You also have to explain what is wrong; if you get a crash, or if
     the results printed are not good and in that case, in what way.
     Make sure that the bug report includes all information you would
     need to fix this kind of bug for someone else.


   Please make an effort to produce a self-contained report, with
something definite that can be tested or debugged.  Vague queries or
piecemeal messages are difficult to act on and don't help the
development effort.

   If your bug report is good, we will do our best to help you to get a
corrected version of the software; if the bug report is poor, we won't
do anything about it (apart from asking you to send better bug reports).

   If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please also send a
note.

   Send your bug report to:

                      `bug-shishi@josefsson.org'


File: shishi.info,  Node: Contributing,  Prev: Bug Reports,  Up: Introduction

1.10 Contributing
=================

If you want to submit a patch for inclusion - from solve a typo you
discovered, up to adding support for a new feature - you should submit
it as a bug report (*note Bug Reports::).  There are some things that
you can do to increase the chances for it to be included in the
official package.

   Unless your patch is very small (say, under 10 lines) we require that
you assign the copyright of your work to the Free Software Foundation.
This is to protect the freedom of the project.  If you have not already
signed papers, we will send you the necessary information when you
submit your contribution.

   For contributions that doesn't consist of actual programming code,
the only guidelines are common sense.  Use it.

   For code contributions, a number of style guides will help you:

   * Coding Style.  Follow the GNU Standards document (*note GNU Coding
     Standards: (standards)top.).

     If you normally code using another coding standard, there is no
     problem, but you should use `indent' to reformat the code (*note
     GNU Indent: (indent)top.) before submitting your work.

   * Use the unified diff format `diff -u'.

   * Return errors.  The only valid reason for ever aborting the
     execution of the program is due to memory allocation errors, but
     for that you should call `shishi_xalloc_die' to allow the
     application to recover if it wants to.

   * Design with thread safety in mind.  Don't use global variables.
     Don't even write to per-handle global variables unless the
     documented behaviour of the function you write is to write to the
     per-handle global variable.

   * Avoid using the C math library.  It causes problems for embedded
     implementations, and in most situations it is very easy to avoid
     using it.

   * Document your functions.  Use comments before each function
     headers, that, if properly formatted, are extracted into Texinfo
     manuals and GTK-DOC web pages.

   * Supply a ChangeLog and NEWS entries, where appropriate.



File: shishi.info,  Node: User Manual,  Next: Administration Manual,  Prev: Introduction,  Up: Top

2 User Manual
*************

Usually Shishi interacts with you to get some initial authentication
information like a password, and then contacts a server to receive a so
called ticket granting ticket.  From now on, you rarely interacts with
Shishi directly.  Applications that needs security services instruct
the Shishi library to use the ticket granting ticket to get new tickets
for various servers.  An example could be if you log on to a host
remotely via `telnet'.  The host usually requires authentication before
permitting you in.  The `telnet' client uses the ticket granting ticket
to get a ticket for the server, and then use this ticket to
authenticate you against the server (typically the server is also
authenticated to you).  You perform the initial authentication by
typing `shishi' at the prompt.  Sometimes it is necessary to supply
options telling Shishi what your principal name (user name in the
Kerberos realm) or realm is.  In the example, I specify the client name
`simon@JOSEFSSON.ORG'.

     $ shishi simon@JOSEFSSON.ORG
     Enter password for `simon@JOSEFSSON.ORG':
     simon@JOSEFSSON.ORG:
     Authtime:       Fri Aug 15 04:44:49 2003
     Endtime:        Fri Aug 15 05:01:29 2003
     Server:         krbtgt/JOSEFSSON.ORG key des3-cbc-sha1-kd (16)
     Ticket key:     des3-cbc-sha1-kd (16) protected by des3-cbc-sha1-kd (16)
     Ticket flags:   INITIAL (512)
     $

   As you can see, Shishi also prints a short description of the ticket
received.

   A logical next step is to display all tickets you have received (by
the way, the tickets are usually stored as text in
`~/.shishi/tickets').  This is achieved by typing `shishi --list'.

     $ shishi --list
     Tickets in `/home/jas/.shishi/tickets':

     jas@JOSEFSSON.ORG:
     Authtime:       Fri Aug 15 04:49:46 2003
     Endtime:        Fri Aug 15 05:06:26 2003
     Server:         krbtgt/JOSEFSSON.ORG key des-cbc-md5 (3)
     Ticket key:     des-cbc-md5 (3) protected by des-cbc-md5 (3)
     Ticket flags:   INITIAL (512)

     jas@JOSEFSSON.ORG:
     Authtime:       Fri Aug 15 04:49:46 2003
     Starttime:      Fri Aug 15 04:49:49 2003
     Endtime:        Fri Aug 15 05:06:26 2003
     Server:         host/latte.josefsson.org key des-cbc-md5 (3)
     Ticket key:     des-cbc-md5 (3) protected by des-cbc-md5 (3)

     2 tickets found.
     $

   As you can see, I had a ticket for the server
`host/latte.josefsson.org' which was generated by `telnet':ing to that
host.

   If, for some reason, you want to manually get a ticket for a specific
server, you can use the `shishi --server-name' command.  Normally,
however, the application that uses Shishi will take care of getting a
ticket for the appropriate server, so you normally wouldn't need this
command.

     $ shishi --server-name=user/billg --encryption-type=des-cbc-md4
     jas@JOSEFSSON.ORG:
     Authtime:       Fri Aug 15 04:49:46 2003
     Starttime:      Fri Aug 15 04:54:33 2003
     Endtime:        Fri Aug 15 05:06:26 2003
     Server:         user/billg key des-cbc-md4 (2)
     Ticket key:     des-cbc-md4 (2) protected by des-cbc-md5 (3)
     $

   As you can see, I acquired a ticket for `user/billg' with a
`des-cbc-md4' (*note Cryptographic Overview::) encryption key specified
with the `--encryption-type' parameter.

   To wrap up this introduction, lets see how you can remove tickets.
You may want to do this if you leave your terminal for lunch or
similar, and don't want someone to be able to copy the file and then
use your credentials.  Note that this only destroy the tickets locally,
it does not contact any server and tell it that these credentials are
no longer valid.  So if someone stole your ticket file, you must
contact your administrator and have them reset your account, simply
using this parameter is not sufficient.

     $ shishi --server-name=imap/latte.josefsson.org --destroy
     1 ticket removed.
     $ shishi --server-name=foobar --destroy
     No tickets removed.
     $ shishi --destroy
     3 tickets removed.
     $

   Since the `--server-name' parameter takes a long to type, it is
possible to type the server name directly, after the client name.  The
following example demonstrate a AS-REQ followed by a TGS-REQ for a
specific server (assuming you did not have any tickets from the start).

     $ src/shishi simon@latte.josefsson.org imap/latte.josefsson.org
     Enter password for `simon@latte.josefsson.org':
     simon@latte.josefsson.org:
     Acquired:       Wed Aug 27 17:21:06 2003
     Expires:        Wed Aug 27 17:37:46 2003
     Server:         imap/latte.josefsson.org key aes256-cts-hmac-sha1-96 (18)
     Ticket key:     aes256-cts-hmac-sha1-96 (18) protected by aes256-cts-hmac-sha1-96 (18)
     Ticket flags:   FORWARDED PROXIABLE (12)
     $

   Refer to the reference manual for all available parameters (*note
Parameters for shishi::).  The rest of this section contains
description of more specialized usage modes that can be ignored by most
users.

2.1 Proxiable and Proxy Tickets
===============================

At times it may be necessary for a principal to allow a service to
perform an operation on its behalf. The service must be able to take on
the identity of the client, but only for a particular purpose. A
principal can allow a service to take on the principal's identity for a
particular purpose by granting it a proxy.

   The process of granting a proxy using the proxy and proxiable flags
is used to provide credentials for use with specific services. Though
conceptually also a proxy, users wishing to delegate their identity in
a form usable for all purpose MUST use the ticket forwarding mechanism
described in the next section to forward a ticket-granting ticket.

   The PROXIABLE flag in a ticket is normally only interpreted by the
ticket-granting service. It can be ignored by application servers.
When set, this flag tells the ticket-granting server that it is OK to
issue a new ticket (but not a ticket-granting ticket) with a different
network address based on this ticket. This flag is set if requested by
the client on initial authentication. By default, the client will
request that it be set when requesting a ticket-granting ticket, and
reset when requesting any other ticket.

   This flag allows a client to pass a proxy to a server to perform a
remote request on its behalf (e.g. a print service client can give the
print server a proxy to access the client's files on a particular file
server in order to satisfy a print request).

   In order to complicate the use of stolen credentials, Kerberos
tickets are usually valid from only those network addresses specifically
included in the ticket[4]. When granting a proxy, the client MUST
specify the new network address from which the proxy is to be used, or
indicate that the proxy is to be issued for use from any address.

   The PROXY flag is set in a ticket by the TGS when it issues a proxy
ticket.  Application servers MAY check this flag and at their option
they MAY require additional authentication from the agent presenting
the proxy in order to provide an audit trail.

   Here is how you would acquire a PROXY ticket for the service
`imap/latte.josefsson.org':

     $ shishi jas@JOSEFSSON.ORG imap/latte.josefsson.org --proxy
     Enter password for `jas@JOSEFSSON.ORG':
     libshishi: warning: KDC bug: Reply encrypted using wrong key.
     jas@JOSEFSSON.ORG:
     Authtime:       Mon Sep  8 20:02:35 2003
     Starttime:      Mon Sep  8 20:02:36 2003
     Endtime:        Tue Sep  9 04:02:35 2003
     Server:         imap/latte.josefsson.org key des3-cbc-sha1-kd (16)
     Ticket key:     des3-cbc-sha1-kd (16) protected by des3-cbc-sha1-kd (16)
     Ticket flags:   PROXY (16)
     $

   As you noticed, this asked for your password.  The reason is that
proxy tickets must be acquired using a proxiable ticket granting
ticket, which was not present.  If you often need to get proxy tickets,
you may acquire a proxiable ticket granting ticket from the start:

     $ shishi --proxiable
     Enter password for `jas@JOSEFSSON.ORG':
     jas@JOSEFSSON.ORG:
     Authtime:       Mon Sep  8 20:04:27 2003
     Endtime:        Tue Sep  9 04:04:27 2003
     Server:         krbtgt/JOSEFSSON.ORG key des3-cbc-sha1-kd (16)
     Ticket key:     des3-cbc-sha1-kd (16) protected by des3-cbc-sha1-kd (16)
     Ticket flags:   PROXIABLE INITIAL (520)

   Then you should be able to acquire proxy tickets based on that ticket
granting ticket, as follows:

     $ shishi jas@JOSEFSSON.ORG imap/latte.josefsson.org --proxy
     libshishi: warning: KDC bug: Reply encrypted using wrong key.
     jas@JOSEFSSON.ORG:
     Authtime:       Mon Sep  8 20:04:27 2003
     Starttime:      Mon Sep  8 20:04:32 2003
     Endtime:        Tue Sep  9 04:04:27 2003
     Server:         imap/latte.josefsson.org key des3-cbc-sha1-kd (16)
     Ticket key:     des3-cbc-sha1-kd (16) protected by des3-cbc-sha1-kd (16)
     Ticket flags:   PROXY (16)
     $

2.2 Forwardable and Forwarded Tickets
=====================================

Authentication forwarding is an instance of a proxy where the service
that is granted is complete use of the client's identity. An example
where it might be used is when a user logs in to a remote system and
wants authentication to work from that system as if the login were
local.

   The FORWARDABLE flag in a ticket is normally only interpreted by the
ticket-granting service. It can be ignored by application servers.  The
FORWARDABLE flag has an interpretation similar to that of the PROXIABLE
flag, except ticket-granting tickets may also be issued with different
network addresses. This flag is reset by default, but users MAY request
that it be set by setting the FORWARDABLE option in the AS request when
they request their initial ticket-granting ticket.

   This flag allows for authentication forwarding without requiring the
user to enter a password again. If the flag is not set, then
authentication forwarding is not permitted, but the same result can
still be achieved if the user engages in the AS exchange specifying the
requested network addresses and supplies a password.

   The FORWARDED flag is set by the TGS when a client presents a ticket
with the FORWARDABLE flag set and requests a forwarded ticket by
specifying the FORWARDED KDC option and supplying a set of addresses
for the new ticket. It is also set in all tickets issued based on
tickets with the FORWARDED flag set. Application servers may choose to
process FORWARDED tickets differently than non-FORWARDED tickets.

   If addressless tickets are forwarded from one system to another,
clients SHOULD still use this option to obtain a new TGT in order to
have different session keys on the different systems.

   Here is how you would acquire a FORWARDED ticket for the service
`host/latte.josefsson.org':

     $ shishi jas@JOSEFSSON.ORG host/latte.josefsson.org --forwarded
     Enter password for `jas@JOSEFSSON.ORG':
     libshishi: warning: KDC bug: Reply encrypted using wrong key.
     jas@JOSEFSSON.ORG:
     Authtime:       Mon Sep  8 20:07:11 2003
     Starttime:      Mon Sep  8 20:07:12 2003
     Endtime:        Tue Sep  9 04:07:11 2003
     Server:         host/latte.josefsson.org key des3-cbc-sha1-kd (16)
     Ticket key:     des3-cbc-sha1-kd (16) protected by des3-cbc-sha1-kd (16)
     Ticket flags:   FORWARDED (4)
     $

   As you noticed, this asked for your password.  The reason is that
forwarded tickets must be acquired using a forwardable ticket granting
ticket, which was not present.  If you often need to get forwarded
tickets, you may acquire a forwardable ticket granting ticket from the
start:

     $ shishi --forwardable
     Enter password for `jas@JOSEFSSON.ORG':
     jas@JOSEFSSON.ORG:
     Authtime:       Mon Sep  8 20:08:53 2003
     Endtime:        Tue Sep  9 04:08:53 2003
     Server:         krbtgt/JOSEFSSON.ORG key des3-cbc-sha1-kd (16)
     Ticket key:     des3-cbc-sha1-kd (16) protected by des3-cbc-sha1-kd (16)
     Ticket flags:   FORWARDABLE INITIAL (514)
     $

   Then you should be able to acquire forwarded tickets based on that
ticket granting ticket, as follows:

     $ shishi jas@JOSEFSSON.ORG host/latte.josefsson.org --forwarded
     libshishi: warning: KDC bug: Reply encrypted using wrong key.
     jas@JOSEFSSON.ORG:
     Authtime:       Mon Sep  8 20:08:53 2003
     Starttime:      Mon Sep  8 20:08:57 2003
     Endtime:        Tue Sep  9 04:08:53 2003
     Server:         host/latte.josefsson.org key des3-cbc-sha1-kd (16)
     Ticket key:     des3-cbc-sha1-kd (16) protected by des3-cbc-sha1-kd (16)
     Ticket flags:   FORWARDED (4)
     $


File: shishi.info,  Node: Administration Manual,  Next: Reference Manual,  Prev: User Manual,  Up: Top

3 Administration Manual
***********************

Here you will learn how to set up, run and maintain the Shishi Kerberos
server.  Kerberos is incompatible with the standard Unix `/etc/passwd'
password database(1), therefor the first step will be to create a
Kerberos user database.  Shishi's user database system is called Shisa.
Once Shisa is configured, you can then start the server and begin
issuing Kerberos tickets to your users.  The Shishi server is called
`shishid'.  After getting the server up and running, we discuss how you
can set up multiple Kerberos servers, to increase availability or offer
load-balancing.  Finally, we include some information intended for
developers, that will enable you to customize Shisa to use an external
user database, such as a LDAP server or SQL database.

* Menu:

* Introduction to Shisa::       Explanation of the Shishi user database.
* Configuring Shisa::           Define the user database in Shisa.
* Using Shisa::                 How to add realms and principals to database.
* Starting Shishid::            Issue Kerberos tickets to your users.
* Configuring DNS for KDC::     Placing the KDC address in DNS is useful.
* Kerberos via TLS::            How to setup Shishi to use TLS.
* Multiple servers::            High availability and load-balancing.
* Developer information::       Writing your own Shisa database backend.

   ---------- Footnotes ----------

   (1) And besides, Shishi is intended to work on non-Unix platforms as
well.


File: shishi.info,  Node: Introduction to Shisa,  Next: Configuring Shisa,  Up: Administration Manual

3.1 Introduction to Shisa
=========================

The user database part of Shishi is called Shisa.  The Shisa library is
independent of the core Shishi library.  Shisa is responsible for
storing the name of your realms, the name of your principals (users),
accounting information for the users (i.e., when each account start to
be valid and when it expire), and the cryptographic keys each user
have.  Some Kerberos internal data can also be stored, such as the key
version number, the last dates for when various ticket requests were
made, the cryptographic salt, string-to-key parameters and password for
each user.  Not all information need to be stored.  For example, in
some situations it is prudent to leave the password field empty, so
that somebody who manage to steal the user database will only be able
to compromise your system, and not other systems were your user may
have re-used the same password.  On the other hand, you may already
store the password in your customized database, in which case being
able to change it via the Shisa interface can be useful.

   Shisa is a small (a few thousand lines of C code) standalone
library.  Shisa does not depend on the Shishi library.  Because a user
database with passwords may be useful for other applications as well
(e.g., GNU SASL), it may be separated into its own project later on.
You should keep this in mind, so that you don't consider writing a
Shisa backend for your own database a purely Shishi specific project.
You may, for example, chose to use the Shisa interface in your own
applications to have a simple interface to your user database.  Your
experience and feedback is appreciated if you chose to explore this.

   Note that the Shisa database does not expose everything you may want
to know about a user, such as its full human name, telephone number or
even the user's login account name or home directory.  It only store
what is needed to authenticate a peer claiming to be an entity.  Thus
it does not make sense to replace your current user database or
`/etc/passwd' with data derived from the Shisa database.  Instead, it
is intended that you write a Shisa backend that export some of the
information stored in your user database.  You may be able to replace
some existing functionality, such as the password field in
`/etc/passwd' with a Kerberos PAM module, but there is no requirement
for doing so.


File: shishi.info,  Node: Configuring Shisa,  Next: Using Shisa,  Prev: Introduction to Shisa,  Up: Administration Manual

3.2 Configuring Shisa
=====================

The configuration file for Shisa is typically stored in
`/usr/local/etc/shishi/shisa.conf'.  You do not have to configure this
file, the defaults should be acceptable to first-time users.  The file
is used to define where you user database reside, and some options such
as making the database read-only or whether errors detected when
accessing the database should be ignored.  (The latter may be useful if
the server is a remote LDAP server that may be unavailable, and you
want to fail over to a local copy of the database.)

   The default will store the user database using directories and files,
rooted by default in `/usr/local/var/shishi'.  You may use standard
file permission settings to control access to the directory hierarchy.
It is strongly recommended to restrict access to the directory.
Storing the directory on local storage (i.e., hard disk or removal
media) is recommended.  We discourage placing the database on a network
file system, but realize it can be useful in some situations (*note
Multiple servers::).

   See the reference manual (*note Shisa Configuration::) for the
details of the configuration file.  Again, you are not expected to need
to modify anything unless you are an experienced Shishi administrator.


File: shishi.info,  Node: Using Shisa,  Next: Starting Shishid,  Prev: Configuring Shisa,  Up: Administration Manual

3.3 Using Shisa
===============

There is a command line interface to the Shisa library, aptly named
`shisa'.  You will use this tool to add, remove and change information
stored in the database about realms, principals and keys.  The tool can
also be used to "dump" all information in the database, for backup or
debugging purposes.  (Currently the output format cannot be read by any
tool, but functionality to do this will be added in the future,
possibly as a read-only file-based Shisa database backend.)

   The reference manual (*note Parameters for shisa::) explains all
parameters, but here we will give you a walk-through of the typical
uses of the tool.

   Installing Shishi usually create a realm with two principals; one
ticket granting ticket for the realm, and one host key for the server.
This is what you typically need to get started, but it doesn't serve
our purposes.  So we start by removing the principals and the realm.
To do that, we need to figure out the name of the realm.  The `--list'
or `--dump' parameters can be used for this.  (Most "long" parameters,
like `--dump', have shorter names as well, in this case `-d', *note
Parameters for shisa::).

     jas@latte:~$ shisa -d
     latte
             krbtgt/latte
                     Account is enabled.
                     Current key version 0 (0x0).
                     Key 0 (0x0).
                             Etype aes256-cts-hmac-sha1-96 (0x12, 18).
                             Salt lattekrbtgt/latte.
             host/latte
                     Account is enabled.
                     Current key version 0 (0x0).
                     Key 0 (0x0).
                             Etype aes256-cts-hmac-sha1-96 (0x12, 18).
                             Salt lattehost/latte.
     jas@latte:~$

   The realm names are printed at column 0, the principal names are
indented with one `TAB' character (aka `\t' or ASCII 0x09 Horizontal
Tabulation), and the information about each principal are indented with
two `TAB' characters.  The above output means that there is one realm
`latte' with two principals; `krbtgt/latte' (which is used to
authenticate Kerberos ticket requests) and `host/latte' (used to
authenticate host-based applications like Telnet).  They were created
during `make install' on a host called `latte'.

   If the installation did not create a default database for you, you
might get an error similar to the following.

     jas@latte:~$ shisa -d
     shisa: Cannot initialize `file' database backend.
     Location `/usr/local/var/shishi' and options `N/A'.
     shisa: Initialization failed:
     Shisa database could not be opened.
     jas@latte:~$

   This indicate the database do not exist.  For a file database, you
can create it by simply creating the directory, as follows.  Note the
access permission change with `chmod'.  Typically the `root' user would
own the files, but as these examples demonstrate, setting up a Kerberos
server does not require root access.  Indeed, it may be prudent to run
all Shishi applications as a special non-`root' user, and have all
Shishi related files owned by that user, so that any security
vulnerabilities does not lead to a system compromise.  (However, if the
user database is stolen, system compromises of other systems may be
possible if you use, e.g., Kerberos Telnet.)

     jas@latte:~$ mkdir /usr/local/var/shishi
     jas@latte:~$ chmod go-rwx /usr/local/var/shishi

   Back to the first example, where you have a realm `latte' with some
principals.  We want to remove the realm to demonstrate how you create
the realm from scratch.  (Of course, you can have more than one realm
in the database, but for this example we assume you want to set up a
realm named the same as Shishi guessed you would name it, so the
existing realm need to be removed first.)  The `--remove' (short form
`-r') parameter is used for this purpose, as follows.

     jas@latte:~$ shisa -r latte host/latte
     Removing principal `host/latte@latte'...
     Removing principal `host/latte@latte'...done
     jas@latte:~$ shisa -r latte krbtgt/latte
     Removing principal `krbtgt/latte@latte'...
     Removing principal `krbtgt/latte@latte'...done
     jas@latte:~$ shisa -r latte
     Removing realm `latte'...
     Removing realm `latte'...done
     jas@latte:~$

   You may be asking yourself "What if the realm has many more
principals?".  If you fear manual labor (or a small `sed' script,
recall the format of `--list'?), don't worry, there is a `--force'
(short form `-f') flag.  Use with care.  Here is a faster way to do the
above:

     jas@latte:~$ shisa -r latte -f
     Removing principal `krbtgt/latte@latte'...
     Removing principal `krbtgt/latte@latte'...done
     Removing principal `host/latte@latte'...
     Removing principal `host/latte@latte'...done
     Removing realm `latte'...
     Removing realm `latte'...done
     jas@latte:~$

   You should now have a working, but empty, Shisa database.  Let's set
up the realm manually, step by step.  The first step is to decide on
name for your realm.  The full story is explained elsewhere (*note
Realm and Principal Naming::) but the short story is to take your DNS
domain name and translate it to upper case.  For example, if your
organization uses `example.org' it is a good idea to use `EXAMPLE.ORG'
as the name of your Kerberos realm.  We'll use `EXAMPLE.ORG' as the
realm name in these examples.  Let's create the realm.

     jas@latte:~$ shisa -a EXAMPLE.ORG
     Adding realm `EXAMPLE.ORG'...
     Adding realm `EXAMPLE.ORG'...done
     jas@latte:~$

   Currently, there are no properties associated with entire realms.  In
the future, it may be possible to set a default realm-wide password
expiry policy or similar.  Each realm normally have one principal that
is used for authenticating against the "ticket granting service" on the
Kerberos server with a ticket instead of using the password.  This is
used by the user when she acquire a ticket for servers.  This principal
must look like `krbtgt/REALM' (*note Name of the TGS: krbtgt.).  Let's
create it.

     jas@latte:~$ shisa -a EXAMPLE.ORG krbtgt/EXAMPLE.ORG
     Adding principal `krbtgt/EXAMPLE.ORG@EXAMPLE.ORG'...
     Adding principal `krbtgt/EXAMPLE.ORG@EXAMPLE.ORG'...done
     jas@latte:~$

   Now that wasn't difficult, although not very satisfying either.  What
does adding a principal mean?  The name is created, obviously, but it
also mean setting a few values in the database.  Let's view the entry
to find out which values.

     jas@latte:~$ shisa -d
     EXAMPLE.ORG
             krbtgt/EXAMPLE.ORG
                     Account is enabled.
                     Current key version 0 (0x0).
                     Key 0 (0x0).
                             Etype aes256-cts-hmac-sha1-96 (0x12, 18).
                             Salt EXAMPLE.ORGkrbtgt/EXAMPLE.ORG.
     jas@latte:~$

   To use host based security services like SSH or Telnet with
Kerberos, each host must have a key shared between the host and the
KDC.  The key is typically stored in
`/usr/local/etc/shishi/shishi.keys'.  We assume your server is called
`mail.example.org' and create the principal.  To illustrate a new
parameter, we also set the specific algorithm to use by using the
`--encryption-type' (short form `-E') parameter.

     jas@latte:~$ shisa -a EXAMPLE.ORG host/mail.example.org -E des3
     Adding principal `host/mail.example.org@EXAMPLE.ORG'...
     Adding principal `host/mail.example.org@EXAMPLE.ORG'...done
     jas@latte:~$

   To export the key, there is another Shisa parameter `--keys' that
will print the key in a format that is recognized by Shishi.  Let's use
it to print the host key.

     jas@latte:~$ shisa -d --keys EXAMPLE.ORG host/mail.example.org
     EXAMPLE.ORG
             host/mail.example.org
                     Account is enabled.
                     Current key version 0 (0x0).
                     Key 0 (0x0).
                             Etype des3-cbc-sha1-kd (0x10, 16).
     -----BEGIN SHISHI KEY-----
     Keytype: 16 (des3-cbc-sha1-kd)
     Principal: host/mail.example.org
     Realm: EXAMPLE.ORG

     iQdA8hxdvOUHZNliZJv7noM02rXHV8gq
     -----END SHISHI KEY-----
                             Salt EXAMPLE.ORGhost/mail.example.org.
     jas@latte:~$

   So to set up the host, simply redirect output to the host key file.

     jas@latte:~$ shisa -d --keys EXAMPLE.ORG \
          host/mail.example.org > /usr/local/etc/shishi/shishi.keys
     jas@latte:~$

   The next logical step is to create a principal for some user, so you
can use your password to get a Ticket Granting Ticket via the
Authentication Service (AS) from the KDC, and then use the Ticket
Granting Service (TGS) from the KDC to get a ticket for a specific
host, and then send that ticket to the host to authenticate yourself.
Creating this end-user principle is slightly different from the earlier
steps, because you want the key to be derived from a password instead
of being a random key.  The `--password' parameter indicate this.  This
make the tool ask you for the password.

     jas@latte:~$ shisa -a EXAMPLE.ORG simon --password
     Password for `simon@EXAMPLE.ORG':
     Adding principal `simon@EXAMPLE.ORG'...
     Adding principal `simon@EXAMPLE.ORG'...done
     jas@latte:~$

   The only special thing about this principal now is that it has a
`password' field set in the database.

     jas@latte:~$ shisa -d EXAMPLE.ORG simon --keys
     EXAMPLE.ORG
             simon
                     Account is enabled.
                     Current key version 0 (0x0).
                     Key 0 (0x0).
                             Etype aes256-cts-hmac-sha1-96 (0x12, 18).
     -----BEGIN SHISHI KEY-----
     Keytype: 18 (aes256-cts-hmac-sha1-96)
     Principal: simon
     Realm: EXAMPLE.ORG

     Ja7ciNtrAI3gtodLaVDQ5zhcH58ffk0kS5tGAM7ILvM=
     -----END SHISHI KEY-----
                             Salt EXAMPLE.ORGsimon.
                             Password foo.
     jas@latte:~$

   You should now be ready to start the KDC, which is explained in the
next section (*note Starting Shishid::), and get tickets as explained
earlier (*note User Manual::).


File: shishi.info,  Node: Starting Shishid,  Next: Configuring DNS for KDC,  Prev: Using Shisa,  Up: Administration Manual

3.4 Starting Shishid
====================

The Shishi server, or Key Distribution Center (KDC), is called Shishid.
Shishid is responsible for listening on UDP and TCP ports for Kerberos
requests.  Currently it can handle initial ticket requests
(Authentication Service, or AS), typically authenticated with keys
derived from passwords, and subsequent ticket requests (Ticket Granting
Service, or TGS), typically authenticated with the key acquired during
an AS exchange.

   Currently there is very little configuration available, the only
variables are which ports the server should listen on and an optional
user name to `setuid' into after successfully listening to the ports.

   By default, Shishid listens on the `kerberos' service port
(typically translated to 88 via `/etc/services') on the UDP and TCP
protocols via IPv4 and (if your machine support it) IPv6 on all
interfaces on your machine.  Here is a typical startup.

     latte:/home/jas/src/shishi# /usr/local/sbin/shishid
     Initializing GNUTLS...
     Initializing GNUTLS...done
     Listening on IPv4:*:kerberos/udp...done
     Listening on IPv4:*:kerberos/tcp...done
     Listening on IPv6:*:kerberos/udp...failed
     socket: Address family not supported by protocol
     Listening on IPv6:*:kerberos/tcp...failed
     socket: Address family not supported by protocol
     Listening on 2 ports...

   Running as root is not recommended.  Any security problem in shishid
and your host may be compromised.  Therefor, we recommend using the
`--setuid' parameter, as follows.

     latte:/home/jas/src/shishi# /usr/local/sbin/shishid --setuid=jas
     Initializing GNUTLS...
     Initializing GNUTLS...done
     Listening on IPv4:*:kerberos/udp...done
     Listening on IPv4:*:kerberos/tcp...done
     Listening on IPv6:*:kerberos/udp...failed
     socket: Address family not supported by protocol
     Listening on IPv6:*:kerberos/tcp...failed
     socket: Address family not supported by protocol
     Listening on 2 ports...
     User identity set to `jas' (22541)...

   An alternative is to run shishid on an alternative port as a
non-privileged user.  To continue the example of setting up the
`EXAMPLE.ORG' realm as a non-privileged user from the preceding
section, we start the server listen on port 4711 via UDP on IPv4.

     jas@latte:~$ /usr/local/sbin/shishid -l IPv4:*:4711/udp
     Initializing GNUTLS...
     Initializing GNUTLS...done
     Listening on *:4711/tcp...
     Listening on 1 ports...
     shishid: Starting (GNUTLS `1.0.4')
     shishid: Listening on *:4711/tcp socket 4

   If you have set up the Shisa database as in the previous example, you
can now acquire tickets as follows.

     jas@latte:~$ shishi -o 'realm-kdc=EXAMPLE.ORG,localhost:4711' \
        simon@EXAMPLE.ORG
     Enter password for `simon@EXAMPLE.ORG':
     simon@EXAMPLE.ORG:
     Authtime:       Fri Dec 12 01:41:01 2003
     Endtime:        Fri Dec 12 01:57:41 2003
     Server:         krbtgt/EXAMPLE.ORG key aes256-cts-hmac-sha1-96 (18)
     Ticket key:     aes256-cts-hmac-sha1-96 (18) protected by aes256-cts-hmac-sha1-96 (18)
     Ticket flags:   FORWARDED PROXIABLE RENEWABLE INITIAL (12)
     jas@latte:~$

   The output from Shishid on a successful invocation would look like:

     shishid: Has 131 bytes from *:4711/udp on socket 4
     shishid: Processing 131 from *:4711/udp on socket 4
     shishid: Trying AS-REQ
     shishid: AS-REQ from simon@EXAMPLE.ORG for krbtgt/EXAMPLE.ORG@EXAMPLE.ORG
     shishid: Matching client etype 18 against user key etype 18
     shishid: Have 511 bytes for *:4711/udp on socket 4
     shishid: Sending 511 bytes to *:4711/udp socket 4 via UDP
     shishid: Listening on *:4711/udp socket 4

   You may use the '-v' parameter for Shishid and Shishi to generate
more debugging information.

   To illustrate what an application, such as the Shishi patched
versions of GNU lsh or Telnet from GNU InetUtils, would do when
contacting the host `mail.example.org' we illustrate using the TGS
service as well.

     jas@latte:~$ shishi -o 'realm-kdc=EXAMPLE.ORG,localhost:4711' \
        simon@EXAMPLE.ORG host/mail.example.org
     simon@EXAMPLE.ORG:
     Authtime:       Fri Dec 12 01:46:54 2003
     Endtime:        Fri Dec 12 02:03:34 2003
     Server:         host/mail.example.org key des3-cbc-sha1-kd (16)
     Ticket key:     des3-cbc-sha1-kd (16) protected by aes256-cts-hmac-sha1-96 (18)
     Ticket flags:   FORWARDED PROXIABLE (45398796)
     jas@latte:~$

   This conclude our walk-through of setting up a new Kerberos realm
using Shishi.  It is quite likely that one or more steps failed, and if
so we encourage you to debug it and submit a patch, or at least report
it as a problem.  Heck, even letting us know if you got this far would
be of interest.  *Note Bug Reports::.


File: shishi.info,  Node: Configuring DNS for KDC,  Next: Kerberos via TLS,  Prev: Starting Shishid,  Up: Administration Manual

3.5 Configuring DNS for KDC
===========================

Making sure the configuration files on all hosts running Shishi clients
include the addresses of your server is tedious.  If the configuration
files do not mention the KDC address for a realm, Shishi will try to
look up the information from DNS.  In order for Shishi to find that
information, you need to add the information to DNS.  For this to work
well, you need to set up a DNS zone with the same name as your Kerberos
realm.  The easiest is if you own the publicly visible DNS name, such
as `example.org' if your realm is `EXAMPLE.ORG', but you can set up an
internal DNS server with the information for your realm only.  If this
is done, you do not need to keep configuration files updated for the
KDC addressing information.

3.5.1 DNS vs. Kerberos - Case Sensitivity of Realm Names
--------------------------------------------------------

In Kerberos, realm names are case sensitive.  While it is strongly
encouraged that all realm names be all upper case this recommendation
has not been adopted by all sites.  Some sites use all lower case names
and other use mixed case.  DNS on the other hand is case insensitive
for queries but is case preserving for responses to TXT queries.  Since
"MYREALM", "myrealm", and "MyRealm" are all different it is necessary
that only one of the possible combinations of upper and lower case
characters be used.  This restriction may be lifted in the future as
the DNS naming scheme is expanded to support non-ASCII names.

3.5.2 Overview - KDC location information
-----------------------------------------

KDC location information is to be stored using the DNS SRV RR [RFC
2052].  The format of this RR is as follows:

   Service.Proto.Realm TTL Class SRV Priority Weight Port Target

   The Service name for Kerberos is always "_kerberos".

   The Proto can be either "_udp", "_tcp", or "_tls._tcp".  If these SRV
records are to be used, a "_udp" record MUST be included.  If the
Kerberos implementation supports TCP transport, a "_tcp" record MUST be
included.  When using "_tcp" with "_kerberos", this indicates a "raw"
TCP connection without any additional encapsulation.  A "_tls._tcp"
record MUST be specified for all Kerberos implementations that support
communication with the KDC across TCP sockets encapsulated using TLS
[RFC2246] (*note STARTTLS protected KDC exchanges::).

   The Realm is the Kerberos realm that this record corresponds to.

   TTL, Class, SRV, Priority, Weight, and Target have the standard
meaning as defined in RFC 2052.

   As per RFC 2052 the Port number should be the value assigned to
"kerberos" by the Internet Assigned Number Authority (88).

3.5.3 Example - KDC location information
----------------------------------------

These are DNS records for a Kerberos realm ASDF.COM.  It has two
Kerberos servers, kdc1.asdf.com and kdc2.asdf.com.  Queries should be
directed to kdc1.asdf.com first as per the specified priority.  Weights
are not used in these records.

     _kerberos._udp.ASDF.COM.        IN      SRV     0 0 88 kdc1.asdf.com.
     _kerberos._udp.ASDF.COM.        IN      SRV     1 0 88 kdc2.asdf.com.
     _kerberos._tcp.ASDF.COM.        IN      SRV     0 0 88 kdc1.asdf.com.
     _kerberos._tcp.ASDF.COM.        IN      SRV     1 0 88 kdc2.asdf.com.
     _kerberos._tls._tcp.ASDF.COM.   IN      SRV     0 0 88 kdc1.asdf.com.
     _kerberos._tls._tcp.ASDF.COM.   IN      SRV     1 0 88 kdc2.asdf.com.

3.5.4 Security considerations
-----------------------------

As DNS is deployed today, it is an unsecure service.  Thus the infor-
mation returned by it cannot be trusted.

   Current practice for REALM to KDC mapping is to use hostnames to
indicate KDC hosts (stored in some implementation-dependent location,
but generally a local config file).  These hostnames are vulnerable to
the standard set of DNS attacks (denial of service, spoofed entries,
etc).  The design of the Kerberos protocol limits attacks of this sort
to denial of service.  However, the use of SRV records does not change
this attack in any way.  They have the same vulnerabilities that
already exist in the common practice of using hostnames for KDC
locations.

   Implementations SHOULD provide a way of specifying this information
locally without the use of DNS.  However, to make this feature
worthwhile a lack of any configuration information on a client should
be interpretted as permission to use DNS.


File: shishi.info,  Node: Kerberos via TLS,  Next: Multiple servers,  Prev: Configuring DNS for KDC,  Up: Administration Manual

3.6 Kerberos via TLS
====================

If Shishi is built with support for GNUTLS, the messages exchanged
between clients and Shishid can be protected with TLS.  TLS is only
available over TCP connections.  A full discussion of the features TLS
have is out of scope here, but in short it means the communication is
integrity and privacy protected, and that users can use OpenPGP, X.509
or SRP (i.e., any mechanism supported by TLS) to authenticate
themselves to the Kerberos server.  For details on the implementation,
*Note STARTTLS protected KDC exchanges::.

3.6.1 Setting up TLS resume
---------------------------

Resuming earlier TLS session is supported and enabled by default.  This
improves the speed of the TLS handshake, because results from earlier
negotiations can be re-used.  Currently the TLS resume database is
stored in memory (in constract to storing it on disk), in both the
client and in the server.  Because the server typically runs for a long
time, this is not a problem for that side.  The client is typically not
a long-running process though; the client usually is invoked as part of
applications like `telnet' or `login'.  However, because each use of
the client library typically result in a ticket, which is stored on
disk and re-used by later processes, this is likely not a serious
problem because the number of different tickets required by a user is
usually quite small.  For the client, TLS resume is typically only
useful when you perform an initial authentication (using a password)
followed by a ticket request for a service, in the same process.

   You can configure the server, `shishid' to never use TLS resume, or
to increase or decrease the number of distinct TLS connections that can
be resumed before they are garbage collected, see the `--resume-limit'
parameter (*note Parameters for shishid::).

3.6.2 Setting up Anonymous TLS
------------------------------

Anonymous TLS is the simplest to set up and use.  In fact, only the
client need to be informed that your KDC support TLS.  This can be done
in the configuration file with the `/tls' parameter for `kdc-realm'
(*note Shishi Configuration: realm-kdc.), or by placing the KDC address
in DNS using the `_tls' SRV record (*note Configuring DNS for KDC::).

   Let's start Shishid, listening on a TCP socket.  TLS require TCP.
TCP sockets are automatically upgraded to TLS if the client request it.

     jas@latte:~$ /usr/local/sbin/shishid -l IPv4:*:4711/tcp
     Initializing GNUTLS...done
     Listening on IPv4:*:4711/tcp...
     Listening on 1 ports...
     shishid: Starting (GNUTLS `1.0.4')
     shishid: Listening on IPv4:*:4711/tcp socket 4

   Let's use the client to talk with it, using TLS.

     jas@latte:~$ shishi -o 'realm-kdc=EXAMPLE.ORG,localhost:4711/tls \
         simon@EXAMPLE.ORG
     Enter password for `simon@EXAMPLE.ORG':
     simon@EXAMPLE.ORG:
     Authtime:       Tue Dec 16 05:20:47 2003
     Endtime:        Tue Dec 16 05:37:27 2003
     Server:         krbtgt/EXAMPLE.ORG key aes256-cts-hmac-sha1-96 (18)
     Ticket key:     aes256-cts-hmac-sha1-96 (18) protected by aes256-cts-hmac-sha1-96 (18)
     Ticket flags:   FORWARDED PROXIABLE (12)
     jas@latte:~$

   On success, the server will print the following debug information.

     shishid: Accepted socket 6 from socket 4 as IPv4:*:4711/tcp peer 127.0.0.1
     shishid: Listening on IPv4:*:4711/tcp socket 4
     shishid: Listening on IPv4:*:4711/tcp peer 127.0.0.1 socket 6
     shishid: Has 4 bytes from IPv4:*:4711/tcp peer 127.0.0.1 on socket 6
     shishid: Trying STARTTLS
     shishid: TLS handshake negotiated protocol `TLS 1.0', key exchange `Anon DH', certficate type `X.509', cipher `AES 256 CBC', mac `SHA', compression `NULL', session not resumed
     shishid: TLS anonymous authentication with 1024 bit Diffie-Hellman
     shishid: Listening on IPv4:*:4711/tcp socket 4
     shishid: Listening on IPv4:*:4711/tcp peer 127.0.0.1 socket 6
     shishid: Has 131 bytes from IPv4:*:4711/tcp peer 127.0.0.1 on socket 6
     shishid: Processing 131 from IPv4:*:4711/tcp peer 127.0.0.1 on socket 6
     shishid: Trying AS-REQ
     shishid: AS-REQ from simon@EXAMPLE.ORG for krbtgt/EXAMPLE.ORG@EXAMPLE.ORG
     shishid: Matching client etype 18 against user key etype 18
     shishid: Have 511 bytes for IPv4:*:4711/tcp peer 127.0.0.1 on socket 6
     shishid: Sending 511 bytes to IPv4:*:4711/tcp peer 127.0.0.1 socket 6 via TLS
     shishid: Listening on IPv4:*:4711/tcp socket 4
     shishid: Listening on IPv4:*:4711/tcp peer 127.0.0.1 socket 6
     shishid: Peer IPv4:*:4711/tcp peer 127.0.0.1 disconnected on socket 6
     shishid: Closing IPv4:*:4711/tcp peer 127.0.0.1 socket 6
     shishid: Listening on IPv4:*:4711/tcp socket 4

3.6.3 Setting up X.509 authenticated TLS
----------------------------------------

Setting up X.509 authentication is slightly more complicated than
anonymous authentication.  You need a X.509 certificate authority (CA)
that can generate certificates for your Kerberos server and Kerberos
clients.  It is often easiest to setup the CA yourself.  Managing a CA
can be a daunting task, and we only give the bare essentials to get
things up and running.  We suggest that you study the relevant
literature.  As a first step beyond this introduction, you may wish to
explore more secure forms of key storage than storing them unencrypted
on disk.

   The following three sections describe how you create the CA, KDC
certificate, and client certificates.  You can use any tool you like
for this task, as long as they generate X.509 (PKIX) certificates in
PEM format and RSA keys in PKCS#1 format.  Here we use `certtool' that
come with GNUTLS, which is widely available.  We conclude by discussing
how you use these certificates in the KDC and in the Shishi client.

3.6.3.1 Create a Kerberos Certificate Authority
...............................................

First create a CA key.

     jas@latte:~$ certtool --generate-privkey \
        --outfile /usr/local/etc/shishi/shishi.key
     Generating a private key...
     Generating a 1024 bit RSA private key...
     jas@latte:~$

   Then create the CA certificate.  Use whatever details you prefer.

     jas@latte:~$ certtool --generate-self-signed \
        --load-privkey /usr/local/etc/shishi/shishi.key \
        --outfile /usr/local/etc/shishi/shishi.cert
     Generating a self signed certificate...
     Please enter the details of the certificate's distinguished name. \
     Just press enter to ignore a field.
     Country name (2 chars): SE
     Organization name: Shishi Example CA
     Organizational unit name:
     Locality name:
     State or province name:
     Common name: CA
     This field should not be used in new certificates.
     E-mail:
     Enter the certificate's serial number (decimal): 0


     Activation/Expiration time.
     The generated certificate will expire in (days): 180


     Extensions.
     Does the certificate belong to an authority? (Y/N): y
     Is this a web server certificate? (Y/N): n
     Enter the e-mail of the subject of the certificate:


     X.509 certificate info:

     Version: 3
     Serial Number (hex): 00
     Validity:
             Not Before: Sun Dec 21 10:59:00 2003
             Not After: Fri Jun 18 11:59:00 2004
     Subject: C=SE,O=Shishi Example CA,CN=CA
     Subject Public Key Info:
             Public Key Algorithm: RSA

     X.509 Extensions:
             Basic Constraints: (critical)
                     CA:TRUE

     Is the above information ok? (Y/N): y


     Signing certificate...
     jas@latte:~$

3.6.3.2 Create a Kerberos KDC Certificate
.........................................

First create the key for the KDC.

     jas@latte:~$ certtool --generate-privkey \
        --outfile /usr/local/etc/shishi/shishid.key
     Generating a private key...
     Generating a 1024 bit RSA private key...
     jas@latte:~$

   Then create actual KDC certificate, signed by the CA certificate
created in the previous step.

     jas@latte:~$ certtool --generate-certificate \
        --load-ca-certificate /usr/local/etc/shishi/shishi.cert \
        --load-ca-privkey /usr/local/etc/shishi/shishi.key \
        --load-privkey /usr/local/etc/shishi/shishid.key \
        --outfile /usr/local/etc/shishi/shishid.cert
     Generating a signed certificate...
     Loading CA's private key...
     Loading CA's certificate...
     Please enter the details of the certificate's distinguished name. \
     Just press enter to ignore a field.
     Country name (2 chars): SE
     Organization name: Shishi Example KDC
     Organizational unit name:
     Locality name:
     State or province name:
     Common name: KDC
     This field should not be used in new certificates.
     E-mail:
     Enter the certificate's serial number (decimal): 0


     Activation/Expiration time.
     The generated certificate will expire in (days): 180


     Extensions.
     Does the certificate belong to an authority? (Y/N): n
     Is this a web server certificate? (Y/N): n
     Enter the e-mail of the subject of the certificate:


     X.509 certificate info:

     Version: 3
     Serial Number (hex): 00
     Validity:
             Not Before: Sun Dec 21 11:02:00 2003
             Not After: Fri Jun 18 12:02:00 2004
     Subject: C=SE,O=Shishi Example KDC,CN=KDC
     Subject Public Key Info:
             Public Key Algorithm: RSA

     X.509 Extensions:
             Basic Constraints: (critical)
                     CA:FALSE

     Is the above information ok? (Y/N): y


     Signing certificate...
     jas@latte:~$

3.6.3.3 Create a Kerberos Client Certificate
............................................

First create the key for the client.

     jas@latte:~$ certtool --generate-privkey \
        --outfile ~/.shishi/client.key
     Generating a private key...
     Generating a 1024 bit RSA private key...
     jas@latte:~$

   Then create the client certificate, signed by the CA.  An
alternative would be to have the KDC sign the client certificates.

     jas@latte:~$ certtool --generate-certificate \
        --load-ca-certificate /usr/local/etc/shishi/shishi.cert \
        --load-ca-privkey /usr/local/etc/shishi/shishi.key \
        --load-privkey ~/.shishi/client.key \
        --outfile ~/.shishi/client.certs
     Generating a signed certificate...
     Loading CA's private key...
     Loading CA's certificate...
     Please enter the details of the certificate's distinguished name. \
     Just press enter to ignore a field.
     Country name (2 chars): SE
     Organization name: Shishi Example Client
     Organizational unit name:
     Locality name:
     State or province name:
     Common name: Client
     This field should not be used in new certificates.
     E-mail:
     Enter the certificate's serial number (decimal): 0


     Activation/Expiration time.
     The generated certificate will expire in (days): 180


     Extensions.
     Does the certificate belong to an authority? (Y/N): n
     Is this a web server certificate? (Y/N): n
     Enter the e-mail of the subject of the certificate:


     X.509 certificate info:

     Version: 3
     Serial Number (hex): 00
     Validity:
             Not Before: Sun Dec 21 11:04:00 2003
             Not After: Fri Jun 18 12:04:00 2004
     Subject: C=SE,O=Shishi Example Client,CN=Client
     Subject Public Key Info:
             Public Key Algorithm: RSA

     X.509 Extensions:
             Basic Constraints: (critical)
                     CA:FALSE

     Is the above information ok? (Y/N): y


     Signing certificate...
     jas@latte:~$

3.6.3.4 Starting KDC with X.509 authentication support
......................................................

The KDC need the CA certificate (to verify client certificates) and the
server certificate and key (to authenticate itself to the clients).
See elsewhere (*note Parameters for shishid::) for the entire
description of the parameters.

     jas@latte:~$ shishid -l *:4711/tcp \
        --x509cafile /usr/local/etc/shishi/shishi.cert \
        --x509certfile /usr/local/etc/shishi/shishid.cert \
        --x509keyfile /usr/local/etc/shishi/shishid.key
     Initializing GNUTLS...
     Parsed 1 CAs...
     Loaded server certificate/key...
     Generating Diffie-Hellman parameters...
     Initializing GNUTLS...done
     Listening on *:4711/tcp...
     Listening on 1 ports...
     shishid: Starting (GNUTLS `1.0.4')
     shishid: Listening on *:4711/tcp socket 4

   Then acquire tickets as usual.  In case you wonder how shishi finds
the client certificate and key, the filenames used above when
generating the client certificates happen to be the default filenames
for these files.  So it pick them up automatically.

     jas@latte:~$ shishi -o 'realm-kdc=EXAMPLE.ORG,localhost:4711/tls' \
        simon@EXAMPLE.ORG
     Enter password for `simon@EXAMPLE.ORG':
     simon@EXAMPLE.ORG:
     Authtime:       Sun Dec 21 11:15:47 2003
     Endtime:        Sun Dec 21 11:32:27 2003
     Server:         krbtgt/EXAMPLE.ORG key aes256-cts-hmac-sha1-96 (18)
     Ticket key:     aes256-cts-hmac-sha1-96 (18) protected by aes256-cts-hmac-sha1-96 (18)
     Ticket flags:   FORWARDED PROXIABLE RENEWABLE HWAUTHENT TRANSITEDPOLICYCHECKED OKASDELEGATE (12)
     jas@latte:~$

   Here is what the server would print.

     shishid: Accepted socket 6 from socket 4 as *:4711/tcp peer 127.0.0.1
     shishid: Listening on *:4711/tcp socket 4
     shishid: Listening on *:4711/tcp peer 127.0.0.1 socket 6
     shishid: Has 4 bytes from *:4711/tcp peer 127.0.0.1 on socket 6
     shishid: Trying STARTTLS
     shishid: TLS handshake negotiated protocol `TLS 1.0', key exchange `RSA', certficate type `X.509', cipher `AES 256 CBC', mac `SHA', compression `NULL', session not resumed
     shishid: TLS client certificate `C=SE,O=Shishi Example Client,CN=Client', issued by `C=SE,O=Shishi Example CA,CN=CA', serial number `00', MD5 fingerprint `a5:d3:1f:58:76:e3:58:cd:2d:eb:f7:45:a2:4b:52:f9:', activated `Sun Dec 21 11:04:00 2003', expires `Fri Jun 18 12:04:00 2004', version #3, key RSA modulus 1024 bits, currently EXPIRED
     shishid: Listening on *:4711/tcp socket 4
     shishid: Listening on *:4711/tcp peer 127.0.0.1 socket 6
     shishid: Has 131 bytes from *:4711/tcp peer 127.0.0.1 on socket 6
     shishid: Processing 131 from *:4711/tcp peer 127.0.0.1 on socket 6
     shishid: Trying AS-REQ
     shishid: AS-REQ from simon@EXAMPLE.ORG for krbtgt/EXAMPLE.ORG@EXAMPLE.ORG
     shishid: Matching client etype 18 against user key etype 18
     shishid: Have 511 bytes for *:4711/tcp peer 127.0.0.1 on socket 6
     shishid: Sending 511 bytes to *:4711/tcp peer 127.0.0.1 socket 6 via TLS
     shishid: Listening on *:4711/tcp socket 4
     shishid: Listening on *:4711/tcp peer 127.0.0.1 socket 6
     shishid: Peer *:4711/tcp peer 127.0.0.1 disconnected on socket 6
     shishid: Closing *:4711/tcp peer 127.0.0.1 socket 6
     shishid: Listening on *:4711/tcp socket 4


File: shishi.info,  Node: Multiple servers,  Next: Developer information,  Prev: Kerberos via TLS,  Up: Administration Manual

3.7 Multiple servers
====================

Setting up multiple servers is as easy as replicating the user
database.  Since the default `file' user database is stored in the
normal file system, you can use any common tools to replicate a file
system.  Network file system like NFS (properly secured by, e.g., a
point-to-point symmetrically encrypted IPSEC connection) and file
synchronizing tools like `rsync' are typical choices.

   The secondary server should be configured just like the master
server.  If you use the `file' database over NFS you do not have to
make any modifications.  If you use, e.g., a cron job to `rsync' the
directory every hour or so, you may want to add a `--read-only' flag to
the Shisa `db' definition (*note Shisa Configuration::).  That way,
nobody will be lured into creating or changing information in the
database on the secondary server, which only would be overwritten
during the next synchronization.

     db --read-only file /usr/local/var/backup-shishi

   The `file' database is designed so it doesn't require file locking
in the file system, which may be unreliable in some network file
systems or implementations.  It is also designed so that multiple
concurrent readers and writers may access the database without causing
corruption.

   *Warning:* The last paragraph is currently not completely accurate.
There may be race conditions with concurrent writers.  None should
cause infinite loops or data loss.  However, unexpected results might
occur if two writers try to update information about a principal
simultaneous.

   If you use a remote LDAP server or SQL database to store the user
database, and access it via a Shisa backend, you have make sure your
Shisa backend handle concurrent writers properly.  If you use a modern
SQL database, this probably is not a concern.  If it is a problem, you
may be able to work around it by implementing some kind of
synchronization or semaphore mechanism.  If all else sounds too
complicated, you can set up the secondary servers as `--read-only'
servers, although you will lose some functionality (like changing
passwords via the secondary server, or updating timestamps when the
last ticket request occurred).

   One function that is of particular use for users with remote
databases (be it LDAP or SQL) is the "database override" feature.
Using this you can have the security critical principals (such as the
ticket granting ticket) stored on local file system storage, but use
the remote database for user principals.  Of course, you must keep the
local file system storage synchronized between all servers, as before.
Here is an example configuration.

     db --read-only file /var/local/master
     db ldap kdc.example.org ca=/etc/shisa/kdc-ca.pem

   This instruct the Shisa library to access the two databases
sequentially, for each query using the first database that know about
the requested principal.  If you put the `krbtgt/REALM' principal in
the local `file' database, this will override the LDAP interface.
Naturally, you can have as many `db' definition lines as you wish.

   Users with remote databases can also investigate a so called High
Availability mode.  This is useful if you wish to have your Kerberos
servers be able to continue to operate even when the remote database is
offline.  This is achieved via the `--ignore-errors' flag in the
database definition.  Here is a sample configuration.

     db --ignore-errors ldap kdc.example.org ca=/etc/shisa/kdc-ca.pem
     db --read-only file /var/cache/ldap-copy

   This instruct the Shisa library to try the LDAP backend first, but
if it fails, instead of returning an error, continue to try the
operation on a read only local `file' based database.  Of course, write
requests will still fail, but it may be better than halting the server
completely.  To make this work, you first need to set up a cron job on
a, say, hourly basis, to make a copy of the remote database and store
it in the local file database.  That way, when the remote server goes
away, fairly current information will still be available locally.

   If you also wish to experiment with read-write fail over, here is an
idea for the configuration.

     db --ignore-errors ldap kdc.example.org ca=/etc/shisa/kdc-ca.pem
     db --ignore-errors --read-only file /var/cache/ldap-copy
     db file /var/cache/local-updates

   This is similar to the previous, but it will ignore errors reading
and writing from the first two databases, ultimately causing write
attempts to end up in the final `file' based database.  Of course, you
would need to create tools to feed back any local updates made while
the remote server was down.  It may also be necessary to create a
special backend for this purpose, which can auto create principals that
are used.

   We finish with an example that demonstrate all the ideas presented.

     db --read-only file /var/local/master
     db --ignore-errors ldap kdc.example.org ca=/etc/shisa/kdc-ca.pem
     db --ignore-errors --read-only file /var/cache/ldap-copy
     db file /var/cache/local-updates


File: shishi.info,  Node: Developer information,  Prev: Multiple servers,  Up: Administration Manual

3.8 Developer information
=========================

The Programming API for Shisa is described below (*note Kerberos
Database Functions::); this section is about extending Shisa, and
consequently Shishi, to use your own user database system.  You may
want to store your Kerberos user information on an LDAP database
server, for example.

   Adding a new backend is straight forward.  You need to implement the
backend API function set, add the list of API functions to `db/db.c'
and possibly also add any library dependencies to the Makefile.

   The simplest way to write a new backend is to start from the existing
`file' based database, in `db/file.c', and modify the entry points as
needed.

   Note that the current backend API will likely change before it is
frozen.  We may describe it in detail here when it has matured.
However, currently it is similar to the external Shisa API (*note
Kerberos Database Functions::).

   There should be no need to modify anything else in the Shisa library,
and certainly not in the Shishi library or the `shishid' server.

   Naturally, we would appreciate if you would send us your new backend,
if you believe it is generally useful (*note Bug Reports::).


File: shishi.info,  Node: Reference Manual,  Next: Programming Manual,  Prev: Administration Manual,  Up: Top

4 Reference Manual
******************

This chapter discuss the underlying assumptions of Kerberos, contain a
glossary to Kerberos concepts, give you background information on
choosing realm and principal names, and describe all parameters and
configuration file syntaxes for the Shishi tools.

* Menu:

* Environmental Assumptions::   Kerberos 5 assumptions about your system.
* Glossary of terms::           Glossary of Kerberos related terminology.
* Realm and Principal Naming::  How to name your realm and principals.
* Shishi Configuration::        Explains the Core Shishi configuration file.
* Shisa Configuration::         Explains the Shisa database definition file.
* Parameters for shishi::       Command line parameters for 'shishi'.
* Parameters for shishid::      Command line parameters for 'shishid'.
* Parameters for shisa::        Command line parameters for 'shisa'.
* Environment variables::       Overriding compile-time defaults at run-time.
* Date input formats::          Details of the understood date formats.


File: shishi.info,  Node: Environmental Assumptions,  Next: Glossary of terms,  Up: Reference Manual

4.1 Environmental Assumptions
=============================

Kerberos imposes a few assumptions on the environment in which it can
properly function:

   * "Denial of service" attacks are not solved with Kerberos. There
     are places in the protocols where an intruder can prevent an
     application from participating in the proper authentication steps.
     Detection and solution of such attacks (some of which can appear
     to be not-uncommon "normal" failure modes for the system) is
     usually best left to the human administrators and users.

   * Principals MUST keep their secret keys secret. If an intruder
     somehow steals a principal's key, it will be able to masquerade as
     that principal or impersonate any server to the legitimate
     principal.

   * "Password guessing" attacks are not solved by Kerberos. If a user
     chooses a poor password, it is possible for an attacker to
     successfully mount an offline dictionary attack by repeatedly
     attempting to decrypt, with successive entries from a dictionary,
     messages obtained which are encrypted under a key derived from the
     user's password.

   * Each host on the network MUST have a clock which is "loosely
     synchronized" to the time of the other hosts; this synchronization
     is used to reduce the bookkeeping needs of application servers
     when they do replay detection. The degree of "looseness" can be
     configured on a per-server basis, but is typically on the order of
     5 minutes. If the clocks are synchronized over the network, the
     clock synchronization protocol MUST itself be secured from network
     attackers.

   * Principal identifiers are not recycled on a short-term basis. A
     typical mode of access control will use access control lists
     (ACLs) to grant permissions to particular principals. If a stale
     ACL entry remains for a deleted principal and the principal
     identifier is reused, the new principal will inherit rights
     specified in the stale ACL entry. By not re-using principal
     identifiers, the danger of inadvertent access is removed.


File: shishi.info,  Node: Glossary of terms,  Next: Realm and Principal Naming,  Prev: Environmental Assumptions,  Up: Reference Manual

4.2 Glossary of terms
=====================

Authentication
     Verifying the claimed identity of a principal.

Authentication header
     A record containing a Ticket and an Authenticator to be presented
     to a server as part of the authentication process.

Authentication path
     A sequence of intermediate realms transited in the authentication
     process when communicating from one realm to another.

Authenticator
     A record containing information that can be shown to have been
     recently generated using the session key known only by the client
     and server.

Authorization
     The process of determining whether a client may use a service,
     which objects the client is allowed to access, and the type of
     access allowed for each.

Capability
     A token that grants the bearer permission to access an object or
     service. In Kerberos, this might be a ticket whose use is
     restricted by the contents of the authorization data field, but
     which lists no network addresses, together with the session key
     necessary to use the ticket.

Ciphertext
     The output of an encryption function. Encryption transforms
     plaintext into ciphertext.

Client
     A process that makes use of a network service on behalf of a user.
     Note that in some cases a Server may itself be a client of some
     other server (e.g. a print server may be a client of a file
     server).

Credentials
     A ticket plus the secret session key necessary to successfully use
     that ticket in an authentication exchange.

Encryption Type (etype)
     When associated with encrypted data, an encryption type identifies
     the algorithm used to encrypt the data and is used to select the
     appropriate algorithm for decrypting the data.  Encryption type
     tags are communicated in other messages to enumerate algorithms
     that are desired, supported, preferred, or allowed to be used for
     encryption of data between parties.  This preference is combined
     with local information and policy to select an algorithm to be
     used.

KDC
     Key Distribution Center, a network service that supplies tickets
     and temporary session keys; or an instance of that service or the
     host on which it runs. The KDC services both initial ticket and
     ticket-granting ticket requests. The initial ticket portion is
     sometimes referred to as the Authentication Server (or service).
     The ticket-granting ticket portion is sometimes referred to as the
     ticket-granting server (or service).

Kerberos
     The name given to the Project Athena's authentication service, the
     protocol used by that service, or the code used to implement the
     authentication service.  The name is adopted from the three-headed
     dog which guards Hades.

Key Version Number (kvno)
     A tag associated with encrypted data identifies which key was used
     for encryption when a long lived key associated with a principal
     changes over time.  It is used during the transition to a new key
     so that the party decrypting a message can tell whether the data
     was encrypted using the old or the new key.

Plaintext
     The input to an encryption function or the output of a decryption
     function. Decryption transforms ciphertext into plaintext.

Principal
     A named client or server entity that participates in a network
     communication, with one name that is considered canonical.

Principal identifier
     The canonical name used to uniquely identify each different
     principal.

Seal
     To encipher a record containing several fields in such a way that
     the fields cannot be individually replaced without either
     knowledge of the encryption key or leaving evidence of tampering.

Secret key
     An encryption key shared by a principal and the KDC, distributed
     outside the bounds of the system, with a long lifetime. In the
     case of a human user's principal, the secret key MAY be derived
     from a password.

Server
     A particular Principal which provides a resource to network
     clients.  The server is sometimes referred to as the Application
     Server.

Service
     A resource provided to network clients; often provided by more
     than one server (for example, remote file service).

Session key
     A temporary encryption key used between two principals, with a
     lifetime limited to the duration of a single login "session".  In
     the Kerberos system, a session key is generated by the KDC.  The
     session key is distinct from the sub-session key, described next..

Sub-session key
     A temporary encryption key used between two principals, selected
     and exchanged by the principals using the session key, and with a
     lifetime limited to the duration of a single association. The sub-
     session key is also referred to as the subkey.

Ticket
     A record that helps a client authenticate itself to a server; it
     contains the client's identity, a session key, a timestamp, and
     other information, all sealed using the server's secret key. It
     only serves to authenticate a client when presented along with a
     fresh Authenticator.


File: shishi.info,  Node: Realm and Principal Naming,  Next: Shishi Configuration,  Prev: Glossary of terms,  Up: Reference Manual

4.3 Realm and Principal Naming
==============================

This section contains the discussion on naming realms and principals
from the Kerberos specification.

4.3.1 Realm Names
-----------------

Although realm names are encoded as GeneralStrings and although a realm
can technically select any name it chooses, interoperability across
realm boundaries requires agreement on how realm names are to be
assigned, and what information they imply.

   To enforce these conventions, each realm MUST conform to the
conventions itself, and it MUST require that any realms with which
inter-realm keys are shared also conform to the conventions and require
the same from its neighbors.

   Kerberos realm names are case sensitive. Realm names that differ only
in the case of the characters are not equivalent. There are presently
three styles of realm names: domain, X500, and other. Examples of each
style follow:

          domain:   ATHENA.MIT.EDU
            X500:   C=US/O=OSF
           other:   NAMETYPE:rest/of.name=without-restrictions

   Domain syle realm names MUST look like domain names: they consist of
components separated by periods (.) and they contain neither colons (:)
nor slashes (/). Though domain names themselves are case insensitive,
in order for realms to match, the case must match as well. When
establishing a new realm name based on an internet domain name it is
recommended by convention that the characters be converted to upper
case.

   X.500 names contain an equal (=) and cannot contain a colon (:)
before the equal. The realm names for X.500 names will be string
representations of the names with components separated by slashes.
Leading and trailing slashes will not be included. Note that the slash
separator is consistent with Kerberos implementations based on RFC1510,
but it is different from the separator recommended in RFC2253.

   Names that fall into the other category MUST begin with a prefix that
contains no equal (=) or period (.) and the prefix MUST be followed by
a colon (:) and the rest of the name. All prefixes must be assigned
before they may be used. Presently none are assigned.

   The reserved category includes strings which do not fall into the
first three categories. All names in this category are reserved. It is
unlikely that names will be assigned to this category unless there is a
very strong argument for not using the 'other' category.

   These rules guarantee that there will be no conflicts between the
various name styles. The following additional constraints apply to the
assignment of realm names in the domain and X.500 categories: the name
of a realm for the domain or X.500 formats must either be used by the
organization owning (to whom it was assigned) an Internet domain name
or X.500 name, or in the case that no such names are registered,
authority to use a realm name MAY be derived from the authority of the
parent realm. For example, if there is no domain name for E40.MIT.EDU,
then the administrator of the MIT.EDU realm can authorize the creation
of a realm with that name.

   This is acceptable because the organization to which the parent is
assigned is presumably the organization authorized to assign names to
its children in the X.500 and domain name systems as well. If the
parent assigns a realm name without also registering it in the domain
name or X.500 hierarchy, it is the parent's responsibility to make sure
that there will not in the future exist a name identical to the realm
name of the child unless it is assigned to the same entity as the realm
name.

4.3.2 Principal Names
---------------------

As was the case for realm names, conventions are needed to ensure that
all agree on what information is implied by a principal name.  The
name-type field that is part of the principal name indicates the kind
of information implied by the name. The name-type SHOULD be treated
only as a hint to interpreting the meaning of a name. It is not
significant when checking for equivalence. Principal names that differ
only in the name-type identify the same principal. The name type does
not partition the name space. Ignoring the name type, no two names can
be the same (i.e. at least one of the components, or the realm, MUST be
different). The following name types are defined:

     name-type      value   meaning

     NT-UNKNOWN        0  Name type not known
     NT-PRINCIPAL      1  Just the name of the principal as in DCE, or for users
     NT-SRV-INST       2  Service and other unique instance (krbtgt)
     NT-SRV-HST        3  Service with host name as instance (telnet, rcommands)
     NT-SRV-XHST       4  Service with host as remaining components
     NT-UID            5  Unique ID
     NT-X500-PRINCIPAL 6  Encoded X.509 Distingished name [RFC 2253]
     NT-SMTP-NAME      7  Name in form of SMTP email name (e.g. user@foo.com)
     NT-ENTERPRISE    10   Enterprise name - may be mapped to principal name

   When a name implies no information other than its uniqueness at a
particular time the name type PRINCIPAL SHOULD be used. The principal
name type SHOULD be used for users, and it might also be used for a
unique server. If the name is a unique machine generated ID that is
guaranteed never to be reassigned then the name type of UID SHOULD be
used (note that it is generally a bad idea to reassign names of any
type since stale entries might remain in access control lists).

   If the first component of a name identifies a service and the
remaining components identify an instance of the service in a server
specified manner, then the name type of SRV-INST SHOULD be used. An
example of this name type is the Kerberos ticket-granting service whose
name has a first component of krbtgt and a second component identifying
the realm for which the ticket is valid.

   If the first component of a name identifies a service and there is a
single component following the service name identifying the instance as
the host on which the server is running, then the name type SRV- HST
SHOULD be used. This type is typically used for Internet services such
as telnet and the Berkeley R commands. If the separate components of
the host name appear as successive components following the name of the
service, then the name type SRV-XHST SHOULD be used.  This type might
be used to identify servers on hosts with X.500 names where the slash
(/) might otherwise be ambiguous.

   A name type of NT-X500-PRINCIPAL SHOULD be used when a name from an
X.509 certificate is translated into a Kerberos name. The encoding of
the X.509 name as a Kerberos principal shall conform to the encoding
rules specified in RFC 2253.

   A name type of SMTP allows a name to be of a form that resembles a
SMTP email name. This name, including an "@" and a domain name, is used
as the one component of the principal name.

   A name type of UNKNOWN SHOULD be used when the form of the name is
not known. When comparing names, a name of type UNKNOWN will match
principals authenticated with names of any type. A principal
authenticated with a name of type UNKNOWN, however, will only match
other names of type UNKNOWN.

   Names of any type with an initial component of 'krbtgt' are reserved
for the Kerberos ticket granting service. *Note Name of the TGS:
krbtgt, for the form of such names.

4.3.2.1 Name of server principals
.................................

The principal identifier for a server on a host will generally be
composed of two parts: (1) the realm of the KDC with which the server
is registered, and (2) a two-component name of type NT-SRV-HST if the
host name is an Internet domain name or a multi-component name of type
NT-SRV-XHST if the name of the host is of a form such as X.500 that
allows slash (/) separators. The first component of the two- or
multi-component name will identify the service and the latter
components will identify the host. Where the name of the host is not
case sensitive (for example, with Internet domain names) the name of
the host MUST be lower case. If specified by the application protocol
for services such as telnet and the Berkeley R commands which run with
system privileges, the first component MAY be the string 'host' instead
of a service specific identifier.

4.3.2.2 Name of the TGS
.......................

The principal identifier of the ticket-granting service shall be
composed of three parts: (1) the realm of the KDC issuing the TGS
ticket (2) a two-part name of type NT-SRV-INST, with the first part
"krbtgt" and the second part the name of the realm which will accept
the ticket-granting ticket. For example, a ticket-granting ticket
issued by the ATHENA.MIT.EDU realm to be used to get tickets from the
ATHENA.MIT.EDU KDC has a principal identifier of "ATHENA.MIT.EDU"
(realm), ("krbtgt", "ATHENA.MIT.EDU") (name). A ticket-granting ticket
issued by the ATHENA.MIT.EDU realm to be used to get tickets from the
MIT.EDU realm has a principal identifier of "ATHENA.MIT.EDU" (realm),
("krbtgt", "MIT.EDU") (name).

4.3.3 Choosing a principal with which to communicate
----------------------------------------------------

The Kerberos protocol provides the means for verifying (subject to the
assumptions in *note Environmental Assumptions::) that the entity with
which one communicates is the same entity that was registered with the
KDC using the claimed identity (principal name). It is still necessary
to determine whether that identity corresponds to the entity with which
one intends to communicate.

   When appropriate data has been exchanged in advance, this
determination may be performed syntactically by the application based
on the application protocol specification, information provided by the
user, and configuration files. For example, the server principal name
(including realm) for a telnet server might be derived from the user
specified host name (from the telnet command line), the "host/" prefix
specified in the application protocol specification, and a mapping to a
Kerberos realm derived syntactically from the domain part of the
specified hostname and information from the local Kerberos realms
database.

   One can also rely on trusted third parties to make this
determination, but only when the data obtained from the third party is
suitably integrity protected while resident on the third party server
and when transmitted.  Thus, for example, one should not rely on an
unprotected domain name system record to map a host alias to the
primary name of a server, accepting the primary name as the party one
intends to contact, since an attacker can modify the mapping and
impersonate the party with which one intended to communicate.

   Implementations of Kerberos and protocols based on Kerberos MUST NOT
use insecure DNS queries to canonicalize the hostname components of the
service principal names.  In an environment without secure name
service, application authors MAY append a statically configured domain
name to unqualified hostnames before passing the name to the security
mechanisms, but should do no more than that.  Secure name service
facilities, if available, might be trusted for hostname
canonicalization, but such canonicalization by the client SHOULD NOT be
required by KDC implementations.

   Implementation note: Many current implementations do some degree of
canonicalization of the provided service name, often using DNS even
though it creates security problems. However there is no consistency
among implementations about whether the service name is case folded to
lower case or whether reverse resolution is used. To maximize
interoperability and security, applications SHOULD provide security
mechanisms with names which result from folding the user-entered name
to lower case, without performing any other modifications or
canonicalization.

4.3.4 Principal Name Form
-------------------------

Principal names consist of a sequence of strings, which is often
tedious to parse.  Therefor, Shishi often uses a "printed" form of
principal which embed the entire principal name string sequence, and
optionally also the realm, into one string.  The format is taken from
the Kerberos 5 GSS-API mechanism (RFC 1964).

   The elements included within this name representation are as follows,
proceeding from the beginning of the string:

  1. One or more principal name components; if more than one principal
     name component is included, the components are separated by `/`.
     Arbitrary octets may be included within principal name components,
     with the following constraints and special considerations:
       a. Any occurrence of the characters `@` or `/` within a name
          component must be immediately preceded by the `\` quoting
          character, to prevent interpretation as a component or realm
          separator.

       b. The ASCII newline, tab, backspace, and null characters may
          occur directly within the component or may be represented,
          respectively, by `\n`, `\t`, `\b`, or `\0`.

       c. If the `\` quoting character occurs outside the contexts
          described in (1a) and (1b) above, the following character is
          interpreted literally.  As a special case, this allows the
          doubled representation `\\` to represent a single occurrence
          of the quoting character.

       d. An occurrence of the `\` quoting character as the last
          character of a component is illegal.

  2. Optionally, a `@` character, signifying that a realm name
     immediately follows. If no realm name element is included, the
     local realm name is assumed.  The `/` , `:`, and null characters
     may not occur within a realm name; the `@`, newline, tab, and
     backspace characters may be included using the quoting conventions
     described in (1a), (1b), and (1c) above.


File: shishi.info,  Node: Shishi Configuration,  Next: Shisa Configuration,  Prev: Realm and Principal Naming,  Up: Reference Manual

4.4 Shishi Configuration
========================

The valid configuration file tokens are described here.  The user
configuration file is typically located in `~/.shishi/shishi.conf'
(compare `shishi --configuration-file') and the system configuration is
typically located in `/usr/local/etc/shishi/shishi.conf' (compare
`shishi --system-configuration-file').  If the first non white space
character of a line is a '#', the line is ignored.  Empty lines are
also ignored.

   All tokens are valid in both the system and the user configuration
files, and have the same meaning.  However, as the system file is
supposed to apply to all users on a system, it would not make sense to
use some tokens in that file.  For example, the `default-principal' is
rarely useful in a system configuration file.

4.4.1 `default-realm'
---------------------

Specify the default realm, by default the hostname of the host is used.
E.g.,

     default-realm JOSEFSSON.ORG

4.4.2 `default-principal'
-------------------------

Specify the default principal, by default the login username is used.
E.g.,

     default-principal jas

4.4.3 `client-kdc-etypes'
-------------------------

Specify which encryption types client asks server to respond in during
AS/TGS exchanges. List valid encryption types, in preference order.
Supported algorithms include aes256-cts-hmac-sha1-96,
aes128-cts-hmac-sha1-96, des3-cbc-sha1-kd, des-cbc-md5, des-cbc-md4,
des-cbc-crc and null.  This option also indicates which encryption
types are accepted by the client when receiving the response.  Note
that the preference order is not cryptographically protected, so a man
in the middle can modify the order without being detected.  Thus, only
specify encryption types you trust completely here. The default only
includes aes256-cts-hmac-sha1-96, as suggested by RFC1510bis.  E.g.,

     client-kdc-etypes=aes256-cts-hmac-sha1-96 des3-cbc-sha1-kd des-cbc-md5

4.4.4 `verbose', `verbose-asn1', `verbose-noise', `verbose-crypto', `verbose-crypto-noise'
------------------------------------------------------------------------------------------

Enable verbose library messages.  E.g.,

     verbose
     verbose-noise

4.4.5 `realm-kdc'
-----------------

Specify KDC addresses for realms.  Value is
`REALM,KDCADDRESS[/PROTOCOL][,KDCADDRESS[/PROTOCOL]...]'.

   KDCADDRESS is the hostname or IP address of KDC.

   Optional PROTOCOL is udp for UDP, tcp for TCP, and TLS for TLS
connections.  By default UDP is tried first, and TCP used as a fallback
if the KRB_ERR_RESPONSE_TOO_BIG error is received.

   If not specified, Shishi tries to locate the KDC using SRV RRs,
which is recommended.  This option should normally only be used during
experiments, or to access badly maintained realms.

     realm-kdc=JOSEFSSON.ORG,ristretto.josefsson.org

4.4.6 `server-realm'
--------------------

Specify realm for servers. Value is
`REALM,SERVERREGEXP[,SERVERREGEXP...]'.

   SERVERREGEXP is a regular expression matching servers in the realm.
The first match is used.  E.g.,

     server-realm=JOSEFSSON.ORG,.josefsson.org

   Note: currently not used.

4.4.7 `kdc-timeout', `kdc-retries'
----------------------------------

How long shishi waits for a response from a KDC before continuing to
next KDC for realm.  The default is 5 seconds.  E.g.,

     kdc-timeout=10

   How many times shishi sends a request to a KDC before giving up.  The
default is 3 times.  E.g.,

     kdc-retries=5

4.4.8 `stringprocess'
---------------------

How username and passwords entered from the terminal, or taken from the
command line, are processed.

   "none": no processing is used.

   "stringprep": convert from locale charset to UTF-8 and process using
             experimental RFC 1510 stringprep profile.

   It can also be a string indicating a character set supported by
iconv via libstringprep, in which case data is converted from locale
charset into the indicated character set. E.g., UTF-8, ISO-8859-1,
KOI-8, EBCDIC-IS-FRISS are supported on GNU systems.  On some systems
you can use "locale -m" to list available character sets.  By default,
the "none" setting is used which is consistent with RFC 1510 that is
silent on the issue.  In practice, however, converting to UTF-8
improves interoperability.

   E.g.,

     stringprocess=UTF-8

4.4.9 `ticket-life'
-------------------

Specify default ticket life time.

   The string can be in almost any common format.  It can contain month
names, time zones, `am' and `pm', `yesterday', `ago', `next', etc.
*Note Date input formats::, for the long story.

   As an extra feature, if the time specified by your string correspond
to a time during the last 24 hours, an extra day is added to it.  This
allows you to specify relative times such as "17:00" to always mean the
next 17:00, even if your system clock happens to be 17:30.

   The default is 8 hours.

   E.g.,

     #ticket-life=8 hours
     #ticket-life=1 day
     ticket-life=17:00

4.4.10 `renew-life'
-------------------

Specify how long a renewable ticket should remain renewable.

   See ticket-life for the syntax.  The extra feature that handles
negative values within the last 2 hours is not active here.

   The default is 7 days.

   E.g.,

     #renew-life=1 week
     #renew-life=friday 17:00
     renew-life=sunday


File: shishi.info,  Node: Shisa Configuration,  Next: Parameters for shishi,  Prev: Shishi Configuration,  Up: Reference Manual

4.5 Shisa Configuration
=======================

The configuration file for Shisa is typically stored in
`/usr/local/etc/shishi/shisa.conf'.  If the first non white space
character of a line is a '#', the line is ignored.  Empty lines are
also ignored.

4.5.1 `db'
----------

Currently the only configuration options available is the `db' token
that define the databases to use.  The syntax is:

     db [OPTIONS] <TYPE> [LOCATION] [PARAMETERS ...]

   Specify the data sources for Kerberos 5 data.  Multiple entries,
even of the same data source type, are allowed.  The data sources are
accessed in the same sequence as they are defined here.  If an entry is
found in one data source, it will be used for the operations, without
searching the remaining data sources.  Valid OPTIONS include:

     --read-only       No data is written to this data source.
     --ignore-errors   Ignore failures in this backend.

   The default (when the configuration file is empty) uses one "file"
data source (see below), but for a larger installation you may want to
combine several data sources.  Here is an example.

     db --read-only file /var/local/master
     db --ignore-errors ldap kdc.example.org ca=/etc/shisa/kdc-ca.pem
     db --read-only file /var/cache/ldap-copy

   This demonstrate how you can store critical principals on local disk
(the first entry, /var/local/master) that will always be found without
looking in the LDAP directory.  The critical principals could be, e.g.,
krbtgt/EXAMPLE.ORG.  The second entry denote a LDAP server that could
hold user principals.  As you can see, Shisa will not let the caller
know about errors with the LDAP source (they will be logged, however).
Instead, if for instance the LDAP server has crashed, Shisa would
continue and read from the /var/cache/ldap-copy file source.  That file
source may have been set up to contain a copy of the data in the LDAP
server, perhaps made on an hourly basis, so that your server will be
able to serve recent data even in case of a crash.  Any updates or
passwords change requests will however not be possible while the LDAP
server is inaccessible, to reduce the problem of synchronizing data
back into the LDAP server once it is online again.

   Currently only the "file" data source is supported, and denote a
data source that use the standard file system for storage.

   Valid syntaxes for the "file" database:

     db file PATH

   Examples:

     db file /var/shishi
     db file /usr/share/shishi read-only

   If no `db' tokens are present, the default will be:

     db file /usr/local/var/shishi


File: shishi.info,  Node: Parameters for shishi,  Next: Parameters for shishid,  Prev: Shisa Configuration,  Up: Reference Manual

4.6 Parameters for shishi
=========================

If no command is given, Shishi try to make sure you have a ticket
granting ticket for the default realm, and then display it.

   Mandatory arguments to long options are mandatory for short options
too.

     Usage: shishi [OPTIONS]... [CLIENT [SERVER]]...

       -h, --help                              Print help and exit
       -V, --version                           Print version and exit

     Commands:
       -d, --destroy                           Destroy tickets in local cache,
                                                 limited by any --client-name or
                                                 --server-name.  (default=off)
       -l, --list                              List tickets in local cache, limited
                                                 by any --client-name and
                                                 --server-name.  (default=off)
       -r, --renew                             Renew ticket.  Use --server-name to
                                                 specify ticket, default is the
                                                 most recent renewable ticket
                                                 granting ticket for the default
                                                 realm.  (default=off)

     Flags:
           --forwardable                       Get a forwardable ticket, i.e., one
                                                 that can be used to get forwarded
                                                 tickets.  (default=off)
           --forwarded                         Get a forwarded ticket.  (default=
                                                 off)
           --proxiable                         Get a proxiable ticket, i.e., one
                                                 that can be used to get proxy
                                                 tickets.  (default=off)
           --proxy                             Get a proxy ticket.  (default=off)
           --renewable                         Get a renewable ticket.  (default=
                                                 off)

     Options:
           --client-name=NAME                  Client name. Default is login
                                                 username.
       -E, --encryption-type=ETYPE,[ETYPE...]  Encryption types to use.  ETYPE is
                                                 either registered name or integer.
                                                  Valid values include 'aes128',
                                                 'aes256', 'aes' (same as
                                                 'aes256'), '3des', 'des-md5',
                                                 'des-md4', 'des-crc', 'des' (same
                                                 as 'des-md5'), and 'arcfour'.
       -e, --endtime=STRING                    Specify when ticket validity should
                                                 expire.  The time syntax may be
                                                 relative (to the start time), such
                                                 as '20 hours', or absolute, such
                                                 as '2001-02-03 04:05:06 CET'. The
                                                 default is 8 hours after the start
                                                 time.
           --realm=STRING                      Set default realm.
           --renew-till=STRING                 Specify renewable life of ticket.
                                                 Implies --renewable.  Accepts same
                                                 time syntax as --endtime.  If
                                                 --renewable is specified, the
                                                 default is 1 week after the start
                                                 time.
           --server-name=NAME                  Server name. Default is
                                                 'krbtgt/REALM' where REALM is
                                                 client realm.
       -s, --starttime=STRING                  Specify when ticket should start to
                                                 be valid.  Accepts same time
                                                 syntax as --endtime. The default
                                                 is to become valid immediately.
           --ticket-granter=NAME               Service name in ticket to use for
                                                 authenticating request. Only for
                                                 TGS. Defaults to
                                                 'krbtgt/REALM@REALM' where REALM
                                                 is client realm.

     Other options:
           --configuration-file=FILE           Read user configuration from FILE.
       -c, --ticket-file=FILE                  Read tickets from FILE.
       -o, --library-options=STRING            Parse STRING as a configuration file
                                                 statement.
       -q, --quiet                             Don't produce any diagnostic output.
                                                   (default=off)
           --system-configuration-file=FILE    Read system configuration from FILE.
           --ticket-write-file=FILE            Write tickets from FILE.  Default is
                                                 to write them back to where they
                                                 were read from.
       -v, --verbose                           Produce verbose output.
                                                   (default=off)


File: shishi.info,  Node: Parameters for shishid,  Next: Parameters for shisa,  Prev: Parameters for shishi,  Up: Reference Manual

4.7 Parameters for shishid
==========================

If no parameters are specified, `shishid' listens on the defaults
interfaces and answers incoming requests using the keys in the default
key file.

   Mandatory arguments to long options are mandatory for short options
too.

     Usage: shishid [OPTIONS]...

       -h, --help                            Print help and exit
       -V, --version                         Print version and exit

     Commands:
       -l, --listen=[FAMILY:]ADDR:PORT/TYPE  Sockets to listen for queries on.
                                               Family is `IPv4' or `IPv6', if
                                               absent the family is decided by
                                               gethostbyname(ADDR). An address of
                                               `*' indicates all addresses on the
                                               local host. The default is
                                               `IPv4:*:kerberos/udp,
                                               IPv4:*:kerberos/tcp,
                                               IPv6:*:kerberos/udp,
                                               IPv6:*:kerberos/tcp'.
       -u, --setuid=NAME                     After binding socket, set user
                                               identity.

     TLS settings:
           --x509cafile=FILE                 X.509 certificate authorities used to
                                               verify client certificates, in PEM
                                               format.
           --x509certfile=FILE               X.509 server certificate, in PEM
                                               format.
           --x509crlfile=FILE                X.509 certificate revocation list to
                                               check for revoked client
                                               certificates, in PEM format.
           --x509keyfile=FILE                X.509 server certificate key, in PEM
                                               format.
            --resume-limit=SHORT             Keep track of up to this many TLS
                                              sessions for resume purposes (0 to
                                              disable TLS resume).  (default=`50')

     Other options:
       -c, --configuration-file=FILE         Use specified configuration file.
       -v, --verbose                         Produce verbose output.
                                                 (default=off)
       -q, --quiet                           Don't produce any diagnostic output.
                                                 (default=off)


File: shishi.info,  Node: Parameters for shisa,  Next: Environment variables,  Prev: Parameters for shishid,  Up: Reference Manual

4.8 Parameters for shisa
========================

The purpose of `shisa' is to manipulate information stored in the
Kerberos 5 database used by Shishi.

   Mandatory arguments to long options are mandatory for short options
too.

     Usage: shisa [OPTIONS]... [REALM [PRINCIPAL]]...

       -h, --help                         Print help and exit
       -V, --version                      Print version and exit

     Operations:
       -a, --add                          Add realm or principal to database.
       -d, --dump                         Dump entries in database.
       -n, --key-add                      Add new key to a principal in database.
           --key-remove                   Remove a key from a principal in
                                            database.
       -l, --list                         List entries in database.
       -m, --modify                       Modify principal entry in database.
       -r, --remove                       Remove realm or principal from database.

     Parameters:
       -f, --force                        Allow removal of non-empty realms.
                                              (default=off)
           --enabled                      Only dump or list enabled principals.
                                              (default=off)
           --disabled                     Only dump or list disabled principals.
                                              (default=off)
           --keys                         Print cryptographic key and password in
                                            hostkey format.  (default=off)

     Values:
       -E, --encryption-type=STRING       Override default key encryption type.
                                            Valid values include 'aes128',
                                            'aes256', 'aes' (same as 'aes256'),
                                            '3des', 'des-md5', 'des-md4',
                                            'des-crc', 'des' (same as 'des-md5'),
                                            and 'arcfour'.
           --key-version=NUMBER           Version of key.
           --password[=STRING]            Derive key from this password.
           --random                       Use a random key.  (default)
           --salt=STRING                  Use specified salt for deriving key.
                                            Defaults to concatenation of realm and
                                            (unwrapped) principal name.
           --string-to-key-parameter=HEX  Encryption algorithm specific parameter
                                            for password derivation.  Currently
                                            only the AES algorithm can utilize
                                            this, where it is interpreted as the
                                            iteration count of the PKCS#5 PBKDF2
                                            key deriver.

     Other options:
       -c, --configuration-file=FILE      Use specified configuration file.
       -o, --library-options=STRING       Parse string as configuration file
                                            statement.
       -v, --verbose                      Produce verbose output.
                                              (default=off)
       -q, --quiet                        Don't produce any diagnostic output.
                                              (default=off)


File: shishi.info,  Node: Environment variables,  Next: Date input formats,  Prev: Parameters for shisa,  Up: Reference Manual

4.9 Environment variables
=========================

A few of the compile-time defaults may be overridden at run-time by
using environment variables.  The following variables are supported.

   * `SHISHI_CONFIG' Specify the location of the default system
     configuration file.  Used by the Shishi library.  If not
     specified, the default is specified at compile-time and is usually
     `$prefix/etc/shishi.conf'.

   * `SHISHI_HOME' Specify the user specific directory for
     configuration files, ticket cache, etc.  Used by the Shishi
     library.  If not specified, it is computed as `$HOME/.shishi'.

   * `SHISHI_USER' Specify the default principal user name.  Used by
     the Shishi library.  If not specified, it is taken from the
     environment variable `USER'.

   * `SHISHI_TICKETS' Specify the file name of the ticket cache.  Used
     by the Shishi library.  If not specified, it will be
     `$SHISHI_HOME/tickets', or `$HOME/.shishi/tickets' if
     `$SHISHI_HOME' is not specified.



File: shishi.info,  Node: Date input formats,  Prev: Environment variables,  Up: Reference Manual

4.10 Date input formats
=======================

First, a quote:

     Our units of temporal measurement, from seconds on up to months,
     are so complicated, asymmetrical and disjunctive so as to make
     coherent mental reckoning in time all but impossible.  Indeed, had
     some tyrannical god contrived to enslave our minds to time, to
     make it all but impossible for us to escape subjection to sodden
     routines and unpleasant surprises, he could hardly have done
     better than handing down our present system.  It is like a set of
     trapezoidal building blocks, with no vertical or horizontal
     surfaces, like a language in which the simplest thought demands
     ornate constructions, useless particles and lengthy
     circumlocutions.  Unlike the more successful patterns of language
     and science, which enable us to face experience boldly or at least
     level-headedly, our system of temporal calculation silently and
     persistently encourages our terror of time.

     ...  It is as though architects had to measure length in feet,
     width in meters and height in ells; as though basic instruction
     manuals demanded a knowledge of five different languages.  It is
     no wonder then that we often look into our own immediate past or
     future, last Tuesday or a week from Sunday, with feelings of
     helpless confusion.  ...

     -- Robert Grudin, `Time and the Art of Living'.

   This section describes the textual date representations that GNU
programs accept.  These are the strings you, as a user, can supply as
arguments to the various programs.  The C interface (via the `get_date'
function) is not described here.

* Menu:

* General date syntax::            Common rules.
* Calendar date items::            19 Dec 1994.
* Time of day items::              9:20pm.
* Time zone items::                EST, PDT, GMT.
* Day of week items::              Monday and others.
* Relative items in date strings:: next tuesday, 2 years ago.
* Pure numbers in date strings::   19931219, 1440.
* Seconds since the Epoch::        @1078100502.
* Specifying time zone rules::     TZ="America/New_York", TZ="UTC0".
* Authors of get_date::            Bellovin, Eggert, Salz, Berets, et al.


File: shishi.info,  Node: General date syntax,  Next: Calendar date items,  Up: Date input formats

4.10.1 General date syntax
--------------------------

A "date" is a string, possibly empty, containing many items separated
by whitespace.  The whitespace may be omitted when no ambiguity arises.
The empty string means the beginning of today (i.e., midnight).  Order
of the items is immaterial.  A date string may contain many flavors of
items:

   * calendar date items

   * time of day items

   * time zone items

   * day of the week items

   * relative items

   * pure numbers.

We describe each of these item types in turn, below.

   A few ordinal numbers may be written out in words in some contexts.
This is most useful for specifying day of the week items or relative
items (see below).  Among the most commonly used ordinal numbers, the
word `last' stands for -1, `this' stands for 0, and `first' and `next'
both stand for 1.  Because the word `second' stands for the unit of
time there is no way to write the ordinal number 2, but for convenience
`third' stands for 3, `fourth' for 4, `fifth' for 5, `sixth' for 6,
`seventh' for 7, `eighth' for 8, `ninth' for 9, `tenth' for 10,
`eleventh' for 11 and `twelfth' for 12.

   When a month is written this way, it is still considered to be
written numerically, instead of being "spelled in full"; this changes
the allowed strings.

   In the current implementation, only English is supported for words
and abbreviations like `AM', `DST', `EST', `first', `January',
`Sunday', `tomorrow', and `year'.

   The output of the `date' command is not always acceptable as a date
string, not only because of the language problem, but also because
there is no standard meaning for time zone items like `IST'.  When using
`date' to generate a date string intended to be parsed later, specify a
date format that is independent of language and that does not use time
zone items other than `UTC' and `Z'.  Here are some ways to do this:

     $ LC_ALL=C TZ=UTC0 date
     Mon Mar  1 00:21:42 UTC 2004
     $ TZ=UTC0 date +'%Y-%m-%d %H:%M:%SZ'
     2004-03-01 00:21:42Z
     $ date --iso-8601=ns | tr T ' '  # --iso-8601 is a GNU extension.
     2004-02-29 16:21:42,692722128-0800
     $ date --rfc-2822  # a GNU extension
     Sun, 29 Feb 2004 16:21:42 -0800
     $ date +'%Y-%m-%d %H:%M:%S %z'  # %z is a GNU extension.
     2004-02-29 16:21:42 -0800
     $ date +'@%s.%N'  # %s and %N are GNU extensions.
     @1078100502.692722128

   Alphabetic case is completely ignored in dates.  Comments may be
introduced between round parentheses, as long as included parentheses
are properly nested.  Hyphens not followed by a digit are currently
ignored.  Leading zeros on numbers are ignored.

   Invalid dates like `2005-02-29' or times like `24:00' are rejected.
In the typical case of a host that does not support leap seconds, a
time like `23:59:60' is rejected even if it corresponds to a valid leap
second.


File: shishi.info,  Node: Calendar date items,  Next: Time of day items,  Prev: General date syntax,  Up: Date input formats

4.10.2 Calendar date items
--------------------------

A "calendar date item" specifies a day of the year.  It is specified
differently, depending on whether the month is specified numerically or
literally.  All these strings specify the same calendar date:

     1972-09-24     # ISO 8601.
     72-9-24        # Assume 19xx for 69 through 99,
                    # 20xx for 00 through 68.
     72-09-24       # Leading zeros are ignored.
     9/24/72        # Common U.S. writing.
     24 September 1972
     24 Sept 72     # September has a special abbreviation.
     24 Sep 72      # Three-letter abbreviations always allowed.
     Sep 24, 1972
     24-sep-72
     24sep72

   The year can also be omitted.  In this case, the last specified year
is used, or the current year if none.  For example:

     9/24
     sep 24

   Here are the rules.

   For numeric months, the ISO 8601 format `YEAR-MONTH-DAY' is allowed,
where YEAR is any positive number, MONTH is a number between 01 and 12,
and DAY is a number between 01 and 31.  A leading zero must be present
if a number is less than ten.  If YEAR is 68 or smaller, then 2000 is
added to it; otherwise, if YEAR is less than 100, then 1900 is added to
it.  The construct `MONTH/DAY/YEAR', popular in the United States, is
accepted.  Also `MONTH/DAY', omitting the year.

   Literal months may be spelled out in full: `January', `February',
`March', `April', `May', `June', `July', `August', `September',
`October', `November' or `December'.  Literal months may be abbreviated
to their first three letters, possibly followed by an abbreviating dot.
It is also permitted to write `Sept' instead of `September'.

   When months are written literally, the calendar date may be given as
any of the following:

     DAY MONTH YEAR
     DAY MONTH
     MONTH DAY YEAR
     DAY-MONTH-YEAR

   Or, omitting the year:

     MONTH DAY


File: shishi.info,  Node: Time of day items,  Next: Time zone items,  Prev: Calendar date items,  Up: Date input formats

4.10.3 Time of day items
------------------------

A "time of day item" in date strings specifies the time on a given day.
Here are some examples, all of which represent the same time:

     20:02:00.000000
     20:02
     8:02pm
     20:02-0500      # In EST (U.S. Eastern Standard Time).

   More generally, the time of day may be given as
`HOUR:MINUTE:SECOND', where HOUR is a number between 0 and 23, MINUTE
is a number between 0 and 59, and SECOND is a number between 0 and 59
possibly followed by `.' or `,' and a fraction containing one or more
digits.  Alternatively, `:SECOND' can be omitted, in which case it is
taken to be zero.  On the rare hosts that support leap seconds, SECOND
may be 60.

   If the time is followed by `am' or `pm' (or `a.m.' or `p.m.'), HOUR
is restricted to run from 1 to 12, and `:MINUTE' may be omitted (taken
to be zero).  `am' indicates the first half of the day, `pm' indicates
the second half of the day.  In this notation, 12 is the predecessor of
1: midnight is `12am' while noon is `12pm'.  (This is the zero-oriented
interpretation of `12am' and `12pm', as opposed to the old tradition
derived from Latin which uses `12m' for noon and `12pm' for midnight.)

   The time may alternatively be followed by a time zone correction,
expressed as `SHHMM', where S is `+' or `-', HH is a number of zone
hours and MM is a number of zone minutes.  The zone minutes term, MM,
may be omitted, in which case the one- or two-digit correction is
interpreted as a number of hours.  You can also separate HH from MM
with a colon.  When a time zone correction is given this way, it forces
interpretation of the time relative to Coordinated Universal Time
(UTC), overriding any previous specification for the time zone or the
local time zone.  For example, `+0530' and `+05:30' both stand for the
time zone 5.5 hours ahead of UTC (e.g., India).  This is the best way to
specify a time zone correction by fractional parts of an hour.  The
maximum zone correction is 24 hours.

   Either `am'/`pm' or a time zone correction may be specified, but not
both.


File: shishi.info,  Node: Time zone items,  Next: Day of week items,  Prev: Time of day items,  Up: Date input formats

4.10.4 Time zone items
----------------------

A "time zone item" specifies an international time zone, indicated by a
small set of letters, e.g., `UTC' or `Z' for Coordinated Universal
Time.  Any included periods are ignored.  By following a
non-daylight-saving time zone by the string `DST' in a separate word
(that is, separated by some white space), the corresponding daylight
saving time zone may be specified.  Alternatively, a
non-daylight-saving time zone can be followed by a time zone
correction, to add the two values.  This is normally done only for
`UTC'; for example, `UTC+05:30' is equivalent to `+05:30'.

   Time zone items other than `UTC' and `Z' are obsolescent and are not
recommended, because they are ambiguous; for example, `EST' has a
different meaning in Australia than in the United States.  Instead,
it's better to use unambiguous numeric time zone corrections like
`-0500', as described in the previous section.

   If neither a time zone item nor a time zone correction is supplied,
time stamps are interpreted using the rules of the default time zone
(*note Specifying time zone rules::).


File: shishi.info,  Node: Day of week items,  Next: Relative items in date strings,  Prev: Time zone items,  Up: Date input formats

4.10.5 Day of week items
------------------------

The explicit mention of a day of the week will forward the date (only
if necessary) to reach that day of the week in the future.

   Days of the week may be spelled out in full: `Sunday', `Monday',
`Tuesday', `Wednesday', `Thursday', `Friday' or `Saturday'.  Days may
be abbreviated to their first three letters, optionally followed by a
period.  The special abbreviations `Tues' for `Tuesday', `Wednes' for
`Wednesday' and `Thur' or `Thurs' for `Thursday' are also allowed.

   A number may precede a day of the week item to move forward
supplementary weeks.  It is best used in expression like `third
monday'.  In this context, `last DAY' or `next DAY' is also acceptable;
they move one week before or after the day that DAY by itself would
represent.

   A comma following a day of the week item is ignored.


File: shishi.info,  Node: Relative items in date strings,  Next: Pure numbers in date strings,  Prev: Day of week items,  Up: Date input formats

4.10.6 Relative items in date strings
-------------------------------------

"Relative items" adjust a date (or the current date if none) forward or
backward.  The effects of relative items accumulate.  Here are some
examples:

     1 year
     1 year ago
     3 years
     2 days

   The unit of time displacement may be selected by the string `year'
or `month' for moving by whole years or months.  These are fuzzy units,
as years and months are not all of equal duration.  More precise units
are `fortnight' which is worth 14 days, `week' worth 7 days, `day'
worth 24 hours, `hour' worth 60 minutes, `minute' or `min' worth 60
seconds, and `second' or `sec' worth one second.  An `s' suffix on
these units is accepted and ignored.

   The unit of time may be preceded by a multiplier, given as an
optionally signed number.  Unsigned numbers are taken as positively
signed.  No number at all implies 1 for a multiplier.  Following a
relative item by the string `ago' is equivalent to preceding the unit
by a multiplier with value -1.

   The string `tomorrow' is worth one day in the future (equivalent to
`day'), the string `yesterday' is worth one day in the past (equivalent
to `day ago').

   The strings `now' or `today' are relative items corresponding to
zero-valued time displacement, these strings come from the fact a
zero-valued time displacement represents the current time when not
otherwise changed by previous items.  They may be used to stress other
items, like in `12:00 today'.  The string `this' also has the meaning
of a zero-valued time displacement, but is preferred in date strings
like `this thursday'.

   When a relative item causes the resulting date to cross a boundary
where the clocks were adjusted, typically for daylight saving time, the
resulting date and time are adjusted accordingly.

   The fuzz in units can cause problems with relative items.  For
example, `2003-07-31 -1 month' might evaluate to 2003-07-01, because
2003-06-31 is an invalid date.  To determine the previous month more
reliably, you can ask for the month before the 15th of the current
month.  For example:

     $ date -R
     Thu, 31 Jul 2003 13:02:39 -0700
     $ date --date='-1 month' +'Last month was %B?'
     Last month was July?
     $ date --date="$(date +%Y-%m-15) -1 month" +'Last month was %B!'
     Last month was June!

   Also, take care when manipulating dates around clock changes such as
daylight saving leaps.  In a few cases these have added or subtracted
as much as 24 hours from the clock, so it is often wise to adopt
universal time by setting the `TZ' environment variable to `UTC0'
before embarking on calendrical calculations.


File: shishi.info,  Node: Pure numbers in date strings,  Next: Seconds since the Epoch,  Prev: Relative items in date strings,  Up: Date input formats

4.10.7 Pure numbers in date strings
-----------------------------------

The precise interpretation of a pure decimal number depends on the
context in the date string.

   If the decimal number is of the form YYYYMMDD and no other calendar
date item (*note Calendar date items::) appears before it in the date
string, then YYYY is read as the year, MM as the month number and DD as
the day of the month, for the specified calendar date.

   If the decimal number is of the form HHMM and no other time of day
item appears before it in the date string, then HH is read as the hour
of the day and MM as the minute of the hour, for the specified time of
day.  MM can also be omitted.

   If both a calendar date and a time of day appear to the left of a
number in the date string, but no relative item, then the number
overrides the year.


File: shishi.info,  Node: Seconds since the Epoch,  Next: Specifying time zone rules,  Prev: Pure numbers in date strings,  Up: Date input formats

4.10.8 Seconds since the Epoch
------------------------------

If you precede a number with `@', it represents an internal time stamp
as a count of seconds.  The number can contain an internal decimal
point (either `.' or `,'); any excess precision not supported by the
internal representation is truncated toward minus infinity.  Such a
number cannot be combined with any other date item, as it specifies a
complete time stamp.

   Internally, computer times are represented as a count of seconds
since an epoch--a well-defined point of time.  On GNU and POSIX
systems, the epoch is 1970-01-01 00:00:00 UTC, so `@0' represents this
time, `@1' represents 1970-01-01 00:00:01 UTC, and so forth.  GNU and
most other POSIX-compliant systems support such times as an extension
to POSIX, using negative counts, so that `@-1' represents 1969-12-31
23:59:59 UTC.

   Traditional Unix systems count seconds with 32-bit two's-complement
integers and can represent times from 1901-12-13 20:45:52 through
2038-01-19 03:14:07 UTC.  More modern systems use 64-bit counts of
seconds with nanosecond subcounts, and can represent all the times in
the known lifetime of the universe to a resolution of 1 nanosecond.

   On most hosts, these counts ignore the presence of leap seconds.
For example, on most hosts `@915148799' represents 1998-12-31 23:59:59
UTC, `@915148800' represents 1999-01-01 00:00:00 UTC, and there is no
way to represent the intervening leap second 1998-12-31 23:59:60 UTC.


File: shishi.info,  Node: Specifying time zone rules,  Next: Authors of get_date,  Prev: Seconds since the Epoch,  Up: Date input formats

4.10.9 Specifying time zone rules
---------------------------------

Normally, dates are interpreted using the rules of the current time
zone, which in turn are specified by the `TZ' environment variable, or
by a system default if `TZ' is not set.  To specify a different set of
default time zone rules that apply just to one date, start the date
with a string of the form `TZ="RULE"'.  The two quote characters (`"')
must be present in the date, and any quotes or backslashes within RULE
must be escaped by a backslash.

   For example, with the GNU `date' command you can answer the question
"What time is it in New York when a Paris clock shows 6:30am on October
31, 2004?" by using a date beginning with `TZ="Europe/Paris"' as shown
in the following shell transcript:

     $ export TZ="America/New_York"
     $ date --date='TZ="Europe/Paris" 2004-10-31 06:30'
     Sun Oct 31 01:30:00 EDT 2004

   In this example, the `--date' operand begins with its own `TZ'
setting, so the rest of that operand is processed according to
`Europe/Paris' rules, treating the string `2004-10-31 06:30' as if it
were in Paris.  However, since the output of the `date' command is
processed according to the overall time zone rules, it uses New York
time.  (Paris was normally six hours ahead of New York in 2004, but
this example refers to a brief Halloween period when the gap was five
hours.)

   A `TZ' value is a rule that typically names a location in the `tz'
database (http://www.twinsun.com/tz/tz-link.htm).  A recent catalog of
location names appears in the TWiki Date and Time Gateway
(http://twiki.org/cgi-bin/xtra/tzdate).  A few non-GNU hosts require a
colon before a location name in a `TZ' setting, e.g.,
`TZ=":America/New_York"'.

   The `tz' database includes a wide variety of locations ranging from
`Arctic/Longyearbyen' to `Antarctica/South_Pole', but if you are at sea
and have your own private time zone, or if you are using a non-GNU host
that does not support the `tz' database, you may need to use a POSIX
rule instead.  Simple POSIX rules like `UTC0' specify a time zone
without daylight saving time; other rules can specify simple daylight
saving regimes.  *Note Specifying the Time Zone with `TZ': (libc)TZ
Variable.


File: shishi.info,  Node: Authors of get_date,  Prev: Specifying time zone rules,  Up: Date input formats

4.10.10 Authors of `get_date'
-----------------------------

`get_date' was originally implemented by Steven M. Bellovin
(<smb@research.att.com>) while at the University of North Carolina at
Chapel Hill.  The code was later tweaked by a couple of people on
Usenet, then completely overhauled by Rich $alz (<rsalz@bbn.com>) and
Jim Berets (<jberets@bbn.com>) in August, 1990.  Various revisions for
the GNU system were made by David MacKenzie, Jim Meyering, Paul Eggert
and others.

   This chapter was originally produced by Franc,ois Pinard
(<pinard@iro.umontreal.ca>) from the `getdate.y' source code, and then
edited by K. Berry (<kb@cs.umb.edu>).


File: shishi.info,  Node: Programming Manual,  Next: Acknowledgements,  Prev: Reference Manual,  Up: Top

5 Programming Manual
********************

This chapter describes all the publicly available functions in the
library.

* Menu:

* Preparation::                 What you should do before using the library.
* Initialization Functions::    Creating library handle, configuration file.
* Ticket Set Functions::        High-level ticket management functions.
* AP-REQ and AP-REP Functions:: Client/Server authentication functions.
* SAFE and PRIV Functions::     Client/Server session data functions.
* Ticket Functions::            Medium-level ticket manipulation functions.
* AS Functions::                Medium-level initial authentication functions.
* TGS Functions::               Medium-level authentication functions.
* Ticket (ASN.1) Functions::    Low-level Ticket functions.
* AS/TGS Functions::            Low-level KDC functions; AS and TGS.
* Authenticator Functions::     Low-level authenticator functions.
* KRB-ERROR Functions::         Low-level KRB-ERROR functions.
* Cryptographic Functions::     Low-level cryptographic functions.
* X.509 Functions::             Utility functions for X.509 support.
* Utility Functions::           Utilities for use in the global context.
* ASN.1 Functions::             Perform low-level ASN.1 manipulations.
* Error Handling::              Error codes and such.
* Examples::                    Example code.
* Kerberos Database Functions:: The Shisa generic database interface.
* Generic Security Service::    If you want to use the GSS API instead.


File: shishi.info,  Node: Preparation,  Next: Initialization Functions,  Up: Programming Manual

5.1 Preparation
===============

To use `Libshishi', you have to perform some changes to your sources
and the build system.  The necessary changes are small and explained in
the following sections.  At the end of this chapter, it is described
how the library is initialized, and how the requirements of the library
are verified.

   A faster way to find out how to adapt your application for use with
`Libshishi' may be to look at the examples at the end of this manual
(*note Examples::).

* Menu:

* Header::
* Initialization::
* Version Check::
* Building the source::
* Autoconf tests::


File: shishi.info,  Node: Header,  Next: Initialization,  Up: Preparation

5.1.1 Header
------------

All interfaces (data types and functions) of the library are defined in
the header file `shishi.h'.  You must include this in all programs
using the library, either directly or through some other header file,
like this:

     #include <shishi.h>

   The name space of `Libshishi' is `shishi_*' for function names,
`Shishi*' for data types and `SHISHI_*' for other symbols.  In addition
the same name prefixes with one prepended underscore are reserved for
internal use and should never be used by an application.


File: shishi.info,  Node: Initialization,  Next: Version Check,  Prev: Header,  Up: Preparation

5.1.2 Initialization
--------------------

`Libshishi' must be initialized before it can be used.  The library is
initialized by calling `shishi_init' (*note Initialization
Functions::).  The resources allocated by the initialization process
can be released if the application no longer has a need to call
`Libshishi' functions, this is done by calling `shishi_done'.

   In order to take advantage of the internationalisation features in
`Libshishi', such as translated error messages, the application must
set the current locale using `setlocale' before initializing
`Libshishi'.


File: shishi.info,  Node: Version Check,  Next: Building the source,  Prev: Initialization,  Up: Preparation

5.1.3 Version Check
-------------------

It is often desirable to check that the version of `Libshishi' used is
indeed one which fits all requirements.  Even with binary compatibility
new features may have been introduced but due to problem with the
dynamic linker an old version is actually used.  So you may want to
check that the version is okay right after program startup.

shishi_check_version
--------------------

 -- Function: const char * shishi_check_version (const char *
          REQ_VERSION)
     REQ_VERSION: version string to compare with, or NULL

     Check that the the version of the library is at minimum the one
     given as a string in `req_version'.

     *Return value:* the actual version string of the library; NULL if
     the condition is not met.  If `NULL' is passed to this function no
     check is done and only the version string is returned.

   The normal way to use the function is to put something similar to the
following early in your `main':

       if (!shishi_check_version (SHISHI_VERSION))
         {
           printf ("shishi_check_version failed:\n"
                   "Header file incompatible with shared library.\n");
           exit(1);
         }


File: shishi.info,  Node: Building the source,  Next: Autoconf tests,  Prev: Version Check,  Up: Preparation

5.1.4 Building the source
-------------------------

If you want to compile a source file including the `shishi.h' header
file, you must make sure that the compiler can find it in the directory
hierarchy.  This is accomplished by adding the path to the directory in
which the header file is located to the compilers include file search
path (via the `-I' option).

   However, the path to the include file is determined at the time the
source is configured.  To solve this problem, `Libshishi' uses the
external package `pkg-config' that knows the path to the include file
and other configuration options.  The options that need to be added to
the compiler invocation at compile time are output by the `--cflags'
option to `pkg-config shishi'.  The following example shows how it can
be used at the command line:

     gcc -c foo.c `pkg-config shishi --cflags`

   Adding the output of `pkg-config shishi --cflags' to the compilers
command line will ensure that the compiler can find the `Libshishi'
header file.

   A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files.  For this to work,
the path to the library files has to be added to the library search path
(via the `-L' option).  For this, the option `--libs' to `pkg-config
shishi' can be used.  For convenience, this option also outputs all
other options that are required to link the program with the
`Libshishi' libararies (in particular, the `-lshishi' option).  The
example shows how to link `foo.o' with the `Libshishi' library to a
program `foo'.

     gcc -o foo foo.o `pkg-config shishi --libs`

   Of course you can also combine both examples to a single command by
specifying both options to `pkg-config':

     gcc -o foo foo.c `pkg-config shishi --cflags --libs`


File: shishi.info,  Node: Autoconf tests,  Prev: Building the source,  Up: Preparation

5.1.5 Autoconf tests
--------------------

If you work on a project that uses Autoconf (*note GNU Autoconf:
(autoconf)top.) to help find installed libraries, the suggestions in
the previous section are not the entire story.  There are a few methods
to detect and incorporate Shishi into your Autoconf based package.  The
preferred approach, is to use Libtool in your project, and use the
normal Autoconf header file and library tests.

5.1.5.1 Autoconf test via `pkg-config'
......................................

If your audience is a typical GNU/Linux desktop, you can often assume
they have the `pkg-config' tool installed, in which you can use its
Autoconf M4 macro to find and set up your package for use with Shishi.
The following illustrate this scenario.

     AC_ARG_ENABLE(kerberos_v5,
     	AC_HELP_STRING([--disable-kerberos_v5],
                            [don't use the KERBEROS_V5 mechanism]),
     	kerberos_v5=$enableval)
     if test "$kerberos_v5" != "no" ; then
     	PKG_CHECK_MODULES(SHISHI, shishi >= 0.0.0,
     			[kerberos_v5=yes],
                             [kerberos_v5=no])
     	if test "$kerberos_v5" != "yes" ; then
     		kerberos_v5=no
     		AC_MSG_WARN([shishi not found, disabling Kerberos 5])
     	else
     		kerberos_v5=yes
     		AC_DEFINE(USE_KERBEROS_V5, 1,
                               [Define to 1 if you want Kerberos 5.])
     	fi
     fi
     AC_MSG_CHECKING([if Kerberos 5 should be used])
     AC_MSG_RESULT($kerberos_v5)

5.1.5.2 Standalone Autoconf test using Libtool
..............................................

If your package uses Libtool(*note GNU Libtool: (libtool)top.), you can
use the normal Autoconf tests to find the Shishi library and rely on
the Libtool dependency tracking to include the proper dependency
libraries (e.g., Libidn).  The following illustrate this scenario.

     AC_CHECK_HEADER(shishi.h,
     	AC_CHECK_LIB(shishi, shishi_check_version,
     		[kerberos5=yes AC_SUBST(SHISHI_LIBS, -lshishi)],
     		kerberos5=no),
     	kerberos5=no)
     AC_ARG_ENABLE(kerberos5,
     	AC_HELP_STRING([--disable-kerberos5],
                            [disable Kerberos 5 unconditionally]),
     	kerberos5=$enableval)
     if test "$kerberos5" != "no" ; then
     	AC_DEFINE(USE_KERBEROS_V5, 1,
     		  [Define to 1 if you want Kerberos 5.])
     else
     	AC_MSG_WARN([Shishi not found, disabling Kerberos 5])
     fi
     AC_MSG_CHECKING([if Kerberos 5 should be used])
     AC_MSG_RESULT($kerberos5)

5.1.5.3 Standalone Autoconf test
................................

If your package does not use Libtool, as well as detecting the Shishi
library as in the previous case, you must also detect whatever
dependencies Shishi requires to work (e.g., libidn).  Since the
dependencies are in a state of flux, we do not provide an example and
we do not recommend this approach, unless you are experienced developer.


File: shishi.info,  Node: Initialization Functions,  Next: Ticket Set Functions,  Prev: Preparation,  Up: Programming Manual

5.2 Initialization Functions
============================

shishi
------

 -- Function: Shishi * shishi ( VOID)
     Initializes the Shishi library, and set up, using
     `shishi_error_set_outputtype()', the library so that future
     warnings and informational messages are printed to stderr.  If
     this function fails, it may print diagnostic errors to stderr.

     *Return value:* Returns Shishi library handle, or `NULL' on error.

shishi_server
-------------

 -- Function: Shishi * shishi_server ( VOID)
     Initializes the Shishi library, and set up, using
     `shishi_error_set_outputtype()', the library so that future
     warnings and informational messages are printed to the syslog.  If
     this function fails, it may print diagnostic errors to the syslog.

     *Return value:* Returns Shishi library handle, or `NULL' on error.

shishi_done
-----------

 -- Function: void shishi_done (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Deallocates the shishi library handle.  The handle must not be used
     in any calls to shishi functions after this.

     If there is a default tkts, it is written to the default tkts file
     (call `shishi_tkts_default_file_set()' to change the default tkts
     file). If you do not wish to write the default tkts file, close the
     default tkts with shishi_tkts_done(handle, NULL) before calling
     this function.

shishi_init
-----------

 -- Function: int shishi_init (Shishi ** HANDLE)
     HANDLE: pointer to handle to be created.

     Create a Shishi library handle, using `shishi()', and read the
     system configuration file, user configuration file and user
     tickets from their default locations.  The paths to the system
     configuration file is decided at compile time, and is
     $sysconfdir/shishi.conf.  The user configuration file is
     $HOME/.shishi/config, and the user ticket file is
     $HOME/.shishi/ticket.

     The handle is allocated regardless of return values, except for
     SHISHI_HANDLE_ERROR which indicates a problem allocating the
     handle.  (The other error conditions comes from reading the files.)

     *Return value:* Returns SHISHI_OK iff successful.

shishi_init_with_paths
----------------------

 -- Function: int shishi_init_with_paths (Shishi ** HANDLE, const char
          * TKTSFILE, const char * SYSTEMCFGFILE, const char *
          USERCFGFILE)
     HANDLE: pointer to handle to be created.

     TKTSFILE: Filename of ticket file, or NULL.

     SYSTEMCFGFILE: Filename of system configuration, or NULL.

     USERCFGFILE: Filename of user configuration, or NULL.

     Create a Shishi library handle, using `shishi()', and read the
     system configuration file, user configuration file, and user
     tickets from the specified locations.  If any of `usercfgfile' or
     `systemcfgfile' is NULL, the file is read from its default
     location, which for the system configuration file is decided at
     compile time, and is $sysconfdir/shishi.conf, and for the user
     configuration file is $HOME/.shishi/config.  If the ticket file is
     NULL, a ticket file is not read at all.

     The handle is allocated regardless of return values, except for
     SHISHI_HANDLE_ERROR which indicates a problem allocating the
     handle.  (The other error conditions comes from reading the files.)

     *Return value:* Returns SHISHI_OK iff successful.

shishi_init_server
------------------

 -- Function: int shishi_init_server (Shishi ** HANDLE)
     HANDLE: pointer to handle to be created.

     Create a Shishi library handle, using `shishi_server()', and read
     the system configuration file.  The paths to the system
     configuration file is decided at compile time, and is
     $sysconfdir/shishi.conf.

     The handle is allocated regardless of return values, except for
     SHISHI_HANDLE_ERROR which indicates a problem allocating the
     handle.  (The other error conditions comes from reading the file.)

     *Return value:* Returns SHISHI_OK iff successful.

shishi_init_server_with_paths
-----------------------------

 -- Function: int shishi_init_server_with_paths (Shishi ** HANDLE,
          const char * SYSTEMCFGFILE)
     HANDLE: pointer to handle to be created.

     SYSTEMCFGFILE: Filename of system configuration, or NULL.

     Create a Shishi library handle, using `shishi_server()', and read
     the system configuration file from specified location.  The paths
     to the system configuration file is decided at compile time, and is
     $sysconfdir/shishi.conf.  The handle is allocated regardless of
     return values, except for SHISHI_HANDLE_ERROR which indicates a
     problem allocating the handle.  (The other error conditions comes
     from reading the file.)

     *Return value:* Returns SHISHI_OK iff successful.

shishi_cfg
----------

 -- Function: int shishi_cfg (Shishi * HANDLE, const char * OPTION)
     HANDLE: Shishi library handle create by `shishi_init()'.

     OPTION: string with shishi library option.

     Configure shishi library with given option.

     *Return Value:* Returns SHISHI_OK if option was valid.

shishi_cfg_from_file
--------------------

 -- Function: int shishi_cfg_from_file (Shishi * HANDLE, const char *
          CFG)
     HANDLE: Shishi library handle create by `shishi_init()'.

     CFG: filename to read configuration from.

     Configure shishi library using configuration file.

     *Return Value:* Returns SHISHI_OK iff succesful.

shishi_cfg_print
----------------

 -- Function: int shishi_cfg_print (Shishi * HANDLE, FILE * FH)
     HANDLE: Shishi library handle create by `shishi_init()'.

     FH: file descriptor opened for writing.

     Print library configuration status, mostly for debugging purposes.

     *Return Value:* Returns SHISHI_OK.

shishi_cfg_default_systemfile
-----------------------------

 -- Function: const char * shishi_cfg_default_systemfile (Shishi *
          HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     The system configuration file name is decided at compile-time, but
     may be overridden by the environment variable SHISHI_CONFIG.

     *Return value:* Return system configuration file name.

shishi_cfg_default_userdirectory
--------------------------------

 -- Function: const char * shishi_cfg_default_userdirectory (Shishi *
          HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     The default user directory (used for, e.g. Shishi ticket cache) is
     normally computed by appending BASE_DIR ("/.shishi") to the content
     of the environment variable $HOME, but can be overridden by
     specifying the complete path in the environment variable
     SHISHI_HOME.

     *Return value:* Return directory with configuration files etc.

shishi_cfg_userdirectory_file
-----------------------------

 -- Function: char * shishi_cfg_userdirectory_file (Shishi * HANDLE,
          const char * FILE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     FILE: basename of file to find in user directory.

     Get the full path to specified `file' in the users' configuration
     directory.

     *Return value:* Return full path to given relative filename,
     relative to the user specific Shishi configuration directory as
     returned by `shishi_cfg_default_userdirectory()' (typically
     $HOME/.shishi).

shishi_cfg_default_userfile
---------------------------

 -- Function: const char * shishi_cfg_default_userfile (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Get filename of default user configuration file, typically
     $HOME/shishi.conf.

     *Return value:* Return user configuration filename.

shishi_cfg_clientkdcetype
-------------------------

 -- Function: int shishi_cfg_clientkdcetype (Shishi * HANDLE, int32_t
          ** ETYPES)
     HANDLE: Shishi library handle create by `shishi_init()'.

     ETYPES: output array with encryption types.

     Set the etypes variable to the array of preferred client etypes.

     *Return value:* Return the number of encryption types in the array,
     0 means none.

shishi_cfg_clientkdcetype_fast
------------------------------

 -- Function: int32_t shishi_cfg_clientkdcetype_fast (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Extract the default etype from the list of preferred client etypes.

     *Return value:* Return the default encryption types.

shishi_cfg_clientkdcetype_set
-----------------------------

 -- Function: int shishi_cfg_clientkdcetype_set (Shishi * HANDLE, char
          * VALUE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     VALUE: string with encryption types.

     Set the "client-kdc-etypes" configuration option from given string.
     The string contains encryption types (integer or names) separated
     by comma or whitespace, e.g. "aes256-cts-hmac-sha1-96
     des3-cbc-sha1-kd des-cbc-md5".

     *Return value:* Return SHISHI_OK iff successful.

shishi_cfg_authorizationtype_set
--------------------------------

 -- Function: int shishi_cfg_authorizationtype_set (Shishi * HANDLE,
          char * VALUE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     VALUE: string with authorization types.

     Set the "authorization-types" configuration option from given
     string.  The string contains authorization types (integer or
     names) separated by comma or whitespace, e.g. "basic k5login".

     *Return value:* Return SHISHI_OK iff successful.


File: shishi.info,  Node: Ticket Set Functions,  Next: AP-REQ and AP-REP Functions,  Prev: Initialization Functions,  Up: Programming Manual

5.3 Ticket Set Functions
========================

A "ticket set" is, as the name implies, a collection of tickets.
Functions are provided to read tickets from file into a ticket set, to
query number of tickets in the set, to extract a given ticket from the
set, to search the ticket set for tickets matching certain criterium,
to write the ticket set to a file, etc.  High level functions for
performing a initial authentication (*note AS Functions::) or
subsequent authentication (*note TGS Functions::) and storing the new
ticket in the ticket set are also provided.

   To manipulate each individual ticket, *Note Ticket Functions::.  For
low-level ASN.1 manipulation see *Note Ticket (ASN.1) Functions::.

shishi_tkts_default_file_guess
------------------------------

 -- Function: char * shishi_tkts_default_file_guess (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Guesses the default ticket filename; it is $SHISHI_TICKETS,
     $SHISHI_HOME/tickets, or $HOME/.shishi/tickets.

     *Return value:* Returns default tkts filename as a string that has
     to be deallocated with `free()' by the caller.

shishi_tkts_default_file
------------------------

 -- Function: const char * shishi_tkts_default_file (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Get filename of default ticket set.

     *Return value:* Returns the default ticket set filename used in the
     library.  The string is not a copy, so don't modify or deallocate
     it.

shishi_tkts_default_file_set
----------------------------

 -- Function: void shishi_tkts_default_file_set (Shishi * HANDLE, const
          char * TKTSFILE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     TKTSFILE: string with new default tkts file name, or NULL to reset
     to default.

     Set the default ticket set filename used in the library.  The
     string is copied into the library, so you can dispose of the
     variable immediately after calling this function.

shishi_tkts_default
-------------------

 -- Function: Shishi_tkts * shishi_tkts_default (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Get the default ticket set for library handle.

     *Return value:* Return the handle global ticket set.

shishi_tkts
-----------

 -- Function: int shishi_tkts (Shishi * HANDLE, Shishi_tkts ** TKTS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TKTS: output pointer to newly allocated tkts handle.

     Get a new ticket set handle.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_tkts_done
----------------

 -- Function: void shishi_tkts_done (Shishi_tkts ** TKTS)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     Deallocates all resources associated with ticket set.  The ticket
     set handle must not be used in calls to other shishi_tkts_*()
     functions after this.

shishi_tkts_size
----------------

 -- Function: int shishi_tkts_size (Shishi_tkts * TKTS)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     Get size of ticket set.

     *Return value:* Returns number of tickets stored in ticket set.

shishi_tkts_nth
---------------

 -- Function: Shishi_tkt * shishi_tkts_nth (Shishi_tkts * TKTS, int
          TICKETNO)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     TICKETNO: integer indicating requested ticket in ticket set.

     *Get the n:* th ticket in ticket set.

     *Return value:* Returns a ticket handle to the ticketno:th ticket
     in the ticket set, or NULL if ticket set is invalid or ticketno is
     out of bounds.  The first ticket is ticketno 0, the second
     ticketno 1, and so on.

shishi_tkts_remove
------------------

 -- Function: int shishi_tkts_remove (Shishi_tkts * TKTS, int TICKETNO)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     TICKETNO: ticket number of ticket in the set to remove.  The first
     ticket is ticket number 0.

     Remove a ticket, indexed by `ticketno', in ticket set.

     *Return value:* Returns SHISHI_OK if succesful or if ticketno
     larger than size of ticket set.

shishi_tkts_add
---------------

 -- Function: int shishi_tkts_add (Shishi_tkts * TKTS, Shishi_tkt * TKT)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     TKT: ticket to be added to ticket set.

     Add a ticket to the ticket set.  Only the pointer is stored, so if
     you modify `tkt', the ticket in the ticket set will also be
     modified.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkts_new
---------------

 -- Function: int shishi_tkts_new (Shishi_tkts * TKTS, Shishi_asn1
          TICKET, Shishi_asn1 ENCKDCREPPART, Shishi_asn1 KDCREP)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     TICKET: input ticket variable.

     ENCKDCREPPART: input ticket detail variable.

     KDCREP: input KDC-REP variable.

     Allocate a new ticket and add it to the ticket set.

     Note that `ticket', `enckdcreppart' and `kdcrep' are stored by
     reference, so you must not de-allocate them before the ticket is
     removed from the ticket set and de-allocated.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkts_read
----------------

 -- Function: int shishi_tkts_read (Shishi_tkts * TKTS, FILE * FH)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     FH: file descriptor to read from.

     Read tickets from file descriptor and add them to the ticket set.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkts_from_file
---------------------

 -- Function: int shishi_tkts_from_file (Shishi_tkts * TKTS, const char
          * FILENAME)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     FILENAME: filename to read tickets from.

     Read tickets from file and add them to the ticket set.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkts_write
-----------------

 -- Function: int shishi_tkts_write (Shishi_tkts * TKTS, FILE * FH)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     FH: file descriptor to write tickets to.

     Write tickets in set to file descriptor.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkts_expire
------------------

 -- Function: int shishi_tkts_expire (Shishi_tkts * TKTS)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     Remove expired tickets from ticket set.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkts_to_file
-------------------

 -- Function: int shishi_tkts_to_file (Shishi_tkts * TKTS, const char *
          FILENAME)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     FILENAME: filename to write tickets to.

     Write tickets in set to file.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkts_print_for_service
-----------------------------

 -- Function: int shishi_tkts_print_for_service (Shishi_tkts * TKTS,
          FILE * FH, const char * SERVICE)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     FH: file descriptor to print to.

     SERVICE: service to limit tickets printed to, or NULL.

     Print description of tickets for specified service to file
     descriptor.  If service is NULL, all tickets are printed.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkts_print
-----------------

 -- Function: int shishi_tkts_print (Shishi_tkts * TKTS, FILE * FH)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     FH: file descriptor to print to.

     Print description of all tickets to file descriptor.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_tkt_match_p
------------------

 -- Function: int shishi_tkt_match_p (Shishi_tkt * TKT,
          Shishi_tkts_hint * HINT)
     TKT: ticket to test hints on.

     HINT: structure with characteristics of ticket to be found.

     Test if a ticket matches specified hints.

     *Return value:* Returns 0 iff ticket fails to match given criteria.

shishi_tkts_find
----------------

 -- Function: Shishi_tkt * shishi_tkts_find (Shishi_tkts * TKTS,
          Shishi_tkts_hint * HINT)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     HINT: structure with characteristics of ticket to be found.

     Search the ticketset sequentially (from ticket number 0 through all
     tickets in the set) for a ticket that fits the given
     characteristics.  If a ticket is found, the hint->startpos field is
     updated to point to the next ticket in the set, so this function
     can be called repeatedly with the same hint argument in order to
     find all tickets matching a certain criterium.  Note that if
     tickets are added to, or removed from, the ticketset during a query
     with the same hint argument, the hint->startpos field must be
     updated appropriately.

     *Here is how you would typically use this function:*
     Shishi_tkts_hint  hint;

     Shishi_tkt  tkt;

     memset(&hint, 0, sizeof(hint));

     hint.server = "imap/mail.example.org";

     tkt = shishi_tkts_find (shishi_tkts_default(handle), &hint);

     if (!tkt)

     printf("No ticket found...\n");

     else

     do_something_with_ticket (tkt);

     *Return value:* Returns a ticket if found, or NULL if no further
     matching tickets could be found.

shishi_tkts_find_for_clientserver
---------------------------------

 -- Function: Shishi_tkt * shishi_tkts_find_for_clientserver
          (Shishi_tkts * TKTS, const char * CLIENT, const char * SERVER)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     CLIENT: client name to find ticket for.

     SERVER: server name to find ticket for.

     Short-hand function for searching the ticket set for a ticket for
     the given client and server.  See `shishi_tkts_find()'.

     *Return value:* Returns a ticket if found, or NULL.

shishi_tkts_find_for_server
---------------------------

 -- Function: Shishi_tkt * shishi_tkts_find_for_server (Shishi_tkts *
          TKTS, const char * SERVER)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     SERVER: server name to find ticket for.

     Short-hand function for searching the ticket set for a ticket for
     the given server using the default client principal.  See
     `shishi_tkts_find_for_clientserver()' and `shishi_tkts_find()'.

     *Return value:* Returns a ticket if found, or NULL.

shishi_tkts_get_tgt
-------------------

 -- Function: Shishi_tkt * shishi_tkts_get_tgt (Shishi_tkts * TKTS,
          Shishi_tkts_hint * HINT)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     HINT: structure with characteristics of ticket to begot.

     Get a ticket granting ticket (TGT) suitable for acquiring ticket
     matching the hint.  I.e., get a TGT for the server realm in the
     hint structure (hint->serverrealm), or the default realm if the
     serverrealm field is NULL.  Can result in AS exchange.

     Currently this function do not implement cross realm logic.

     This function is used by `shishi_tkts_get()', which is probably
     what you really want to use unless you have special needs.

     *Return value:* Returns a ticket granting ticket if successful, or
     NULL if this function is unable to acquire on.

shishi_tkts_get_tgs
-------------------

 -- Function: Shishi_tkt * shishi_tkts_get_tgs (Shishi_tkts * TKTS,
          Shishi_tkts_hint * HINT, Shishi_tkt * TGT)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     HINT: structure with characteristics of ticket to begot.

     TGT: ticket granting ticket to use.

     Get a ticket via TGS exchange using specified ticket granting
     ticket.

     This function is used by `shishi_tkts_get()', which is probably
     what you really want to use unless you have special needs.

     *Return value:* Returns a ticket if successful, or NULL if this
     function is unable to acquire on.

shishi_tkts_get
---------------

 -- Function: Shishi_tkt * shishi_tkts_get (Shishi_tkts * TKTS,
          Shishi_tkts_hint * HINT)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     HINT: structure with characteristics of ticket to begot.

     Get a ticket matching given characteristics.  This function first
     looks in the ticket set for the ticket, then tries to find a
     suitable TGT, possibly via an AS exchange, using
     `shishi_tkts_get_tgt()', and then use that TGT in a TGS exchange to
     get the ticket.

     Currently this function do not implement cross realm logic.

     *Return value:* Returns a ticket if found, or NULL if this function
     is unable to get the ticket.

shishi_tkts_get_for_clientserver
--------------------------------

 -- Function: Shishi_tkt * shishi_tkts_get_for_clientserver
          (Shishi_tkts * TKTS, const char * CLIENT, const char * SERVER)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     CLIENT: client name to get ticket for.

     SERVER: server name to get ticket for.

     Short-hand function for getting a ticket for the given client and
     server.  See `shishi_tkts_get()'.

     *Return value:* Returns a ticket if found, or NULL.

shishi_tkts_get_for_server
--------------------------

 -- Function: Shishi_tkt * shishi_tkts_get_for_server (Shishi_tkts *
          TKTS, const char * SERVER)
     TKTS: ticket set handle as allocated by `shishi_tkts()'.

     SERVER: server name to get ticket for.

     Short-hand function for getting a ticket for the given server and
     the default principal client.  See `shishi_tkts_get()'.

     *Return value:* Returns a ticket if found, or NULL.


File: shishi.info,  Node: AP-REQ and AP-REP Functions,  Next: SAFE and PRIV Functions,  Prev: Ticket Set Functions,  Up: Programming Manual

5.4 AP-REQ and AP-REP Functions
===============================

The "AP-REQ" and "AP-REP" are ASN.1 structures used by application
client and servers to prove to each other who they are.  The structures
contain auxilliary information, together with an authenticator (*note
Authenticator Functions::) which is the real cryptographic proof.  The
following illustrates the AP-REQ and AP-REP ASN.1 structures.

AP-REQ		::= [APPLICATION 14] SEQUENCE {
	pvno		[0] INTEGER (5),
	msg-type	[1] INTEGER (14),
	ap-options	[2] APOptions,
	ticket		[3] Ticket,
	authenticator	[4] EncryptedData {Authenticator,
				{ keyuse-pa-TGSReq-authenticator
				  | keyuse-APReq-authenticator }}
}

AP-REP		::= [APPLICATION 15] SEQUENCE {
	pvno		[0] INTEGER (5),
	msg-type	[1] INTEGER (15),
	enc-part	[2] EncryptedData {EncAPRepPart,
				{ keyuse-EncAPRepPart }}
}

EncAPRepPart	::= [APPLICATION 27] SEQUENCE {
	ctime		[0] KerberosTime,
	cusec		[1] Microseconds,
	subkey		[2] EncryptionKey OPTIONAL,
	seq-number	[3] UInt32 OPTIONAL
}

shishi_ap
---------

 -- Function: int shishi_ap (Shishi * HANDLE, Shishi_ap ** AP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AP: pointer to new structure that holds information about AP
     exchange

     Create a new AP exchange with a random subkey of the default
     encryption type from configuration.  Note that there is no
     guarantee that the receiver will understand that key type, you
     should probably use `shishi_ap_etype()' or `shishi_ap_nosubkey()'
     instead.  In the future, this function will likely behave as
     `shishi_ap_nosubkey()' and `shishi_ap_nosubkey()' will be removed.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_etype
---------------

 -- Function: int shishi_ap_etype (Shishi * HANDLE, Shishi_ap ** AP,
          int ETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AP: pointer to new structure that holds information about AP
     exchange

     ETYPE: encryption type of newly generated random subkey.

     Create a new AP exchange with a random subkey of indicated
     encryption type.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_nosubkey
------------------

 -- Function: int shishi_ap_nosubkey (Shishi * HANDLE, Shishi_ap ** AP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AP: pointer to new structure that holds information about AP
     exchange

     Create a new AP exchange without subkey in authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_done
--------------

 -- Function: void shishi_ap_done (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Deallocate resources associated with AP exchange.  This should be
     called by the application when it no longer need to utilize the AP
     exchange handle.

shishi_ap_set_tktoptions
------------------------

 -- Function: int shishi_ap_set_tktoptions (Shishi_ap * AP, Shishi_tkt
          * TKT, int OPTIONS)
     AP: structure that holds information about AP exchange

     TKT: ticket to set in AP.

     OPTIONS: AP-REQ options to set in AP.

     Set the ticket (see `shishi_ap_tkt_set()') and set the AP-REQ
     apoptions (see `shishi_apreq_options_set()').

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_set_tktoptionsdata
----------------------------

 -- Function: int shishi_ap_set_tktoptionsdata (Shishi_ap * AP,
          Shishi_tkt * TKT, int OPTIONS, const char * DATA, size_t LEN)
     AP: structure that holds information about AP exchange

     TKT: ticket to set in AP.

     OPTIONS: AP-REQ options to set in AP.

     DATA: input array with data to checksum in Authenticator.

     LEN: length of input array with data to checksum in Authenticator.

     Set the ticket (see `shishi_ap_tkt_set()') and set the AP-REQ
     apoptions (see `shishi_apreq_options_set()') and set the
     Authenticator checksum data.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_set_tktoptionsraw
---------------------------

 -- Function: int shishi_ap_set_tktoptionsraw (Shishi_ap * AP,
          Shishi_tkt * TKT, int OPTIONS, int32_t CKSUMTYPE, const char
          * DATA, size_t LEN)
     AP: structure that holds information about AP exchange

     TKT: ticket to set in AP.

     OPTIONS: AP-REQ options to set in AP.

     CKSUMTYPE: authenticator checksum type to set in AP.

     DATA: input array with data to store in checksum field in
     Authenticator.

     LEN: length of input array with data to store in checksum field in
     Authenticator.

     Set the ticket (see `shishi_ap_tkt_set()') and set the AP-REQ
     apoptions (see `shishi_apreq_options_set()') and set the raw
     Authenticator checksum data.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_set_tktoptionsasn1usage
---------------------------------

 -- Function: int shishi_ap_set_tktoptionsasn1usage (Shishi_ap * AP,
          Shishi_tkt * TKT, int OPTIONS, Shishi_asn1 NODE, const char *
          FIELD, int AUTHENTICATORCKSUMKEYUSAGE, int
          AUTHENTICATORKEYUSAGE)
     AP: structure that holds information about AP exchange

     TKT: ticket to set in AP.

     OPTIONS: AP-REQ options to set in AP.

     NODE: input ASN.1 structure to store as authenticator checksum
     data.

     FIELD: field in ASN.1 structure to use.

     AUTHENTICATORCKSUMKEYUSAGE: key usage for checksum in
     authenticator.

     AUTHENTICATORKEYUSAGE: key usage for authenticator.

     Set ticket, options and authenticator checksum data using
     `shishi_ap_set_tktoptionsdata()'.  The authenticator checksum data
     is the DER encoding of the ASN.1 field provided.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_tktoptions
--------------------

 -- Function: int shishi_ap_tktoptions (Shishi * HANDLE, Shishi_ap **
          AP, Shishi_tkt * TKT, int OPTIONS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AP: pointer to new structure that holds information about AP
     exchange

     TKT: ticket to set in newly created AP.

     OPTIONS: AP-REQ options to set in newly created AP.

     Create a new AP exchange using `shishi_ap()', and set the ticket
     and AP-REQ apoptions using `shishi_ap_set_tktoption()'.  A random
     session key is added to the authenticator, using the same keytype
     as the ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_tktoptionsdata
------------------------

 -- Function: int shishi_ap_tktoptionsdata (Shishi * HANDLE, Shishi_ap
          ** AP, Shishi_tkt * TKT, int OPTIONS, const char * DATA,
          size_t LEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AP: pointer to new structure that holds information about AP
     exchange

     TKT: ticket to set in newly created AP.

     OPTIONS: AP-REQ options to set in newly created AP.

     DATA: input array with data to checksum in Authenticator.

     LEN: length of input array with data to checksum in Authenticator.

     Create a new AP exchange using `shishi_ap()', and set the ticket,
     AP-REQ apoptions and the Authenticator checksum data using
     `shishi_ap_set_tktoptionsdata()'. A random session key is added to
     the authenticator, using the same keytype as the ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_tktoptionsraw
-----------------------

 -- Function: int shishi_ap_tktoptionsraw (Shishi * HANDLE, Shishi_ap
          ** AP, Shishi_tkt * TKT, int OPTIONS, int32_t CKSUMTYPE,
          const char * DATA, size_t LEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AP: pointer to new structure that holds information about AP
     exchange

     TKT: ticket to set in newly created AP.

     OPTIONS: AP-REQ options to set in newly created AP.

     CKSUMTYPE: authenticator checksum type to set in AP.

     DATA: input array with data to store in checksum field in
     Authenticator.

     LEN: length of input array with data to store in checksum field in
     Authenticator.

     Create a new AP exchange using `shishi_ap()', and set the ticket,
     AP-REQ apoptions and the raw Authenticator checksum data field
     using `shishi_ap_set_tktoptionsraw()'.  A random session key is
     added to the authenticator, using the same keytype as the ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_etype_tktoptionsdata
------------------------------

 -- Function: int shishi_ap_etype_tktoptionsdata (Shishi * HANDLE,
          Shishi_ap ** AP, int32_t ETYPE, Shishi_tkt * TKT, int
          OPTIONS, const char * DATA, size_t LEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AP: pointer to new structure that holds information about AP
     exchange

     ETYPE: encryption type of newly generated random subkey.

     TKT: ticket to set in newly created AP.

     OPTIONS: AP-REQ options to set in newly created AP.

     DATA: input array with data to checksum in Authenticator.

     LEN: length of input array with data to checksum in Authenticator.

     Create a new AP exchange using `shishi_ap()', and set the ticket,
     AP-REQ apoptions and the Authenticator checksum data using
     `shishi_ap_set_tktoptionsdata()'. A random session key is added to
     the authenticator, using the same keytype as the ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_tktoptionsasn1usage
-----------------------------

 -- Function: int shishi_ap_tktoptionsasn1usage (Shishi * HANDLE,
          Shishi_ap ** AP, Shishi_tkt * TKT, int OPTIONS, Shishi_asn1
          NODE, const char * FIELD, int AUTHENTICATORCKSUMKEYUSAGE, int
          AUTHENTICATORKEYUSAGE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AP: pointer to new structure that holds information about AP
     exchange

     TKT: ticket to set in newly created AP.

     OPTIONS: AP-REQ options to set in newly created AP.

     NODE: input ASN.1 structure to store as authenticator checksum
     data.

     FIELD: field in ASN.1 structure to use.

     AUTHENTICATORCKSUMKEYUSAGE: key usage for checksum in
     authenticator.

     AUTHENTICATORKEYUSAGE: key usage for authenticator.

     Create a new AP exchange using `shishi_ap()', and set ticket,
     options and authenticator checksum data from the DER encoding of
     the ASN.1 field using `shishi_ap_set_tktoptionsasn1usage()'.  A
     random session key is added to the authenticator, using the same
     keytype as the ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_tkt
-------------

 -- Function: Shishi_tkt * shishi_ap_tkt (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Get Ticket from AP exchange.

     *Return value:* Returns the ticket from the AP exchange, or NULL if
     not yet set or an error occured.

shishi_ap_tkt_set
-----------------

 -- Function: void shishi_ap_tkt_set (Shishi_ap * AP, Shishi_tkt * TKT)
     AP: structure that holds information about AP exchange

     TKT: ticket to store in AP.

     Set the Ticket in the AP exchange.

shishi_ap_authenticator_cksumdata
---------------------------------

 -- Function: int shishi_ap_authenticator_cksumdata (Shishi_ap * AP,
          char * OUT, size_t * LEN)
     AP: structure that holds information about AP exchange

     OUT: output array that holds authenticator checksum data.

     LEN: on input, maximum length of output array that holds
     authenticator checksum data, on output actual length of output
     array that holds authenticator checksum data.

     Get checksum data from Authenticator.

     *Return value:* Returns SHISHI_OK if successful, or
     SHISHI_TOO_SMALL_BUFFER if buffer provided was too small.

shishi_ap_authenticator_cksumdata_set
-------------------------------------

 -- Function: void shishi_ap_authenticator_cksumdata_set (Shishi_ap *
          AP, const char * AUTHENTICATORCKSUMDATA, size_t
          AUTHENTICATORCKSUMDATALEN)
     AP: structure that holds information about AP exchange

     AUTHENTICATORCKSUMDATA: input array with data to compute checksum
     on and store in Authenticator in AP-REQ.

     AUTHENTICATORCKSUMDATALEN: length of input array with data to
     compute checksum on and store in Authenticator in AP-REQ.

     Set the Authenticator Checksum Data in the AP exchange.  This is
     the data that will be checksumed, and the checksum placed in the
     checksum field.  It is not the actual checksum field.  See also
     shishi_ap_authenticator_cksumraw_set.

shishi_ap_authenticator_cksumraw_set
------------------------------------

 -- Function: void shishi_ap_authenticator_cksumraw_set (Shishi_ap *
          AP, int32_t AUTHENTICATORCKSUMTYPE, const char *
          AUTHENTICATORCKSUMRAW, size_t AUTHENTICATORCKSUMRAWLEN)
     AP: structure that holds information about AP exchange

     AUTHENTICATORCKSUMTYPE: authenticator checksum type to set in AP.

     AUTHENTICATORCKSUMRAW: input array with authenticator checksum
     field value to set in Authenticator in AP-REQ.

     AUTHENTICATORCKSUMRAWLEN: length of input array with authenticator
     checksum field value to set in Authenticator in AP-REQ.

     Set the Authenticator Checksum Data in the AP exchange.  This is
     the actual checksum field, not data to compute checksum on and then
     store in the checksum field.  See also
     shishi_ap_authenticator_cksumdata_set.

shishi_ap_authenticator_cksumtype
---------------------------------

 -- Function: int32_t shishi_ap_authenticator_cksumtype (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Get the Authenticator Checksum Type in the AP exchange.

     *Return value:* Return the authenticator checksum type.

shishi_ap_authenticator_cksumtype_set
-------------------------------------

 -- Function: void shishi_ap_authenticator_cksumtype_set (Shishi_ap *
          AP, int32_t CKSUMTYPE)
     AP: structure that holds information about AP exchange

     CKSUMTYPE: authenticator checksum type to set in AP.

     Set the Authenticator Checksum Type in the AP exchange.

shishi_ap_authenticator
-----------------------

 -- Function: Shishi_asn1 shishi_ap_authenticator (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Get ASN.1 Authenticator structure from AP exchange.

     *Return value:* Returns the Authenticator from the AP exchange, or
     NULL if not yet set or an error occured.

shishi_ap_authenticator_set
---------------------------

 -- Function: void shishi_ap_authenticator_set (Shishi_ap * AP,
          Shishi_asn1 AUTHENTICATOR)
     AP: structure that holds information about AP exchange

     AUTHENTICATOR: authenticator to store in AP.

     Set the Authenticator in the AP exchange.

shishi_ap_req
-------------

 -- Function: Shishi_asn1 shishi_ap_req (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Get ASN.1 AP-REQ structure from AP exchange.

     *Return value:* Returns the AP-REQ from the AP exchange, or NULL if
     not yet set or an error occured.

shishi_ap_req_set
-----------------

 -- Function: void shishi_ap_req_set (Shishi_ap * AP, Shishi_asn1 APREQ)
     AP: structure that holds information about AP exchange

     APREQ: apreq to store in AP.

     Set the AP-REQ in the AP exchange.

shishi_ap_req_der
-----------------

 -- Function: int shishi_ap_req_der (Shishi_ap * AP, char ** OUT,
          size_t * OUTLEN)
     AP: structure that holds information about AP exchange

     OUT: pointer to output array with der encoding of AP-REQ.

     OUTLEN: pointer to length of output array with der encoding of
     AP-REQ.

     Build AP-REQ using `shishi_ap_req_build()' and DER encode it.
     `out' is allocated by this function, and it is the responsibility
     of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_req_der_set
---------------------

 -- Function: int shishi_ap_req_der_set (Shishi_ap * AP, char * DER,
          size_t DERLEN)
     AP: structure that holds information about AP exchange

     DER: input array with DER encoded AP-REQ.

     DERLEN: length of input array with DER encoded AP-REQ.

     DER decode AP-REQ and set it AP exchange.  If decoding fails, the
     AP-REQ in the AP exchange is lost.

     *Return value:* Returns SHISHI_OK.

shishi_ap_req_build
-------------------

 -- Function: int shishi_ap_req_build (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Checksum data in authenticator and add ticket and authenticator to
     AP-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_req_decode
--------------------

 -- Function: int shishi_ap_req_decode (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Decode ticket in AP-REQ and set the Ticket fields in the AP
     exchange.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_req_process_keyusage
------------------------------

 -- Function: int shishi_ap_req_process_keyusage (Shishi_ap * AP,
          Shishi_key * KEY, int32_t KEYUSAGE)
     AP: structure that holds information about AP exchange

     KEY: cryptographic key used to decrypt ticket in AP-REQ.

     KEYUSAGE: key usage to use during decryption, for normal AP-REQ's
     this is normally SHISHI_KEYUSAGE_APREQ_AUTHENTICATOR, for AP-REQ's
     part of TGS-REQ's, this is normally
     SHISHI_KEYUSAGE_TGSREQ_APREQ_AUTHENTICATOR.

     Decrypt ticket in AP-REQ using supplied key and decrypt
     Authenticator in AP-REQ using key in decrypted ticket, and on
     success set the Ticket and Authenticator fields in the AP exchange.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_req_process
---------------------

 -- Function: int shishi_ap_req_process (Shishi_ap * AP, Shishi_key *
          KEY)
     AP: structure that holds information about AP exchange

     KEY: cryptographic key used to decrypt ticket in AP-REQ.

     Decrypt ticket in AP-REQ using supplied key and decrypt
     Authenticator in AP-REQ using key in decrypted ticket, and on
     success set the Ticket and Authenticator fields in the AP exchange.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_req_asn1
------------------

 -- Function: int shishi_ap_req_asn1 (Shishi_ap * AP, Shishi_asn1 *
          APREQ)
     AP: structure that holds information about AP exchange

     APREQ: output AP-REQ variable.

     Build AP-REQ using `shishi_ap_req_build()' and return it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_key
-------------

 -- Function: Shishi_key * shishi_ap_key (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Extract the application key from AP.  If subkeys are used, it is
     taken from the Authenticator, otherwise the session key is used.

     *Return value:* Return application key from AP.

shishi_ap_rep
-------------

 -- Function: Shishi_asn1 shishi_ap_rep (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Get ASN.1 AP-REP structure from AP exchange.

     *Return value:* Returns the AP-REP from the AP exchange, or NULL if
     not yet set or an error occured.

shishi_ap_rep_set
-----------------

 -- Function: void shishi_ap_rep_set (Shishi_ap * AP, Shishi_asn1 APREP)
     AP: structure that holds information about AP exchange

     APREP: aprep to store in AP.

     Set the AP-REP in the AP exchange.

shishi_ap_rep_der
-----------------

 -- Function: int shishi_ap_rep_der (Shishi_ap * AP, char ** OUT,
          size_t * OUTLEN)
     AP: structure that holds information about AP exchange

     OUT: output array with newly allocated DER encoding of AP-REP.

     OUTLEN: length of output array with DER encoding of AP-REP.

     Build AP-REP using `shishi_ap_rep_build()' and DER encode it.
     `out' is allocated by this function, and it is the responsibility
     of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_rep_der_set
---------------------

 -- Function: int shishi_ap_rep_der_set (Shishi_ap * AP, char * DER,
          size_t DERLEN)
     AP: structure that holds information about AP exchange

     DER: input array with DER encoded AP-REP.

     DERLEN: length of input array with DER encoded AP-REP.

     DER decode AP-REP and set it AP exchange.  If decoding fails, the
     AP-REP in the AP exchange remains.

     *Return value:* Returns SHISHI_OK.

shishi_ap_rep_build
-------------------

 -- Function: int shishi_ap_rep_build (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Checksum data in authenticator and add ticket and authenticator to
     AP-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_rep_asn1
------------------

 -- Function: int shishi_ap_rep_asn1 (Shishi_ap * AP, Shishi_asn1 *
          APREP)
     AP: structure that holds information about AP exchange

     APREP: output AP-REP variable.

     Build AP-REP using `shishi_ap_rep_build()' and return it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ap_rep_verify
--------------------

 -- Function: int shishi_ap_rep_verify (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Verify AP-REP compared to Authenticator.

     *Return value:* Returns SHISHI_OK, SHISHI_APREP_VERIFY_FAILED or an
     error.

shishi_ap_rep_verify_der
------------------------

 -- Function: int shishi_ap_rep_verify_der (Shishi_ap * AP, char * DER,
          size_t DERLEN)
     AP: structure that holds information about AP exchange

     DER: input array with DER encoded AP-REP.

     DERLEN: length of input array with DER encoded AP-REP.

     DER decode AP-REP and set it in AP exchange using
     `shishi_ap_rep_der_set()' and verify it using
     `shishi_ap_rep_verify()'.

     *Return value:* Returns SHISHI_OK, SHISHI_APREP_VERIFY_FAILED or an
     error.

shishi_ap_rep_verify_asn1
-------------------------

 -- Function: int shishi_ap_rep_verify_asn1 (Shishi_ap * AP,
          Shishi_asn1 APREP)
     AP: structure that holds information about AP exchange

     APREP: input AP-REP.

     Set the AP-REP in the AP exchange using `shishi_ap_rep_set()' and
     verify it using `shishi_ap_rep_verify()'.

     *Return value:* Returns SHISHI_OK, SHISHI_APREP_VERIFY_FAILED or an
     error.

shishi_ap_encapreppart
----------------------

 -- Function: Shishi_asn1 shishi_ap_encapreppart (Shishi_ap * AP)
     AP: structure that holds information about AP exchange

     Get ASN.1 EncAPRepPart structure from AP exchange.

     *Return value:* Returns the EncAPREPPart from the AP exchange, or
     NULL if not yet set or an error occured.

shishi_ap_encapreppart_set
--------------------------

 -- Function: void shishi_ap_encapreppart_set (Shishi_ap * AP,
          Shishi_asn1 ENCAPREPPART)
     AP: structure that holds information about AP exchange

     ENCAPREPPART: EncAPRepPart to store in AP.

     Set the EncAPRepPart in the AP exchange.

shishi_ap_option2string
-----------------------

 -- Function: const char * shishi_ap_option2string (Shishi_apoptions
          OPTION)
     OPTION: enumerated AP-Option type, see Shishi_apoptions.

     Convert AP-Option type to AP-Option name string.  Note that
     `option' must be just one of the AP-Option types, it cannot be an
     binary ORed indicating several AP-Options.

     *Return value:* Returns static string with name of AP-Option that
     must not be deallocated, or "unknown" if AP-Option was not
     understood.

shishi_ap_string2option
-----------------------

 -- Function: Shishi_apoptions shishi_ap_string2option (const char *
          STR)
     STR: zero terminated character array with name of AP-Option, e.g.
     "use-session-key".

     Convert AP-Option name to AP-Option type.

     *Return value:* Returns enumerated type member corresponding to
     AP-Option, or 0 if string was not understood.

shishi_apreq
------------

 -- Function: Shishi_asn1 shishi_apreq (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new AP-REQ, populated with some default
     values.

     *Return value:* Returns the AP-REQ or NULL on failure.

shishi_apreq_print
------------------

 -- Function: int shishi_apreq_print (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 APREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     APREQ: AP-REQ to print.

     Print ASCII armored DER encoding of AP-REQ to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_save
-----------------

 -- Function: int shishi_apreq_save (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 APREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     APREQ: AP-REQ to save.

     Save DER encoding of AP-REQ to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_to_file
--------------------

 -- Function: int shishi_apreq_to_file (Shishi * HANDLE, Shishi_asn1
          APREQ, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write AP-REQ to file in specified TYPE.  The file will be
     truncated if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_parse
------------------

 -- Function: int shishi_apreq_parse (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * APREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     APREQ: output variable with newly allocated AP-REQ.

     Read ASCII armored DER encoded AP-REQ from file and populate given
     variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_read
-----------------

 -- Function: int shishi_apreq_read (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * APREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     APREQ: output variable with newly allocated AP-REQ.

     Read DER encoded AP-REQ from file and populate given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_from_file
----------------------

 -- Function: int shishi_apreq_from_file (Shishi * HANDLE, Shishi_asn1
          * APREQ, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: output variable with newly allocated AP-REQ.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read AP-REQ from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_set_authenticator
------------------------------

 -- Function: int shishi_apreq_set_authenticator (Shishi * HANDLE,
          Shishi_asn1 APREQ, int32_t ETYPE, uint32_t KVNO, const char *
          BUF, size_t BUFLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ to add authenticator field to.

     ETYPE: encryption type used to encrypt authenticator.

     KVNO: version of the key used to encrypt authenticator.

     BUF: input array with encrypted authenticator.

     BUFLEN: size of input array with encrypted authenticator.

     Set the encrypted authenticator field in the AP-REP.  The encrypted
     data is usually created by calling `shishi_encrypt()' on the DER
     encoded authenticator.  To save time, you may want to use
     `shishi_apreq_add_authenticator()' instead, which calculates the
     encrypted data and calls this function in one step.

     *Return value:* Returns SHISHI_OK on success.

shishi_apreq_add_authenticator
------------------------------

 -- Function: int shishi_apreq_add_authenticator (Shishi * HANDLE,
          Shishi_asn1 APREQ, Shishi_key * KEY, int KEYUSAGE,
          Shishi_asn1 AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ to add authenticator field to.

     KEY: key to to use for encryption.

     KEYUSAGE: cryptographic key usage value to use in encryption.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     Encrypts DER encoded authenticator using key and store it in the
     AP-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_set_ticket
-----------------------

 -- Function: int shishi_apreq_set_ticket (Shishi * HANDLE, Shishi_asn1
          APREQ, Shishi_asn1 TICKET)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ to add ticket field to.

     TICKET: input ticket to copy into AP-REQ ticket field.

     Copy ticket into AP-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_options
--------------------

 -- Function: int shishi_apreq_options (Shishi * HANDLE, Shishi_asn1
          APREQ, uint32_t * FLAGS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ to get options from.

     FLAGS: Output integer containing options from AP-REQ.

     Extract the AP-Options from AP-REQ into output integer.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_use_session_key_p
------------------------------

 -- Function: int shishi_apreq_use_session_key_p (Shishi * HANDLE,
          Shishi_asn1 APREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ as allocated by `shishi_apreq()'.

     Return non-0 iff the "Use session key" option is set in the AP-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_mutual_required_p
------------------------------

 -- Function: int shishi_apreq_mutual_required_p (Shishi * HANDLE,
          Shishi_asn1 APREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ as allocated by `shishi_apreq()'.

     Return non-0 iff the "Mutual required" option is set in the AP-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_options_set
------------------------

 -- Function: int shishi_apreq_options_set (Shishi * HANDLE,
          Shishi_asn1 APREQ, uint32_t OPTIONS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ as allocated by `shishi_apreq()'.

     OPTIONS: Options to set in AP-REQ.

     Set the AP-Options in AP-REQ to indicate integer.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_options_add
------------------------

 -- Function: int shishi_apreq_options_add (Shishi * HANDLE,
          Shishi_asn1 APREQ, uint32_t OPTION)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ as allocated by `shishi_apreq()'.

     OPTION: Options to add in AP-REQ.

     Add the AP-Options in AP-REQ.  Options not set in input parameter
     `option' are preserved in the AP-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_options_remove
---------------------------

 -- Function: int shishi_apreq_options_remove (Shishi * HANDLE,
          Shishi_asn1 APREQ, uint32_t OPTION)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ as allocated by `shishi_apreq()'.

     OPTION: Options to remove from AP-REQ.

     Remove the AP-Options from AP-REQ.  Options not set in input
     parameter `option' are preserved in the AP-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_get_authenticator_etype
------------------------------------

 -- Function: int shishi_apreq_get_authenticator_etype (Shishi *
          HANDLE, Shishi_asn1 APREQ, int32_t * ETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ variable to get value from.

     ETYPE: output variable that holds the value.

     Extract AP-REQ.authenticator.etype.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_apreq_get_ticket
-----------------------

 -- Function: int shishi_apreq_get_ticket (Shishi * HANDLE, Shishi_asn1
          APREQ, Shishi_asn1 * TICKET)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREQ: AP-REQ variable to get ticket from.

     TICKET: output variable to hold extracted ticket.

     Extract ticket from AP-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_aprep
------------

 -- Function: Shishi_asn1 shishi_aprep (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new AP-REP, populated with some default
     values.

     *Return value:* Returns the authenticator or NULL on failure.

shishi_aprep_print
------------------

 -- Function: int shishi_aprep_print (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 APREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     APREP: AP-REP to print.

     Print ASCII armored DER encoding of AP-REP to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_aprep_save
-----------------

 -- Function: int shishi_aprep_save (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 APREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     APREP: AP-REP to save.

     Save DER encoding of AP-REP to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_aprep_to_file
--------------------

 -- Function: int shishi_aprep_to_file (Shishi * HANDLE, Shishi_asn1
          APREP, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREP: AP-REP to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write AP-REP to file in specified TYPE.  The file will be
     truncated if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_aprep_parse
------------------

 -- Function: int shishi_aprep_parse (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * APREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     APREP: output variable with newly allocated AP-REP.

     Read ASCII armored DER encoded AP-REP from file and populate given
     variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_aprep_read
-----------------

 -- Function: int shishi_aprep_read (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * APREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     APREP: output variable with newly allocated AP-REP.

     Read DER encoded AP-REP from file and populate given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_aprep_from_file
----------------------

 -- Function: int shishi_aprep_from_file (Shishi * HANDLE, Shishi_asn1
          * APREP, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREP: output variable with newly allocated AP-REP.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read AP-REP from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_aprep_get_enc_part_etype
-------------------------------

 -- Function: int shishi_aprep_get_enc_part_etype (Shishi * HANDLE,
          Shishi_asn1 APREP, int32_t * ETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     APREP: AP-REP variable to get value from.

     ETYPE: output variable that holds the value.

     Extract AP-REP.enc-part.etype.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart
-------------------

 -- Function: Shishi_asn1 shishi_encapreppart (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new EncAPRepPart, populated with some
     default values.  It uses the current time as returned by the system
     for the ctime and cusec fields.

     *Return value:* Returns the encapreppart or NULL on failure.

shishi_encapreppart_print
-------------------------

 -- Function: int shishi_encapreppart_print (Shishi * HANDLE, FILE *
          FH, Shishi_asn1 ENCAPREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     ENCAPREPPART: EncAPRepPart to print.

     Print ASCII armored DER encoding of EncAPRepPart to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_save
------------------------

 -- Function: int shishi_encapreppart_save (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 ENCAPREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     ENCAPREPPART: EncAPRepPart to save.

     Save DER encoding of EncAPRepPart to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_to_file
---------------------------

 -- Function: int shishi_encapreppart_to_file (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: EncAPRepPart to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write EncAPRepPart to file in specified TYPE.  The file will be
     truncated if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_parse
-------------------------

 -- Function: int shishi_encapreppart_parse (Shishi * HANDLE, FILE *
          FH, Shishi_asn1 * ENCAPREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     ENCAPREPPART: output variable with newly allocated EncAPRepPart.

     Read ASCII armored DER encoded EncAPRepPart from file and populate
     given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_read
------------------------

 -- Function: int shishi_encapreppart_read (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * ENCAPREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     ENCAPREPPART: output variable with newly allocated EncAPRepPart.

     Read DER encoded EncAPRepPart from file and populate given
     variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_from_file
-----------------------------

 -- Function: int shishi_encapreppart_from_file (Shishi * HANDLE,
          Shishi_asn1 * ENCAPREPPART, int FILETYPE, const char *
          FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: output variable with newly allocated EncAPRepPart.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read EncAPRepPart from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_get_key
---------------------------

 -- Function: int shishi_encapreppart_get_key (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, Shishi_key ** KEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: input EncAPRepPart variable.

     KEY: newly allocated key.

     Extract the subkey from the encrypted AP-REP part.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_encapreppart_ctime
-------------------------

 -- Function: int shishi_encapreppart_ctime (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, char ** T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: EncAPRepPart as allocated by `shishi_encapreppart()'.

     T: newly allocated zero-terminated character array with client
     time.

     Extract client time from EncAPRepPart.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_ctime_set
-----------------------------

 -- Function: int shishi_encapreppart_ctime_set (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, const char * T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: EncAPRepPart as allocated by `shishi_encapreppart()'.

     T: string with generalized time value to store in EncAPRepPart.

     Store client time in EncAPRepPart.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_cusec_get
-----------------------------

 -- Function: int shishi_encapreppart_cusec_get (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, uint32_t * CUSEC)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: EncAPRepPart as allocated by `shishi_encapreppart()'.

     CUSEC: output integer with client microseconds field.

     Extract client microseconds field from EncAPRepPart.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_cusec_set
-----------------------------

 -- Function: int shishi_encapreppart_cusec_set (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, uint32_t CUSEC)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: EncAPRepPart as allocated by `shishi_encapreppart()'.

     CUSEC: client microseconds to set in authenticator, 0-999999.

     Set the cusec field in the Authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_seqnumber_get
---------------------------------

 -- Function: int shishi_encapreppart_seqnumber_get (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, uint32_t * SEQNUMBER)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: EncAPRepPart as allocated by `shishi_encapreppart()'.

     SEQNUMBER: output integer with sequence number field.

     Extract sequence number field from EncAPRepPart.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encapreppart_seqnumber_remove
------------------------------------

 -- Function: int shishi_encapreppart_seqnumber_remove (Shishi *
          HANDLE, Shishi_asn1 ENCAPREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: encapreppart as allocated by `shishi_encapreppart()'.

     Remove sequence number field in EncAPRepPart.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_encapreppart_seqnumber_set
---------------------------------

 -- Function: int shishi_encapreppart_seqnumber_set (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, uint32_t SEQNUMBER)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: encapreppart as allocated by `shishi_encapreppart()'.

     SEQNUMBER: integer with sequence number field to store in
     encapreppart.

     Store sequence number field in EncAPRepPart.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_encapreppart_time_copy
-----------------------------

 -- Function: int shishi_encapreppart_time_copy (Shishi * HANDLE,
          Shishi_asn1 ENCAPREPPART, Shishi_asn1 AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCAPREPPART: EncAPRepPart as allocated by `shishi_encapreppart()'.

     AUTHENTICATOR: Authenticator to copy time fields from.

     Copy time fields from Authenticator into EncAPRepPart.

     *Return value:* Returns SHISHI_OK iff successful.


File: shishi.info,  Node: SAFE and PRIV Functions,  Next: Ticket Functions,  Prev: AP-REQ and AP-REP Functions,  Up: Programming Manual

5.5 SAFE and PRIV Functions
===========================

The "KRB-SAFE" is an ASN.1 structure used by application client and
servers to exchange integrity protected data.  The integrity protection
is keyed, usually with a key agreed on via the AP exchange (*note
AP-REQ and AP-REP Functions::).  The following illustrates the KRB-SAFE
ASN.1 structure.

   KRB-SAFE        ::= [APPLICATION 20] SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (20),
           safe-body       [2] KRB-SAFE-BODY,
           cksum           [3] Checksum
   }

   KRB-SAFE-BODY   ::= SEQUENCE {
           user-data       [0] OCTET STRING,
           timestamp       [1] KerberosTime OPTIONAL,
           usec            [2] Microseconds OPTIONAL,
           seq-number      [3] UInt32 OPTIONAL,
           s-address       [4] HostAddress,
           r-address       [5] HostAddress OPTIONAL
   }

shishi_safe
-----------

 -- Function: int shishi_safe (Shishi * HANDLE, Shishi_safe ** SAFE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     SAFE: pointer to new structure that holds information about SAFE
     exchange

     Create a new SAFE exchange.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_done
----------------

 -- Function: void shishi_safe_done (Shishi_safe * SAFE)
     SAFE: structure that holds information about SAFE exchange

     Deallocate resources associated with SAFE exchange.  This should be
     called by the application when it no longer need to utilize the
     SAFE exchange handle.

shishi_safe_key
---------------

 -- Function: Shishi_key * shishi_safe_key (Shishi_safe * SAFE)
     SAFE: structure that holds information about SAFE exchange

     Get key structured from SAFE exchange.

     *Return value:* Returns the key used in the SAFE exchange, or NULL
     if not yet set or an error occured.

shishi_safe_key_set
-------------------

 -- Function: void shishi_safe_key_set (Shishi_safe * SAFE, Shishi_key
          * KEY)
     SAFE: structure that holds information about SAFE exchange

     KEY: key to store in SAFE.

     Set the Key in the SAFE exchange.

shishi_safe_safe
----------------

 -- Function: Shishi_asn1 shishi_safe_safe (Shishi_safe * SAFE)
     SAFE: structure that holds information about SAFE exchange

     Get ASN.1 SAFE structured from SAFE exchange.

     *Return value:* Returns the ASN.1 safe in the SAFE exchange, or
     NULL if not yet set or an error occured.

shishi_safe_safe_set
--------------------

 -- Function: void shishi_safe_safe_set (Shishi_safe * SAFE,
          Shishi_asn1 ASN1SAFE)
     SAFE: structure that holds information about SAFE exchange

     ASN1SAFE: KRB-SAFE to store in SAFE exchange.

     Set the KRB-SAFE in the SAFE exchange.

shishi_safe_safe_der
--------------------

 -- Function: int shishi_safe_safe_der (Shishi_safe * SAFE, char **
          OUT, size_t * OUTLEN)
     SAFE: safe as allocated by `shishi_safe()'.

     OUT: output array with newly allocated DER encoding of SAFE.

     OUTLEN: length of output array with DER encoding of SAFE.

     DER encode SAFE structure.  Typically `shishi_safe_build()' is used
     to build the SAFE structure first.  `out' is allocated by this
     function, and it is the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_safe_der_set
------------------------

 -- Function: int shishi_safe_safe_der_set (Shishi_safe * SAFE, char *
          DER, size_t DERLEN)
     SAFE: safe as allocated by `shishi_safe()'.

     DER: input array with DER encoded KRB-SAFE.

     DERLEN: length of input array with DER encoded KRB-SAFE.

     DER decode KRB-SAFE and set it SAFE exchange.  If decoding fails,
     the KRB-SAFE in the SAFE exchange remains.

     *Return value:* Returns SHISHI_OK.

shishi_safe_print
-----------------

 -- Function: int shishi_safe_print (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 SAFE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     SAFE: SAFE to print.

     Print ASCII armored DER encoding of SAFE to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_save
----------------

 -- Function: int shishi_safe_save (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 SAFE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     SAFE: SAFE to save.

     Save DER encoding of SAFE to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_to_file
-------------------

 -- Function: int shishi_safe_to_file (Shishi * HANDLE, Shishi_asn1
          SAFE, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     SAFE: SAFE to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write SAFE to file in specified TYPE.  The file will be truncated
     if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_parse
-----------------

 -- Function: int shishi_safe_parse (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * SAFE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     SAFE: output variable with newly allocated SAFE.

     Read ASCII armored DER encoded SAFE from file and populate given
     variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_read
----------------

 -- Function: int shishi_safe_read (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * SAFE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     SAFE: output variable with newly allocated SAFE.

     Read DER encoded SAFE from file and populate given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_from_file
---------------------

 -- Function: int shishi_safe_from_file (Shishi * HANDLE, Shishi_asn1 *
          SAFE, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     SAFE: output variable with newly allocated SAFE.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read SAFE from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_cksum
-----------------

 -- Function: int shishi_safe_cksum (Shishi * HANDLE, Shishi_asn1 SAFE,
          int32_t * CKSUMTYPE, char ** CKSUM, size_t * CKSUMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     SAFE: safe as allocated by `shishi_safe()'.

     CKSUMTYPE: output checksum type.

     CKSUM: output array with newly allocated checksum data from SAFE.

     CKSUMLEN: output size of output checksum data buffer.

     Read checksum value from KRB-SAFE.  `cksum' is allocated by this
     function, and it is the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_set_cksum
---------------------

 -- Function: int shishi_safe_set_cksum (Shishi * HANDLE, Shishi_asn1
          SAFE, int32_t CKSUMTYPE, const char * CKSUM, size_t CKSUMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     SAFE: safe as allocated by `shishi_safe()'.

     CKSUMTYPE: input checksum type to store in SAFE.

     CKSUM: input checksum data to store in SAFE.

     CKSUMLEN: size of input checksum data to store in SAFE.

     Store checksum value in SAFE.  A checksum is usually created by
     calling `shishi_checksum()' on some application specific data using
     the key from the ticket that is being used.  To save time, you may
     want to use `shishi_safe_build()' instead, which calculates the
     checksum and calls this function in one step.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_user_data
---------------------

 -- Function: int shishi_safe_user_data (Shishi * HANDLE, Shishi_asn1
          SAFE, char ** USERDATA, size_t * USERDATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     SAFE: safe as allocated by `shishi_safe()'.

     USERDATA: output array with newly allocated user data from
     KRB-SAFE.

     USERDATALEN: output size of output user data buffer.

     Read user data value from KRB-SAFE.  `userdata' is allocated by
     this function, and it is the responsibility of caller to
     deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_set_user_data
-------------------------

 -- Function: int shishi_safe_set_user_data (Shishi * HANDLE,
          Shishi_asn1 SAFE, const char * USERDATA, size_t USERDATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     SAFE: safe as allocated by `shishi_safe()'.

     USERDATA: input user application to store in SAFE.

     USERDATALEN: size of input user application to store in SAFE.

     Set the application data in SAFE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_build
-----------------

 -- Function: int shishi_safe_build (Shishi_safe * SAFE, Shishi_key *
          KEY)
     SAFE: safe as allocated by `shishi_safe()'.

     KEY: key for session, used to compute checksum.

     Build checksum and set it in KRB-SAFE.  Note that this follows RFC
     1510bis and is incompatible with RFC 1510, although presumably few
     implementations use the RFC1510 algorithm.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_safe_verify
------------------

 -- Function: int shishi_safe_verify (Shishi_safe * SAFE, Shishi_key *
          KEY)
     SAFE: safe as allocated by `shishi_safe()'.

     KEY: key for session, used to verify checksum.

     Verify checksum in KRB-SAFE.  Note that this follows RFC 1510bis
     and is incompatible with RFC 1510, although presumably few
     implementations use the RFC1510 algorithm.

     *Return value:* Returns SHISHI_OK iff successful,
     SHISHI_SAFE_BAD_KEYTYPE if an incompatible key type is used, or
     SHISHI_SAFE_VERIFY_FAILED if the actual verification failed.

   The "KRB-PRIV" is an ASN.1 structure used by application client and
servers to exchange confidential data.  The confidentiality is keyed,
usually with a key agreed on via the AP exchange (*note AP-REQ and
AP-REP Functions::).  The following illustrates the KRB-PRIV ASN.1
structure.

   KRB-PRIV        ::= [APPLICATION 21] SEQUENCE {
           pvno            [0] INTEGER (5),
           msg-type        [1] INTEGER (21),
                           -- NOTE: there is no [2] tag
           enc-part        [3] EncryptedData -- EncKrbPrivPart
   }

   EncKrbPrivPart  ::= [APPLICATION 28] SEQUENCE {
           user-data       [0] OCTET STRING,
           timestamp       [1] KerberosTime OPTIONAL,
           usec            [2] Microseconds OPTIONAL,
           seq-number      [3] UInt32 OPTIONAL,
           s-address       [4] HostAddress -- sender's addr --,
           r-address       [5] HostAddress OPTIONAL -- recip's addr
   }

shishi_priv
-----------

 -- Function: int shishi_priv (Shishi * HANDLE, Shishi_priv ** PRIV)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     PRIV: pointer to new structure that holds information about PRIV
     exchange

     Create a new PRIV exchange.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_done
----------------

 -- Function: void shishi_priv_done (Shishi_priv * PRIV)
     PRIV: structure that holds information about PRIV exchange

     Deallocate resources associated with PRIV exchange.  This should be
     called by the application when it no longer need to utilize the
     PRIV exchange handle.

shishi_priv_key
---------------

 -- Function: Shishi_key * shishi_priv_key (Shishi_priv * PRIV)
     PRIV: structure that holds information about PRIV exchange

     Get key from PRIV exchange.

     *Return value:* Returns the key used in the PRIV exchange, or NULL
     if not yet set or an error occured.

shishi_priv_key_set
-------------------

 -- Function: void shishi_priv_key_set (Shishi_priv * PRIV, Shishi_key
          * KEY)
     PRIV: structure that holds information about PRIV exchange

     KEY: key to store in PRIV.

     Set the Key in the PRIV exchange.

shishi_priv_priv
----------------

 -- Function: Shishi_asn1 shishi_priv_priv (Shishi_priv * PRIV)
     PRIV: structure that holds information about PRIV exchange

     Get ASN.1 PRIV structure in PRIV exchange.

     *Return value:* Returns the ASN.1 priv in the PRIV exchange, or
     NULL if not yet set or an error occured.

shishi_priv_priv_set
--------------------

 -- Function: void shishi_priv_priv_set (Shishi_priv * PRIV,
          Shishi_asn1 ASN1PRIV)
     PRIV: structure that holds information about PRIV exchange

     ASN1PRIV: KRB-PRIV to store in PRIV exchange.

     Set the KRB-PRIV in the PRIV exchange.

shishi_priv_priv_der
--------------------

 -- Function: int shishi_priv_priv_der (Shishi_priv * PRIV, char **
          OUT, size_t * OUTLEN)
     PRIV: priv as allocated by `shishi_priv()'.

     OUT: output array with newly allocated DER encoding of PRIV.

     OUTLEN: length of output array with DER encoding of PRIV.

     DER encode PRIV structure.  Typically `shishi_priv_build()' is used
     to build the PRIV structure first.  `out' is allocated by this
     function, and it is the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_priv_der_set
------------------------

 -- Function: int shishi_priv_priv_der_set (Shishi_priv * PRIV, char *
          DER, size_t DERLEN)
     PRIV: priv as allocated by `shishi_priv()'.

     DER: input array with DER encoded KRB-PRIV.

     DERLEN: length of input array with DER encoded KRB-PRIV.

     DER decode KRB-PRIV and set it PRIV exchange.  If decoding fails,
     the KRB-PRIV in the PRIV exchange remains.

     *Return value:* Returns SHISHI_OK.

shishi_priv_encprivpart
-----------------------

 -- Function: Shishi_asn1 shishi_priv_encprivpart (Shishi_priv * PRIV)
     PRIV: structure that holds information about PRIV exchange

     Get ASN.1 EncPrivPart structure from PRIV exchange.

     *Return value:* Returns the ASN.1 encprivpart in the PRIV
     exchange, or NULL if not yet set or an error occured.

shishi_priv_encprivpart_set
---------------------------

 -- Function: void shishi_priv_encprivpart_set (Shishi_priv * PRIV,
          Shishi_asn1 ASN1ENCPRIVPART)
     PRIV: structure that holds information about PRIV exchange

     ASN1ENCPRIVPART: ENCPRIVPART to store in PRIV exchange.

     Set the ENCPRIVPART in the PRIV exchange.

shishi_priv_encprivpart_der
---------------------------

 -- Function: int shishi_priv_encprivpart_der (Shishi_priv * PRIV, char
          ** OUT, size_t * OUTLEN)
     PRIV: priv as allocated by `shishi_priv()'.

     OUT: output array with newly allocated DER encoding of ENCPRIVPART.

     OUTLEN: length of output array with DER encoding of ENCPRIVPART.

     DER encode ENCPRIVPART structure.  Typically
     `shishi_encprivpart_build()' is used to build the ENCPRIVPART
     structure first.  `out' is allocated by this function, and it is
     the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_encprivpart_der_set
-------------------------------

 -- Function: int shishi_priv_encprivpart_der_set (Shishi_priv * PRIV,
          char * DER, size_t DERLEN)
     PRIV: priv as allocated by `shishi_priv()'.

     DER: input array with DER encoded ENCPRIVPART.

     DERLEN: length of input array with DER encoded ENCPRIVPART.

     DER decode ENCPRIVPART and set it PRIV exchange.  If decoding
     fails, the ENCPRIVPART in the PRIV exchange remains.

     *Return value:* Returns SHISHI_OK.

shishi_priv_print
-----------------

 -- Function: int shishi_priv_print (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 PRIV)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     PRIV: PRIV to print.

     Print ASCII armored DER encoding of PRIV to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_save
----------------

 -- Function: int shishi_priv_save (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 PRIV)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     PRIV: PRIV to save.

     Save DER encoding of PRIV to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_to_file
-------------------

 -- Function: int shishi_priv_to_file (Shishi * HANDLE, Shishi_asn1
          PRIV, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     PRIV: PRIV to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write PRIV to file in specified TYPE.  The file will be truncated
     if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_parse
-----------------

 -- Function: int shishi_priv_parse (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * PRIV)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     PRIV: output variable with newly allocated PRIV.

     Read ASCII armored DER encoded PRIV from file and populate given
     variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_read
----------------

 -- Function: int shishi_priv_read (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * PRIV)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     PRIV: output variable with newly allocated PRIV.

     Read DER encoded PRIV from file and populate given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_from_file
---------------------

 -- Function: int shishi_priv_from_file (Shishi * HANDLE, Shishi_asn1 *
          PRIV, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     PRIV: output variable with newly allocated PRIV.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read PRIV from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_enc_part_etype
--------------------------

 -- Function: int shishi_priv_enc_part_etype (Shishi * HANDLE,
          Shishi_asn1 PRIV, int32_t * ETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     PRIV: PRIV variable to get value from.

     ETYPE: output variable that holds the value.

     Extract PRIV.enc-part.etype.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_set_enc_part
------------------------

 -- Function: int shishi_priv_set_enc_part (Shishi * HANDLE,
          Shishi_asn1 PRIV, int32_t ETYPE, const char * ENCPART, size_t
          ENCPARTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     PRIV: priv as allocated by `shishi_priv()'.

     ETYPE: input encryption type to store in PRIV.

     ENCPART: input encrypted data to store in PRIV.

     ENCPARTLEN: size of input encrypted data to store in PRIV.

     Store encrypted data in PRIV.  The encrypted data is usually
     created by calling `shishi_encrypt()' on some application specific
     data using the key from the ticket that is being used.  To save
     time, you may want to use `shishi_priv_build()' instead, which
     encryptes the data and calls this function in one step.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encprivpart_user_data
----------------------------

 -- Function: int shishi_encprivpart_user_data (Shishi * HANDLE,
          Shishi_asn1 ENCPRIVPART, char ** USERDATA, size_t *
          USERDATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCPRIVPART: encprivpart as allocated by `shishi_priv()'.

     USERDATA: output array with newly allocated user data from
     KRB-PRIV.

     USERDATALEN: output size of output user data buffer.

     Read user data value from KRB-PRIV.  `userdata' is allocated by
     this function, and it is the responsibility of caller to
     deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encprivpart_set_user_data
--------------------------------

 -- Function: int shishi_encprivpart_set_user_data (Shishi * HANDLE,
          Shishi_asn1 ENCPRIVPART, const char * USERDATA, size_t
          USERDATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCPRIVPART: encprivpart as allocated by `shishi_priv()'.

     USERDATA: input user application to store in PRIV.

     USERDATALEN: size of input user application to store in PRIV.

     Set the application data in PRIV.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_build
-----------------

 -- Function: int shishi_priv_build (Shishi_priv * PRIV, Shishi_key *
          KEY)
     PRIV: priv as allocated by `shishi_priv()'.

     KEY: key for session, used to encrypt data.

     Build checksum and set it in KRB-PRIV.  Note that this follows RFC
     1510bis and is incompatible with RFC 1510, although presumably few
     implementations use the RFC1510 algorithm.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_priv_process
-------------------

 -- Function: int shishi_priv_process (Shishi_priv * PRIV, Shishi_key *
          KEY)
     PRIV: priv as allocated by `shishi_priv()'.

     KEY: key to use to decrypt EncPrivPart.

     Decrypt encrypted data in KRB-PRIV and set the EncPrivPart in the
     PRIV exchange.

     *Return value:* Returns SHISHI_OK iff successful,
     SHISHI_PRIV_BAD_KEYTYPE if an incompatible key type is used, or
     SHISHI_CRYPTO_ERROR if the actual decryption failed.


File: shishi.info,  Node: Ticket Functions,  Next: AS Functions,  Prev: SAFE and PRIV Functions,  Up: Programming Manual

5.6 Ticket Functions
====================

A Ticket is an ASN.1 structured that can be used to authenticate the
holder to services.  It contain an encrypted part, which the ticket
holder cannot see, but can be encrypted by the service, and various
information about the user and service, including an encryption key to
use for the connection.  *Note Ticket (ASN.1) Functions::, for more
details on the ASN.1 structure of a ticket.

shishi_tkt
----------

 -- Function: int shishi_tkt (Shishi * HANDLE, Shishi_tkt ** TKT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TKT: output variable with newly allocated ticket.

     Create a new ticket handle.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt2
-----------

 -- Function: Shishi_tkt * shishi_tkt2 (Shishi * HANDLE, Shishi_asn1
          TICKET, Shishi_asn1 ENCKDCREPPART, Shishi_asn1 KDCREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TICKET: input variable with ticket.

     ENCKDCREPPART: input variable with auxilliary ticket information.

     KDCREP: input variable with KDC-REP ticket information.

     Create a new ticket handle.

     *Return value:* Returns new ticket handle, or `NULL' on error.

shishi_tkt_done
---------------

 -- Function: void shishi_tkt_done (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Deallocate resources associated with ticket.  The ticket must not
     be used again after this call.

shishi_tkt_ticket
-----------------

 -- Function: Shishi_asn1 shishi_tkt_ticket (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Get ASN.1 Ticket structure from ticket.

     *Return value:* Returns actual ticket.

shishi_tkt_ticket_set
---------------------

 -- Function: void shishi_tkt_ticket_set (Shishi_tkt * TKT, Shishi_asn1
          TICKET)
     TKT: input variable with ticket info.

     TICKET: ASN.1 Ticket to store in ticket.

     Set the ASN.1 Ticket in the Ticket.

shishi_tkt_enckdcreppart
------------------------

 -- Function: Shishi_asn1 shishi_tkt_enckdcreppart (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Get ASN.1 EncKDCRepPart structure from ticket.

     *Return value:* Returns auxilliary ticket information.

shishi_tkt_enckdcreppart_set
----------------------------

 -- Function: void shishi_tkt_enckdcreppart_set (Shishi_tkt * TKT,
          Shishi_asn1 ENCKDCREPPART)
     TKT: structure that holds information about Ticket exchange

     ENCKDCREPPART: EncKDCRepPart to store in Ticket.

     Set the EncKDCRepPart in the Ticket.

shishi_tkt_kdcrep
-----------------

 -- Function: Shishi_asn1 shishi_tkt_kdcrep (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Get ASN.1 KDCRep structure from ticket.

     *Return value:* Returns KDC-REP information.

shishi_tkt_encticketpart
------------------------

 -- Function: Shishi_asn1 shishi_tkt_encticketpart (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Get ASN.1 EncTicketPart structure from ticket.

     *Return value:* Returns EncTicketPart information.

shishi_tkt_encticketpart_set
----------------------------

 -- Function: void shishi_tkt_encticketpart_set (Shishi_tkt * TKT,
          Shishi_asn1 ENCTICKETPART)
     TKT: input variable with ticket info.

     ENCTICKETPART: encticketpart to store in ticket.

     Set the EncTicketPart in the Ticket.

shishi_tkt_key
--------------

 -- Function: Shishi_key * shishi_tkt_key (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Get key used in ticket, by looking first in EncKDCRepPart and then
     in EncTicketPart.  If key is already populated, it is not extracted
     again.

     *Return value:* Returns key extracted from EncKDCRepPart or
     EncTicketPart.

shishi_tkt_key_set
------------------

 -- Function: int shishi_tkt_key_set (Shishi_tkt * TKT, Shishi_key *
          KEY)
     TKT: input variable with ticket info.

     KEY: key to store in ticket.

     Set the key in the EncTicketPart.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_client
-----------------

 -- Function: int shishi_tkt_client (Shishi_tkt * TKT, char ** CLIENT,
          size_t * CLIENTLEN)
     TKT: input variable with ticket info.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name.  May be `NULL' (to only populate
     `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Represent client principal name in Ticket KDC-REP as
     zero-terminated string.  The string is allocate by this function,
     and it is the responsibility of the caller to deallocate it.  Note
     that the output length `clientlen' does not include the terminating
     zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_client_p
-------------------

 -- Function: int shishi_tkt_client_p (Shishi_tkt * TKT, const char *
          CLIENT)
     TKT: input variable with ticket info.

     CLIENT: client name of ticket.

     Determine if ticket is for specified client.

     *Return value:* Returns non-0 iff ticket is for specified client.

shishi_tkt_clientrealm
----------------------

 -- Function: int shishi_tkt_clientrealm (Shishi_tkt * TKT, char **
          CLIENT, size_t * CLIENTLEN)
     TKT: input variable with ticket info.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name and realm.  May be `NULL' (to only
     populate `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Convert cname and realm fields from AS-REQ to printable principal
     name format.  The string is allocate by this function, and it is
     the responsibility of the caller to deallocate it.  Note that the
     output length `clientlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_clientrealm_p
------------------------

 -- Function: int shishi_tkt_clientrealm_p (Shishi_tkt * TKT, const
          char * CLIENT)
     TKT: input variable with ticket info.

     CLIENT: principal name (client name and realm) of ticket.

     Determine if ticket is for specified client principal.

     *Return value:* Returns non-0 iff ticket is for specified client
     principal.

shishi_tkt_realm
----------------

 -- Function: int shishi_tkt_realm (Shishi_tkt * TKT, char ** REALM,
          size_t * REALMLEN)
     TKT: input variable with ticket info.

     REALM: pointer to newly allocated character array with realm name.

     REALMLEN: length of newly allocated character array with realm
     name.

     Extract realm of server in ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_server
-----------------

 -- Function: int shishi_tkt_server (Shishi_tkt * TKT, char ** SERVER,
          size_t * SERVERLEN)
     TKT: input variable with ticket info.

     SERVER: pointer to newly allocated zero terminated string
     containing principal name.  May be `NULL' (to only populate
     `serverlen').

     SERVERLEN: pointer to length of `server' on output, excluding
     terminating zero.  May be `NULL' (to only populate `server').

     Represent server principal name in Ticket as zero-terminated
     string.  The string is allocate by this function, and it is the
     responsibility of the caller to deallocate it.  Note that the
     output length `serverlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_server_p
-------------------

 -- Function: int shishi_tkt_server_p (Shishi_tkt * TKT, const char *
          SERVER)
     TKT: input variable with ticket info.

     SERVER: server name of ticket.

     Determine if ticket is for specified server.

     *Return value:* Returns non-0 iff ticket is for specified server.

shishi_tkt_flags
----------------

 -- Function: int shishi_tkt_flags (Shishi_tkt * TKT, uint32_t * FLAGS)
     TKT: input variable with ticket info.

     FLAGS: pointer to output integer with flags.

     Extract flags in ticket (i.e., EncKDCRepPart).

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_flags_set
--------------------

 -- Function: int shishi_tkt_flags_set (Shishi_tkt * TKT, uint32_t
          FLAGS)
     TKT: input variable with ticket info.

     FLAGS: integer with flags to store in ticket.

     Set flags in ticket, i.e., both EncTicketPart and EncKDCRepPart.
     Note that this reset any already existing flags.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_flags_add
--------------------

 -- Function: int shishi_tkt_flags_add (Shishi_tkt * TKT, uint32_t FLAG)
     TKT: input variable with ticket info.

     FLAG: integer with flags to store in ticket.

     Add ticket flags to Ticket and EncKDCRepPart.  This preserves all
     existing options.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_forwardable_p
------------------------

 -- Function: int shishi_tkt_forwardable_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is forwardable.

     The FORWARDABLE flag in a ticket is normally only interpreted by
     the ticket-granting service. It can be ignored by application
     servers.  The FORWARDABLE flag has an interpretation similar to
     that of the PROXIABLE flag, except ticket-granting tickets may also
     be issued with different network addresses. This flag is reset by
     default, but users MAY request that it be set by setting the
     FORWARDABLE option in the AS request when they request their
     initial ticket-granting ticket.

     *Return value:* Returns non-0 iff forwardable flag is set in
     ticket.

shishi_tkt_forwarded_p
----------------------

 -- Function: int shishi_tkt_forwarded_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is forwarded.

     The FORWARDED flag is set by the TGS when a client presents a
     ticket with the FORWARDABLE flag set and requests a forwarded
     ticket by specifying the FORWARDED KDC option and supplying a set
     of addresses for the new ticket. It is also set in all tickets
     issued based on tickets with the FORWARDED flag set. Application
     servers may choose to process FORWARDED tickets differently than
     non-FORWARDED tickets.

     *Return value:* Returns non-0 iff forwarded flag is set in ticket.

shishi_tkt_proxiable_p
----------------------

 -- Function: int shishi_tkt_proxiable_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is proxiable.

     The PROXIABLE flag in a ticket is normally only interpreted by the
     ticket-granting service. It can be ignored by application servers.
     When set, this flag tells the ticket-granting server that it is OK
     to issue a new ticket (but not a ticket-granting ticket) with a
     different network address based on this ticket. This flag is set if
     requested by the client on initial authentication. By default, the
     client will request that it be set when requesting a
     ticket-granting ticket, and reset when requesting any other ticket.

     *Return value:* Returns non-0 iff proxiable flag is set in ticket.

shishi_tkt_proxy_p
------------------

 -- Function: int shishi_tkt_proxy_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is proxy ticket.

     The PROXY flag is set in a ticket by the TGS when it issues a proxy
     ticket.  Application servers MAY check this flag and at their
     option they MAY require additional authentication from the agent
     presenting the proxy in order to provide an audit trail.

     *Return value:* Returns non-0 iff proxy flag is set in ticket.

shishi_tkt_may_postdate_p
-------------------------

 -- Function: int shishi_tkt_may_postdate_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket may be used to grant postdated tickets.

     The MAY-POSTDATE flag in a ticket is normally only interpreted by
     the ticket-granting service. It can be ignored by application
     servers.  This flag MUST be set in a ticket-granting ticket in
     order to issue a postdated ticket based on the presented ticket. It
     is reset by default; it MAY be requested by a client by setting the
     ALLOW- POSTDATE option in the KRB_AS_REQ message.  This flag does
     not allow a client to obtain a postdated ticket-granting ticket;
     postdated ticket-granting tickets can only by obtained by
     requesting the postdating in the KRB_AS_REQ message. The life
     (endtime-starttime) of a postdated ticket will be the remaining
     life of the ticket-granting ticket at the time of the request,
     unless the RENEWABLE option is also set, in which case it can be
     the full life (endtime-starttime) of the ticket-granting ticket.
     The KDC MAY limit how far in the future a ticket may be postdated.

     *Return value:* Returns non-0 iff may-postdate flag is set in
     ticket.

shishi_tkt_postdated_p
----------------------

 -- Function: int shishi_tkt_postdated_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is postdated.

     The POSTDATED flag indicates that a ticket has been postdated. The
     application server can check the authtime field in the ticket to
     see when the original authentication occurred. Some services MAY
     choose to reject postdated tickets, or they may only accept them
     within a certain period after the original authentication. When the
     KDC issues a POSTDATED ticket, it will also be marked as INVALID,
     so that the application client MUST present the ticket to the KDC
     to be validated before use.

     *Return value:* Returns non-0 iff postdated flag is set in ticket.

shishi_tkt_invalid_p
--------------------

 -- Function: int shishi_tkt_invalid_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is invalid.

     The INVALID flag indicates that a ticket is invalid. Application
     servers MUST reject tickets which have this flag set. A postdated
     ticket will be issued in this form. Invalid tickets MUST be
     validated by the KDC before use, by presenting them to the KDC in a
     TGS request with the VALIDATE option specified. The KDC will only
     validate tickets after their starttime has passed. The validation
     is required so that postdated tickets which have been stolen before
     their starttime can be rendered permanently invalid (through a
     hot-list mechanism).

     *Return value:* Returns non-0 iff invalid flag is set in ticket.

shishi_tkt_renewable_p
----------------------

 -- Function: int shishi_tkt_renewable_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is renewable.

     The RENEWABLE flag in a ticket is normally only interpreted by the
     ticket-granting service (discussed below in section 3.3). It can
     usually be ignored by application servers. However, some
     particularly careful application servers MAY disallow renewable
     tickets.

     *Return value:* Returns non-0 iff renewable flag is set in ticket.

shishi_tkt_initial_p
--------------------

 -- Function: int shishi_tkt_initial_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket was issued using AS exchange.

     The INITIAL flag indicates that a ticket was issued using the AS
     protocol, rather than issued based on a ticket-granting ticket.
     Application servers that want to require the demonstrated knowledge
     of a client's secret key (e.g. a password-changing program) can
     insist that this flag be set in any tickets they accept, and thus
     be assured that the client's key was recently presented to the
     application client.

     *Return value:* Returns non-0 iff initial flag is set in ticket.

shishi_tkt_pre_authent_p
------------------------

 -- Function: int shishi_tkt_pre_authent_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket was pre-authenticated.

     The PRE-AUTHENT and HW-AUTHENT flags provide additional information
     about the initial authentication, regardless of whether the current
     ticket was issued directly (in which case INITIAL will also be set)
     or issued on the basis of a ticket-granting ticket (in which case
     the INITIAL flag is clear, but the PRE-AUTHENT and HW-AUTHENT flags
     are carried forward from the ticket-granting ticket).

     *Return value:* Returns non-0 iff pre-authent flag is set in
     ticket.

shishi_tkt_hw_authent_p
-----------------------

 -- Function: int shishi_tkt_hw_authent_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is authenticated using a hardware token.

     The PRE-AUTHENT and HW-AUTHENT flags provide additional information
     about the initial authentication, regardless of whether the current
     ticket was issued directly (in which case INITIAL will also be set)
     or issued on the basis of a ticket-granting ticket (in which case
     the INITIAL flag is clear, but the PRE-AUTHENT and HW-AUTHENT flags
     are carried forward from the ticket-granting ticket).

     *Return value:* Returns non-0 iff hw-authent flag is set in ticket.

shishi_tkt_transited_policy_checked_p
-------------------------------------

 -- Function: int shishi_tkt_transited_policy_checked_p (Shishi_tkt *
          TKT)
     TKT: input variable with ticket info.

     Determine if ticket has been policy checked for transit.

     The application server is ultimately responsible for accepting or
     rejecting authentication and SHOULD check that only suitably
     trusted KDCs are relied upon to authenticate a principal.  The
     transited field in the ticket identifies which realms (and thus
     which KDCs) were involved in the authentication process and an
     application server would normally check this field. If any of these
     are untrusted to authenticate the indicated client principal
     (probably determined by a realm-based policy), the authentication
     attempt MUST be rejected. The presence of trusted KDCs in this list
     does not provide any guarantee; an untrusted KDC may have
     fabricated the list.

     While the end server ultimately decides whether authentication is
     valid, the KDC for the end server's realm MAY apply a realm
     specific policy for validating the transited field and accepting
     credentials for cross-realm authentication. When the KDC applies
     such checks and accepts such cross-realm authentication it will set
     the TRANSITED-POLICY-CHECKED flag in the service tickets it issues
     based on the cross-realm TGT. A client MAY request that the KDCs
     not check the transited field by setting the
     DISABLE-TRANSITED-CHECK flag. KDCs are encouraged but not required
     to honor this flag.

     Application servers MUST either do the transited-realm checks
     themselves, or reject cross-realm tickets without TRANSITED-POLICY-
     CHECKED set.

     *Return value:* Returns non-0 iff transited-policy-checked flag is
     set in ticket.

shishi_tkt_ok_as_delegate_p
---------------------------

 -- Function: int shishi_tkt_ok_as_delegate_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is ok as delegated ticket.

     The copy of the ticket flags in the encrypted part of the KDC reply
     may have the OK-AS-DELEGATE flag set to indicates to the client
     that the server specified in the ticket has been determined by
     policy of the realm to be a suitable recipient of delegation.  A
     client can use the presence of this flag to help it make a decision
     whether to delegate credentials (either grant a proxy or a
     forwarded ticket- granting ticket) to this server.  It is
     acceptable to ignore the value of this flag. When setting this
     flag, an administrator should consider the security and placement
     of the server on which the service will run, as well as whether the
     service requires the use of delegated credentials.

     *Return value:* Returns non-0 iff ok-as-delegate flag is set in
     ticket.

shishi_tkt_keytype
------------------

 -- Function: int shishi_tkt_keytype (Shishi_tkt * TKT, int32_t * ETYPE)
     TKT: input variable with ticket info.

     ETYPE: pointer to encryption type that is set, see Shishi_etype.

     Extract encryption type of key in ticket (really EncKDCRepPart).

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tkt_keytype_fast
-----------------------

 -- Function: int32_t shishi_tkt_keytype_fast (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Extract encryption type of key in ticket (really EncKDCRepPart).

     *Return value:* Returns encryption type of session key in ticket
     (really EncKDCRepPart), or -1 on error.

shishi_tkt_keytype_p
--------------------

 -- Function: int shishi_tkt_keytype_p (Shishi_tkt * TKT, int32_t ETYPE)
     TKT: input variable with ticket info.

     ETYPE: encryption type, see Shishi_etype.

     Determine if key in ticket (really EncKDCRepPart) is of specified
     key type (really encryption type).

     *Return value:* Returns non-0 iff key in ticket is of specified
     encryption type.

shishi_tkt_lastreqc
-------------------

 -- Function: time_t shishi_tkt_lastreqc (Shishi_tkt * TKT,
          Shishi_lrtype LRTYPE)
     TKT: input variable with ticket info.

     LRTYPE: lastreq type to extract, see Shishi_lrtype.  E.g.,
     SHISHI_LRTYPE_LAST_REQUEST.

     Extract C time corresponding to given lastreq type field in the
     ticket.

     *Return value:* Returns C time interpretation of the specified
     lastreq field, or (time_t) -1.

shishi_tkt_authctime
--------------------

 -- Function: time_t shishi_tkt_authctime (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Extract C time corresponding to the authtime field.  The field
     holds the time when the original authentication took place that
     later resulted in this ticket.

     *Return value:* Returns C time interpretation of the endtime in
     ticket.

shishi_tkt_startctime
---------------------

 -- Function: time_t shishi_tkt_startctime (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Extract C time corresponding to the starttime field.  The field
     holds the time where the ticket start to be valid (typically in the
     past).

     *Return value:* Returns C time interpretation of the endtime in
     ticket.

shishi_tkt_endctime
-------------------

 -- Function: time_t shishi_tkt_endctime (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Extract C time corresponding to the endtime field.  The field holds
     the time where the ticket stop being valid.

     *Return value:* Returns C time interpretation of the endtime in
     ticket.

shishi_tkt_renew_tillc
----------------------

 -- Function: time_t shishi_tkt_renew_tillc (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Extract C time corresponding to the renew-till field.  The field
     holds the time where the ticket stop being valid for renewal.

     *Return value:* Returns C time interpretation of the renew-till in
     ticket.

shishi_tkt_valid_at_time_p
--------------------------

 -- Function: int shishi_tkt_valid_at_time_p (Shishi_tkt * TKT, time_t
          NOW)
     TKT: input variable with ticket info.

     NOW: time to check for.

     Determine if ticket is valid at a specific point in time.

     *Return value:* Returns non-0 iff ticket is valid (not expired and
     after starttime) at specified time.

shishi_tkt_valid_now_p
----------------------

 -- Function: int shishi_tkt_valid_now_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket is valid now.

     *Return value:* Returns 0 iff ticket is invalid (expired or not yet
     valid).

shishi_tkt_expired_p
--------------------

 -- Function: int shishi_tkt_expired_p (Shishi_tkt * TKT)
     TKT: input variable with ticket info.

     Determine if ticket has expired (i.e., endtime is in the past).

     *Return value:* Returns 0 iff ticket has expired.

shishi_tkt_lastreq_pretty_print
-------------------------------

 -- Function: void shishi_tkt_lastreq_pretty_print (Shishi_tkt * TKT,
          FILE * FH)
     TKT: input variable with ticket info.

     FH: file handle open for writing.

     Print a human readable representation of the various lastreq fields
     in the ticket (really EncKDCRepPart).

shishi_tkt_pretty_print
-----------------------

 -- Function: void shishi_tkt_pretty_print (Shishi_tkt * TKT, FILE * FH)
     TKT: input variable with ticket info.

     FH: file handle open for writing.

     Print a human readable representation of a ticket to file handle.


File: shishi.info,  Node: AS Functions,  Next: TGS Functions,  Prev: Ticket Functions,  Up: Programming Manual

5.7 AS Functions
================

The Authentication Service (AS) is used to get an initial ticket using
e.g. your password.  The following illustrates the AS-REQ and AS-REP
ASN.1 structures.

-- Request --

AS-REQ		::= KDC-REQ {10}

KDC-REQ {INTEGER:tagnum}	::= [APPLICATION tagnum] SEQUENCE {
	pvno		[1] INTEGER (5) -- first tag is [1], not [0] --,
	msg-type	[2] INTEGER (tagnum),
	padata		[3] SEQUENCE OF PA-DATA OPTIONAL,
	req-body	[4] KDC-REQ-BODY
}

KDC-REQ-BODY	::= SEQUENCE {
	kdc-options		[0] KDCOptions,
	cname			[1] PrincipalName OPTIONAL
				    -- Used only in AS-REQ --,
	realm			[2] Realm
				    -- Server's realm
				    -- Also client's in AS-REQ --,
	sname			[3] PrincipalName OPTIONAL,
	from			[4] KerberosTime OPTIONAL,
	till			[5] KerberosTime,
	rtime			[6] KerberosTime OPTIONAL,
	nonce			[7] UInt32,
	etype			[8] SEQUENCE OF Int32 -- EncryptionType
				    -- in preference order --,
	addresses		[9] HostAddresses OPTIONAL,
	enc-authorization-data	[10] EncryptedData {
					AuthorizationData,
					{ keyuse-TGSReqAuthData-sesskey
					  | keyuse-TGSReqAuthData-subkey }
				     } OPTIONAL,
	additional-tickets	[11] SEQUENCE OF Ticket OPTIONAL
}

-- Reply --

AS-REP		::= KDC-REP {11, EncASRepPart, {keyuse-EncASRepPart}}

KDC-REP {INTEGER:tagnum,
	 TypeToEncrypt,
	 UInt32:KeyUsages}	::= [APPLICATION tagnum] SEQUENCE {
	pvno		[0] INTEGER (5),
	msg-type	[1] INTEGER (tagnum),
	padata		[2] SEQUENCE OF PA-DATA OPTIONAL,
	crealm		[3] Realm,
	cname		[4] PrincipalName,
	ticket		[5] Ticket,
	enc-part	[6] EncryptedData {TypeToEncrypt, KeyUsages}
}

EncASRepPart	::= [APPLICATION 25] EncKDCRepPart

EncKDCRepPart	::= SEQUENCE {
	key		[0] EncryptionKey,
	last-req	[1] LastReq,
	nonce		[2] UInt32,
	key-expiration	[3] KerberosTime OPTIONAL,
	flags		[4] TicketFlags,
	authtime	[5] KerberosTime,
	starttime	[6] KerberosTime OPTIONAL,
	endtime		[7] KerberosTime,
	renew-till	[8] KerberosTime OPTIONAL,
	srealm		[9] Realm,
	sname		[10] PrincipalName,
	caddr		[11] HostAddresses OPTIONAL
}

shishi_as
---------

 -- Function: int shishi_as (Shishi * HANDLE, Shishi_as ** AS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AS: holds pointer to newly allocate Shishi_as structure.

     Allocate a new AS exchange variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_as_done
--------------

 -- Function: void shishi_as_done (Shishi_as * AS)
     AS: structure that holds information about AS exchange

     Deallocate resources associated with AS exchange.  This should be
     called by the application when it no longer need to utilize the AS
     exchange handle.

shishi_as_req
-------------

 -- Function: Shishi_asn1 shishi_as_req (Shishi_as * AS)
     AS: structure that holds information about AS exchange

     Get ASN.1 AS-REQ structure from AS exchange.

     *Return value:* Returns the generated AS-REQ packet from the AS
     exchange, or NULL if not yet set or an error occured.

shishi_as_req_build
-------------------

 -- Function: int shishi_as_req_build (Shishi_as * AS)
     AS: structure that holds information about AS exchange

     Possibly remove unset fields (e.g., rtime).

     *Return value:* Returns SHISHI_OK iff successful.

shishi_as_req_set
-----------------

 -- Function: void shishi_as_req_set (Shishi_as * AS, Shishi_asn1 ASREQ)
     AS: structure that holds information about AS exchange

     ASREQ: asreq to store in AS.

     Set the AS-REQ in the AS exchange.

shishi_as_req_der
-----------------

 -- Function: int shishi_as_req_der (Shishi_as * AS, char ** OUT,
          size_t * OUTLEN)
     AS: structure that holds information about AS exchange

     OUT: output array with newly allocated DER encoding of AS-REQ.

     OUTLEN: length of output array with DER encoding of AS-REQ.

     DER encode AS-REQ.  `out' is allocated by this function, and it is
     the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_as_req_der_set
---------------------

 -- Function: int shishi_as_req_der_set (Shishi_as * AS, char * DER,
          size_t DERLEN)
     AS: structure that holds information about AS exchange

     DER: input array with DER encoded AP-REQ.

     DERLEN: length of input array with DER encoded AP-REQ.

     DER decode AS-REQ and set it AS exchange.  If decoding fails, the
     AS-REQ in the AS exchange remains.

     *Return value:* Returns SHISHI_OK.

shishi_as_rep
-------------

 -- Function: Shishi_asn1 shishi_as_rep (Shishi_as * AS)
     AS: structure that holds information about AS exchange

     Get ASN.1 AS-REP structure from AS exchange.

     *Return value:* Returns the received AS-REP packet from the AS
     exchange, or NULL if not yet set or an error occured.

shishi_as_rep_process
---------------------

 -- Function: int shishi_as_rep_process (Shishi_as * AS, Shishi_key *
          KEY, const char * PASSWORD)
     AS: structure that holds information about AS exchange

     KEY: user's key, used to encrypt the encrypted part of the AS-REP.

     PASSWORD: user's password, used if key is NULL.

     Process new AS-REP and set ticket.  The key is used to decrypt the
     AP-REP.  If both key and password is NULL, the user is queried for
     it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_as_rep_build
-------------------

 -- Function: int shishi_as_rep_build (Shishi_as * AS, Shishi_key * KEY)
     AS: structure that holds information about AS exchange

     KEY: user's key, used to encrypt the encrypted part of the AS-REP.

     Build AS-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_as_rep_der
-----------------

 -- Function: int shishi_as_rep_der (Shishi_as * AS, char ** OUT,
          size_t * OUTLEN)
     AS: structure that holds information about AS exchange

     OUT: output array with newly allocated DER encoding of AS-REP.

     OUTLEN: length of output array with DER encoding of AS-REP.

     DER encode AS-REP. `out' is allocated by this function, and it is
     the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_as_rep_set
-----------------

 -- Function: void shishi_as_rep_set (Shishi_as * AS, Shishi_asn1 ASREP)
     AS: structure that holds information about AS exchange

     ASREP: asrep to store in AS.

     Set the AS-REP in the AS exchange.

shishi_as_rep_der_set
---------------------

 -- Function: int shishi_as_rep_der_set (Shishi_as * AS, char * DER,
          size_t DERLEN)
     AS: structure that holds information about AS exchange

     DER: input array with DER encoded AP-REP.

     DERLEN: length of input array with DER encoded AP-REP.

     DER decode AS-REP and set it AS exchange.  If decoding fails, the
     AS-REP in the AS exchange remains.

     *Return value:* Returns SHISHI_OK.

shishi_as_krberror
------------------

 -- Function: Shishi_asn1 shishi_as_krberror (Shishi_as * AS)
     AS: structure that holds information about AS exchange

     Get ASN.1 KRB-ERROR structure from AS exchange.

     *Return value:* Returns the received KRB-ERROR packet from the AS
     exchange, or NULL if not yet set or an error occured.

shishi_as_krberror_der
----------------------

 -- Function: int shishi_as_krberror_der (Shishi_as * AS, char ** OUT,
          size_t * OUTLEN)
     AS: structure that holds information about AS exchange

     OUT: output array with newly allocated DER encoding of KRB-ERROR.

     OUTLEN: length of output array with DER encoding of KRB-ERROR.

     DER encode KRB-ERROR. `out' is allocated by this function, and it
     is the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_as_krberror_set
----------------------

 -- Function: void shishi_as_krberror_set (Shishi_as * AS, Shishi_asn1
          KRBERROR)
     AS: structure that holds information about AS exchange

     KRBERROR: krberror to store in AS.

     Set the KRB-ERROR in the AS exchange.

shishi_as_tkt
-------------

 -- Function: Shishi_tkt * shishi_as_tkt (Shishi_as * AS)
     AS: structure that holds information about AS exchange

     Get Ticket in AS exchange.

     *Return value:* Returns the newly aquired tkt from the AS
     exchange, or NULL if not yet set or an error occured.

shishi_as_tkt_set
-----------------

 -- Function: void shishi_as_tkt_set (Shishi_as * AS, Shishi_tkt * TKT)
     AS: structure that holds information about AS exchange

     TKT: tkt to store in AS.

     Set the Tkt in the AS exchange.

shishi_as_sendrecv_hint
-----------------------

 -- Function: int shishi_as_sendrecv_hint (Shishi_as * AS,
          Shishi_tkts_hint * HINT)
     AS: structure that holds information about AS exchange

     HINT: additional parameters that modify connection behaviour, or
     `NULL'.

     Send AS-REQ and receive AS-REP or KRB-ERROR.  This is the initial
     authentication, usually used to acquire a Ticket Granting Ticket.
     The `hint' structure can be used to set, e.g., parameters for TLS
     authentication.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_as_sendrecv
------------------

 -- Function: int shishi_as_sendrecv (Shishi_as * AS)
     AS: structure that holds information about AS exchange

     Send AS-REQ and receive AS-REP or KRB-ERROR.  This is the initial
     authentication, usually used to acquire a Ticket Granting Ticket.

     *Return value:* Returns SHISHI_OK iff successful.


File: shishi.info,  Node: TGS Functions,  Next: Ticket (ASN.1) Functions,  Prev: AS Functions,  Up: Programming Manual

5.8 TGS Functions
=================

The Ticket Granting Service (TGS) is used to get subsequent tickets,
authenticated by other tickets (so called ticket granting tickets).
The following illustrates the TGS-REQ and TGS-REP ASN.1 structures.

-- Request --

TGS-REQ		::= KDC-REQ {12}

KDC-REQ {INTEGER:tagnum}	::= [APPLICATION tagnum] SEQUENCE {
	pvno		[1] INTEGER (5) -- first tag is [1], not [0] --,
	msg-type	[2] INTEGER (tagnum),
	padata		[3] SEQUENCE OF PA-DATA OPTIONAL,
	req-body	[4] KDC-REQ-BODY
}

KDC-REQ-BODY	::= SEQUENCE {
	kdc-options		[0] KDCOptions,
	cname			[1] PrincipalName OPTIONAL
				    -- Used only in AS-REQ --,
	realm			[2] Realm
				    -- Server's realm
				    -- Also client's in AS-REQ --,
	sname			[3] PrincipalName OPTIONAL,
	from			[4] KerberosTime OPTIONAL,
	till			[5] KerberosTime,
	rtime			[6] KerberosTime OPTIONAL,
	nonce			[7] UInt32,
	etype			[8] SEQUENCE OF Int32 -- EncryptionType
				    -- in preference order --,
	addresses		[9] HostAddresses OPTIONAL,
	enc-authorization-data	[10] EncryptedData {
					AuthorizationData,
					{ keyuse-TGSReqAuthData-sesskey
					  | keyuse-TGSReqAuthData-subkey }
				     } OPTIONAL,
	additional-tickets	[11] SEQUENCE OF Ticket OPTIONAL
}

-- Reply --

TGS-REP		::= KDC-REP {13, EncTGSRepPart,
			{ keyuse-EncTGSRepPart-sesskey
			  | keyuse-EncTGSRepPart-subkey }}

KDC-REP {INTEGER:tagnum,
	 TypeToEncrypt,
	 UInt32:KeyUsages}	::= [APPLICATION tagnum] SEQUENCE {
	pvno		[0] INTEGER (5),
	msg-type	[1] INTEGER (tagnum),
	padata		[2] SEQUENCE OF PA-DATA OPTIONAL,
	crealm		[3] Realm,
	cname		[4] PrincipalName,
	ticket		[5] Ticket,
	enc-part	[6] EncryptedData {TypeToEncrypt, KeyUsages}
}

EncTGSRepPart	::= [APPLICATION 26] EncKDCRepPart

EncKDCRepPart	::= SEQUENCE {
	key		[0] EncryptionKey,
	last-req	[1] LastReq,
	nonce		[2] UInt32,
	key-expiration	[3] KerberosTime OPTIONAL,
	flags		[4] TicketFlags,
	authtime	[5] KerberosTime,
	starttime	[6] KerberosTime OPTIONAL,
	endtime		[7] KerberosTime,
	renew-till	[8] KerberosTime OPTIONAL,
	srealm		[9] Realm,
	sname		[10] PrincipalName,
	caddr		[11] HostAddresses OPTIONAL
}

shishi_tgs
----------

 -- Function: int shishi_tgs (Shishi * HANDLE, Shishi_tgs ** TGS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TGS: holds pointer to newly allocate Shishi_tgs structure.

     Allocate a new TGS exchange variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_done
---------------

 -- Function: void shishi_tgs_done (Shishi_tgs * TGS)
     TGS: structure that holds information about AS exchange

     Deallocate resources associated with TGS exchange.  This should be
     called by the application when it no longer need to utilize the TGS
     exchange handle.

shishi_tgs_tgtkt
----------------

 -- Function: Shishi_tkt * shishi_tgs_tgtkt (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Get Ticket-granting-ticket from TGS exchange.

     *Return value:* Returns the ticket-granting-ticket used in the TGS
     exchange, or NULL if not yet set or an error occured.

shishi_tgs_tgtkt_set
--------------------

 -- Function: void shishi_tgs_tgtkt_set (Shishi_tgs * TGS, Shishi_tkt *
          TGTKT)
     TGS: structure that holds information about TGS exchange

     TGTKT: ticket granting ticket to store in TGS.

     Set the Ticket in the TGS exchange.

shishi_tgs_ap
-------------

 -- Function: Shishi_ap * shishi_tgs_ap (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Get the AP from TGS exchange.

     *Return value:* Returns the AP exchange (part of TGS-REQ) from the
     TGS exchange, or NULL if not yet set or an error occured.

shishi_tgs_req
--------------

 -- Function: Shishi_asn1 shishi_tgs_req (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Get the TGS-REQ from TGS exchange.

     *Return value:* Returns the generated TGS-REQ from the TGS
     exchange, or NULL if not yet set or an error occured.

shishi_tgs_req_set
------------------

 -- Function: void shishi_tgs_req_set (Shishi_tgs * TGS, Shishi_asn1
          TGSREQ)
     TGS: structure that holds information about TGS exchange

     TGSREQ: tgsreq to store in TGS.

     Set the TGS-REQ in the TGS exchange.

shishi_tgs_req_der
------------------

 -- Function: int shishi_tgs_req_der (Shishi_tgs * TGS, char ** OUT,
          size_t * OUTLEN)
     TGS: structure that holds information about TGS exchange

     OUT: output array with newly allocated DER encoding of TGS-REQ.

     OUTLEN: length of output array with DER encoding of TGS-REQ.

     DER encode TGS-REQ. `out' is allocated by this function, and it is
     the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_req_der_set
----------------------

 -- Function: int shishi_tgs_req_der_set (Shishi_tgs * TGS, char * DER,
          size_t DERLEN)
     TGS: structure that holds information about TGS exchange

     DER: input array with DER encoded AP-REQ.

     DERLEN: length of input array with DER encoded AP-REQ.

     DER decode TGS-REQ and set it TGS exchange.  If decoding fails, the
     TGS-REQ in the TGS exchange remains.

     *Return value:* Returns SHISHI_OK.

shishi_tgs_req_process
----------------------

 -- Function: int shishi_tgs_req_process (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Process new TGS-REQ and set ticket.  The key to decrypt the TGS-REQ
     is taken from the EncKDCReqPart of the TGS tgticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_req_build
--------------------

 -- Function: int shishi_tgs_req_build (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Checksum data in authenticator and add ticket and authenticator to
     TGS-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_rep
--------------

 -- Function: Shishi_asn1 shishi_tgs_rep (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Get TGS-REP from TGS exchange.

     *Return value:* Returns the received TGS-REP from the TGS exchange,
     or NULL if not yet set or an error occured.

shishi_tgs_rep_der
------------------

 -- Function: int shishi_tgs_rep_der (Shishi_tgs * TGS, char ** OUT,
          size_t * OUTLEN)
     TGS: structure that holds information about TGS exchange

     OUT: output array with newly allocated DER encoding of TGS-REP.

     OUTLEN: length of output array with DER encoding of TGS-REP.

     DER encode TGS-REP. `out' is allocated by this function, and it is
     the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_rep_process
----------------------

 -- Function: int shishi_tgs_rep_process (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Process new TGS-REP and set ticket.  The key to decrypt the TGS-REP
     is taken from the EncKDCRepPart of the TGS tgticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_rep_build
--------------------

 -- Function: int shishi_tgs_rep_build (Shishi_tgs * TGS, int KEYUSAGE,
          Shishi_key * KEY)
     TGS: structure that holds information about TGS exchange

     KEYUSAGE: keyusage integer.

     KEY: user's key, used to encrypt the encrypted part of the TGS-REP.

     Build TGS-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_krberror
-------------------

 -- Function: Shishi_asn1 shishi_tgs_krberror (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Get KRB-ERROR from TGS exchange.

     *Return value:* Returns the received TGS-REP from the TGS exchange,
     or NULL if not yet set or an error occured.

shishi_tgs_krberror_der
-----------------------

 -- Function: int shishi_tgs_krberror_der (Shishi_tgs * TGS, char **
          OUT, size_t * OUTLEN)
     TGS: structure that holds information about TGS exchange

     OUT: output array with newly allocated DER encoding of KRB-ERROR.

     OUTLEN: length of output array with DER encoding of KRB-ERROR.

     DER encode KRB-ERROR.  `out' is allocated by this function, and it
     is the responsibility of caller to deallocate it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_krberror_set
-----------------------

 -- Function: void shishi_tgs_krberror_set (Shishi_tgs * TGS,
          Shishi_asn1 KRBERROR)
     TGS: structure that holds information about TGS exchange

     KRBERROR: krberror to store in TGS.

     Set the KRB-ERROR in the TGS exchange.

shishi_tgs_tkt
--------------

 -- Function: Shishi_tkt * shishi_tgs_tkt (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Get Ticket from TGS exchange.

     *Return value:* Returns the newly aquired ticket from the TGS
     exchange, or NULL if not yet set or an error occured.

shishi_tgs_tkt_set
------------------

 -- Function: void shishi_tgs_tkt_set (Shishi_tgs * TGS, Shishi_tkt *
          TKT)
     TGS: structure that holds information about TGS exchange

     TKT: ticket to store in TGS.

     Set the Ticket in the TGS exchange.

shishi_tgs_sendrecv_hint
------------------------

 -- Function: int shishi_tgs_sendrecv_hint (Shishi_tgs * TGS,
          Shishi_tkts_hint * HINT)
     TGS: structure that holds information about TGS exchange

     HINT: additional parameters that modify connection behaviour, or
     `NULL'.

     Send TGS-REQ and receive TGS-REP or KRB-ERROR.  This is the
     subsequent authentication, usually used to acquire server tickets.
     The `hint' structure can be used to set, e.g., parameters for TLS
     authentication.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_sendrecv
-------------------

 -- Function: int shishi_tgs_sendrecv (Shishi_tgs * TGS)
     TGS: structure that holds information about TGS exchange

     Send TGS-REQ and receive TGS-REP or KRB-ERROR.  This is the
     subsequent authentication, usually used to acquire server tickets.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_set_server
---------------------

 -- Function: int shishi_tgs_set_server (Shishi_tgs * TGS, const char *
          SERVER)
     TGS: structure that holds information about TGS exchange

     SERVER: indicates the server to acquire ticket for.

     Set the server in the TGS-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_set_realm
--------------------

 -- Function: int shishi_tgs_set_realm (Shishi_tgs * TGS, const char *
          REALM)
     TGS: structure that holds information about TGS exchange

     REALM: indicates the realm to acquire ticket for.

     Set the server in the TGS-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_tgs_set_realmserver
--------------------------

 -- Function: int shishi_tgs_set_realmserver (Shishi_tgs * TGS, const
          char * REALM, const char * SERVER)
     TGS: structure that holds information about TGS exchange

     REALM: indicates the realm to acquire ticket for.

     SERVER: indicates the server to acquire ticket for.

     Set the realm and server in the TGS-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

