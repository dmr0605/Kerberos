This is shishi.info, produced by makeinfo version 4.13 from shishi.texi.

This manual is last updated 4 March 2009 for version 0.0.39 of Shishi.

   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Simon
Josefsson.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

INFO-DIR-SECTION GNU utilities
START-INFO-DIR-ENTRY
* shishi: (shishi).		A Kerberos 5 implementation
END-INFO-DIR-ENTRY

INFO-DIR-SECTION GNU Libraries
START-INFO-DIR-ENTRY
* libshishi: (shishi).		Library implementing Kerberos 5.
END-INFO-DIR-ENTRY


File: shishi.info,  Node: Ticket (ASN.1) Functions,  Next: AS/TGS Functions,  Prev: TGS Functions,  Up: Programming Manual

5.9 Ticket (ASN.1) Functions
============================

*Note Ticket Functions::, for an high-level overview of tickets.  The
following illustrates the Ticket and EncTicketPart ASN.1 structures.

Ticket          ::= [APPLICATION 1] SEQUENCE {
        tkt-vno         [0] INTEGER (5),
        realm           [1] Realm,
        sname           [2] PrincipalName,
        enc-part        [3] EncryptedData -- EncTicketPart
}

-- Encrypted part of ticket
EncTicketPart   ::= [APPLICATION 3] SEQUENCE {
        flags                   [0] TicketFlags,
        key                     [1] EncryptionKey,
        crealm                  [2] Realm,
        cname                   [3] PrincipalName,
        transited               [4] TransitedEncoding,
        authtime                [5] KerberosTime,
        starttime               [6] KerberosTime OPTIONAL,
        endtime                 [7] KerberosTime,
        renew-till              [8] KerberosTime OPTIONAL,
        caddr                   [9] HostAddresses OPTIONAL,
        authorization-data      [10] AuthorizationData OPTIONAL
}

shishi_ticket
-------------

 -- Function: Shishi_asn1 shishi_ticket (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new ASN.1 Ticket, populated with some
     default values.

     *Return value:* Returns the ticket or NULL on failure.

shishi_ticket_realm_get
-----------------------

 -- Function: int shishi_ticket_realm_get (Shishi * HANDLE, Shishi_asn1
          TICKET, char ** REALM, size_t * REALMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TICKET: input variable with ticket info.

     REALM: output array with newly allocated name of realm in ticket.

     REALMLEN: size of output array.

     Extract realm from ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ticket_realm_set
-----------------------

 -- Function: int shishi_ticket_realm_set (Shishi * HANDLE, Shishi_asn1
          TICKET, const char * REALM)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TICKET: input variable with ticket info.

     REALM: input array with name of realm.

     Set the realm field in the Ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ticket_server
--------------------

 -- Function: int shishi_ticket_server (Shishi * HANDLE, Shishi_asn1
          TICKET, char ** SERVER, size_t * SERVERLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     TICKET: ASN.1 Ticket variable to get server name from.

     SERVER: pointer to newly allocated zero terminated string
     containing principal name.  May be `NULL' (to only populate
     `serverlen').

     SERVERLEN: pointer to length of `server' on output, excluding
     terminating zero.  May be `NULL' (to only populate `server').

     Represent server principal name in Ticket as zero-terminated
     string.  The string is allocate by this function, and it is the
     responsibility of the caller to deallocate it.  Note that the
     output length `serverlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ticket_sname_set
-----------------------

 -- Function: int shishi_ticket_sname_set (Shishi * HANDLE, Shishi_asn1
          TICKET, Shishi_name_type NAME_TYPE, char * [] SNAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TICKET: Ticket variable to set server name field in.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     SNAME: input array with principal name.

     Set the server name field in the Ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ticket_get_enc_part_etype
--------------------------------

 -- Function: int shishi_ticket_get_enc_part_etype (Shishi * HANDLE,
          Shishi_asn1 TICKET, int32_t * ETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TICKET: Ticket variable to get value from.

     ETYPE: output variable that holds the value.

     Extract Ticket.enc-part.etype.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ticket_set_enc_part
--------------------------

 -- Function: int shishi_ticket_set_enc_part (Shishi * HANDLE,
          Shishi_asn1 TICKET, int32_t ETYPE, uint32_t KVNO, const char
          * BUF, size_t BUFLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TICKET: Ticket to add enc-part field to.

     ETYPE: encryption type used to encrypt enc-part.

     KVNO: key version number.

     BUF: input array with encrypted enc-part.

     BUFLEN: size of input array with encrypted enc-part.

     Set the encrypted enc-part field in the Ticket.  The encrypted data
     is usually created by calling `shishi_encrypt()' on the DER encoded
     enc-part.  To save time, you may want to use
     `shishi_ticket_add_enc_part()' instead, which calculates the
     encrypted data and calls this function in one step.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ticket_add_enc_part
--------------------------

 -- Function: int shishi_ticket_add_enc_part (Shishi * HANDLE,
          Shishi_asn1 TICKET, Shishi_key * KEY, Shishi_asn1
          ENCTICKETPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TICKET: Ticket to add enc-part field to.

     KEY: key used to encrypt enc-part.

     ENCTICKETPART: EncTicketPart to add.

     Encrypts DER encoded EncTicketPart using key and stores it in the
     Ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encticketpart_get_key
----------------------------

 -- Function: int shishi_encticketpart_get_key (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, Shishi_key ** KEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCTICKETPART: input EncTicketPart variable.

     KEY: newly allocated key.

     Extract the session key in the Ticket.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_encticketpart_key_set
----------------------------

 -- Function: int shishi_encticketpart_key_set (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, Shishi_key * KEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCTICKETPART: input EncTicketPart variable.

     KEY: key handle with information to store in encticketpart.

     Set the EncTicketPart.key field to key type and value of supplied
     key.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_encticketpart_flags_set
------------------------------

 -- Function: int shishi_encticketpart_flags_set (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, int FLAGS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCTICKETPART: input EncTicketPart variable.

     FLAGS: flags to set in encticketpart.

     Set the EncTicketPart.flags to supplied value.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_encticketpart_crealm_set
-------------------------------

 -- Function: int shishi_encticketpart_crealm_set (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, const char * REALM)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCTICKETPART: input EncTicketPart variable.

     REALM: input array with name of realm.

     Set the realm field in the KDC-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encticketpart_cname_set
------------------------------

 -- Function: int shishi_encticketpart_cname_set (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, Shishi_name_type NAME_TYPE, const
          char * PRINCIPAL)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCTICKETPART: input EncTicketPart variable.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     PRINCIPAL: input array with principal name.

     Set the client name field in the EncTicketPart.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encticketpart_transited_set
----------------------------------

 -- Function: int shishi_encticketpart_transited_set (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, int32_t TRTYPE, const char *
          TRDATA, size_t TRDATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCTICKETPART: input EncTicketPart variable.

     TRTYPE: transitedencoding type, e.g.
     SHISHI_TR_DOMAIN_X500_COMPRESS.

     TRDATA: actual transited realm data.

     TRDATALEN: length of actual transited realm data.

     Set the EncTicketPart.transited field to supplied value.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_encticketpart_authtime_set
---------------------------------

 -- Function: int shishi_encticketpart_authtime_set (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, const char * AUTHTIME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCTICKETPART: input EncTicketPart variable.

     AUTHTIME: character buffer containing a generalized time string.

     Set the EncTicketPart.authtime to supplied value.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_encticketpart_endtime_set
--------------------------------

 -- Function: int shishi_encticketpart_endtime_set (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, const char * ENDTIME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCTICKETPART: input EncTicketPart variable.

     ENDTIME: character buffer containing a generalized time string.

     Set the EncTicketPart.endtime to supplied value.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_encticketpart_client
---------------------------

 -- Function: int shishi_encticketpart_client (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, char ** CLIENT, size_t * CLIENTLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     ENCTICKETPART: EncTicketPart variable to get client name from.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name.  May be `NULL' (to only populate
     `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Represent client principal name in EncTicketPart as zero-terminated
     string.  The string is allocate by this function, and it is the
     responsibility of the caller to deallocate it.  Note that the
     output length `clientlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_encticketpart_clientrealm
--------------------------------

 -- Function: int shishi_encticketpart_clientrealm (Shishi * HANDLE,
          Shishi_asn1 ENCTICKETPART, char ** CLIENT, size_t * CLIENTLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     ENCTICKETPART: EncTicketPart variable to get client name and realm
     from.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name and realm.  May be `NULL' (to only
     populate `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Convert cname and realm fields from EncTicketPart to printable
     principal name format.  The string is allocate by this function,
     and it is the responsibility of the caller to deallocate it.  Note
     that the output length `clientlen' does not include the terminating
     zero.

     *Return value:* Returns SHISHI_OK iff successful.


File: shishi.info,  Node: AS/TGS Functions,  Next: Authenticator Functions,  Prev: Ticket (ASN.1) Functions,  Up: Programming Manual

5.10 AS/TGS Functions
=====================

The Authentication Service (AS) is used to get an initial ticket using
e.g. your password.  The Ticket Granting Service (TGS) is used to get
subsequent tickets using other tickets.  Protocol wise the procedures
are very similar, which is the reason they are described together.  The
following illustrates the AS-REQ, TGS-REQ and AS-REP, TGS-REP ASN.1
structures.  Most of the functions use the mnemonic "KDC" instead of
either AS or TGS, which means the function operates on both AS and TGS
types.  Only where the distinction between AS and TGS is important are
the AS and TGS names used.  Remember, these are low-level functions,
and normal applications will likely be satisfied with the AS (*note AS
Functions::) and TGS (*note TGS Functions::) interfaces, or the even
more high-level Ticket Set (*note Ticket Set Functions::) interface.

-- Request --

AS-REQ		::= KDC-REQ {10}
TGS-REQ		::= KDC-REQ {12}

KDC-REQ {INTEGER:tagnum}	::= [APPLICATION tagnum] SEQUENCE {
	pvno		[1] INTEGER (5) -- first tag is [1], not [0] --,
	msg-type	[2] INTEGER (tagnum),
	padata		[3] SEQUENCE OF PA-DATA OPTIONAL,
	req-body	[4] KDC-REQ-BODY
}

KDC-REQ-BODY	::= SEQUENCE {
	kdc-options		[0] KDCOptions,
	cname			[1] PrincipalName OPTIONAL
				    -- Used only in AS-REQ --,
	realm			[2] Realm
				    -- Server's realm
				    -- Also client's in AS-REQ --,
	sname			[3] PrincipalName OPTIONAL,
	from			[4] KerberosTime OPTIONAL,
	till			[5] KerberosTime,
	rtime			[6] KerberosTime OPTIONAL,
	nonce			[7] UInt32,
	etype			[8] SEQUENCE OF Int32 -- EncryptionType
				    -- in preference order --,
	addresses		[9] HostAddresses OPTIONAL,
	enc-authorization-data	[10] EncryptedData {
					AuthorizationData,
					{ keyuse-TGSReqAuthData-sesskey
					  | keyuse-TGSReqAuthData-subkey }
				     } OPTIONAL,
	additional-tickets	[11] SEQUENCE OF Ticket OPTIONAL
}

-- Reply --

AS-REP		::= KDC-REP {11, EncASRepPart, {keyuse-EncASRepPart}}
TGS-REP		::= KDC-REP {13, EncTGSRepPart,
			{ keyuse-EncTGSRepPart-sesskey
			  | keyuse-EncTGSRepPart-subkey }}

KDC-REP {INTEGER:tagnum,
	 TypeToEncrypt,
	 UInt32:KeyUsages}	::= [APPLICATION tagnum] SEQUENCE {
	pvno		[0] INTEGER (5),
	msg-type	[1] INTEGER (tagnum),
	padata		[2] SEQUENCE OF PA-DATA OPTIONAL,
	crealm		[3] Realm,
	cname		[4] PrincipalName,
	ticket		[5] Ticket,
	enc-part	[6] EncryptedData {TypeToEncrypt, KeyUsages}
}

EncASRepPart	::= [APPLICATION 25] EncKDCRepPart
EncTGSRepPart	::= [APPLICATION 26] EncKDCRepPart

EncKDCRepPart	::= SEQUENCE {
	key		[0] EncryptionKey,
	last-req	[1] LastReq,
	nonce		[2] UInt32,
	key-expiration	[3] KerberosTime OPTIONAL,
	flags		[4] TicketFlags,
	authtime	[5] KerberosTime,
	starttime	[6] KerberosTime OPTIONAL,
	endtime		[7] KerberosTime,
	renew-till	[8] KerberosTime OPTIONAL,
	srealm		[9] Realm,
	sname		[10] PrincipalName,
	caddr		[11] HostAddresses OPTIONAL
}

shishi_as_derive_salt
---------------------

 -- Function: int shishi_as_derive_salt (Shishi * HANDLE, Shishi_asn1
          ASREQ, Shishi_asn1 ASREP, char ** SALT, size_t * SALTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ASREQ: input AS-REQ variable.

     ASREP: input AS-REP variable.

     SALT: newly allocated output array with salt.

     SALTLEN: holds actual size of output array with salt.

     Derive the salt that should be used when deriving a key via
     `shishi_string_to_key()' for an AS exchange.  Currently this
     searches for PA-DATA of type SHISHI_PA_PW_SALT in the AS-REP and
     returns it if found, otherwise the salt is derived from the client
     name and realm in AS-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdc_copy_crealm
----------------------

 -- Function: int shishi_kdc_copy_crealm (Shishi * HANDLE, Shishi_asn1
          KDCREP, Shishi_asn1 ENCTICKETPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REP to read crealm from.

     ENCTICKETPART: EncTicketPart to set crealm in.

     Set crealm in KDC-REP to value in EncTicketPart.

     *Return value:* Returns SHISHI_OK if successful.

shishi_as_check_crealm
----------------------

 -- Function: int shishi_as_check_crealm (Shishi * HANDLE, Shishi_asn1
          ASREQ, Shishi_asn1 ASREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ASREQ: AS-REQ to compare realm field in.

     ASREP: AS-REP to compare realm field in.

     Verify that AS-REQ.req-body.realm and AS-REP.crealm fields matches.
     This is one of the steps that has to be performed when processing a
     AS-REQ and AS-REP exchange, see `shishi_kdc_process()'.

     *Return value:* Returns SHISHI_OK if successful,
     SHISHI_REALM_MISMATCH if the values differ, or an error code.

shishi_kdc_copy_cname
---------------------

 -- Function: int shishi_kdc_copy_cname (Shishi * HANDLE, Shishi_asn1
          KDCREP, Shishi_asn1 ENCTICKETPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REQ to read cname from.

     ENCTICKETPART: EncTicketPart to set cname in.

     Set cname in KDC-REP to value in EncTicketPart.

     *Return value:* Returns SHISHI_OK if successful.

shishi_as_check_cname
---------------------

 -- Function: int shishi_as_check_cname (Shishi * HANDLE, Shishi_asn1
          ASREQ, Shishi_asn1 ASREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ASREQ: AS-REQ to compare client name field in.

     ASREP: AS-REP to compare client name field in.

     Verify that AS-REQ.req-body.realm and AS-REP.crealm fields matches.
     This is one of the steps that has to be performed when processing a
     AS-REQ and AS-REP exchange, see `shishi_kdc_process()'.

     *Return value:* Returns SHISHI_OK if successful,
     SHISHI_CNAME_MISMATCH if the values differ, or an error code.

shishi_kdc_copy_nonce
---------------------

 -- Function: int shishi_kdc_copy_nonce (Shishi * HANDLE, Shishi_asn1
          KDCREQ, Shishi_asn1 ENCKDCREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to read nonce from.

     ENCKDCREPPART: EncKDCRepPart to set nonce in.

     Set nonce in EncKDCRepPart to value in KDC-REQ.

     *Return value:* Returns SHISHI_OK if successful.

shishi_kdc_check_nonce
----------------------

 -- Function: int shishi_kdc_check_nonce (Shishi * HANDLE, Shishi_asn1
          KDCREQ, Shishi_asn1 ENCKDCREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to compare nonce field in.

     ENCKDCREPPART: Encrypted KDC-REP part to compare nonce field in.

     Verify that KDC-REQ.req-body.nonce and EncKDCRepPart.nonce fields
     matches.  This is one of the steps that has to be performed when
     processing a KDC-REQ and KDC-REP exchange.

     *Return value:* Returns SHISHI_OK if successful,
     SHISHI_NONCE_LENGTH_MISMATCH if the nonces have different lengths
     (usually indicates that buggy server truncated nonce to 4 bytes),
     SHISHI_NONCE_MISMATCH if the values differ, or an error code.

shishi_tgs_process
------------------

 -- Function: int shishi_tgs_process (Shishi * HANDLE, Shishi_asn1
          TGSREQ, Shishi_asn1 TGSREP, Shishi_asn1 AUTHENTICATOR,
          Shishi_asn1 OLDENCKDCREPPART, Shishi_asn1 * ENCKDCREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TGSREQ: input variable that holds the sent KDC-REQ.

     TGSREP: input variable that holds the received KDC-REP.

     AUTHENTICATOR: input variable with Authenticator from AP-REQ in
     KDC-REQ.

     OLDENCKDCREPPART: input variable with EncKDCRepPart used in
     request.

     ENCKDCREPPART: output variable that holds new EncKDCRepPart.

     Process a TGS client exchange and output decrypted EncKDCRepPart
     which holds details for the new ticket received.  This function
     simply derives the encryption key from the ticket used to construct
     the TGS request and calls `shishi_kdc_process()', which see.

     *Return value:* Returns SHISHI_OK iff the TGS client exchange was
     successful.

shishi_as_process
-----------------

 -- Function: int shishi_as_process (Shishi * HANDLE, Shishi_asn1
          ASREQ, Shishi_asn1 ASREP, const char * STRING, Shishi_asn1 *
          ENCKDCREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ASREQ: input variable that holds the sent KDC-REQ.

     ASREP: input variable that holds the received KDC-REP.

     STRING: input variable with zero terminated password.

     ENCKDCREPPART: output variable that holds new EncKDCRepPart.

     Process an AS client exchange and output decrypted EncKDCRepPart
     which holds details for the new ticket received.  This function
     simply derives the encryption key from the password and calls
     `shishi_kdc_process()', which see.

     *Return value:* Returns SHISHI_OK iff the AS client exchange was
     successful.

shishi_kdc_process
------------------

 -- Function: int shishi_kdc_process (Shishi * HANDLE, Shishi_asn1
          KDCREQ, Shishi_asn1 KDCREP, Shishi_key * KEY, int KEYUSAGE,
          Shishi_asn1 * ENCKDCREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: input variable that holds the sent KDC-REQ.

     KDCREP: input variable that holds the received KDC-REP.

     KEY: input array with key to decrypt encrypted part of KDC-REP
     with.

     KEYUSAGE: kereros key usage value.

     ENCKDCREPPART: output variable that holds new EncKDCRepPart.

     Process a KDC client exchange and output decrypted EncKDCRepPart
     which holds details for the new ticket received.  Use
     `shishi_kdcrep_get_ticket()' to extract the ticket.  This function
     verifies the various conditions that must hold if the response is
     to be considered valid, specifically it compares nonces
     (`shishi_check_nonces()') and if the exchange was a AS exchange, it
     also compares cname and crealm (`shishi_check_cname()' and
     `shishi_check_crealm()').

     Usually the `shishi_as_process()' and `shishi_tgs_process()'
     functions should be used instead, since they simplify the
     decryption key computation.

     *Return value:* Returns SHISHI_OK iff the KDC client exchange was
     successful.

shishi_asreq
------------

 -- Function: Shishi_asn1 shishi_asreq (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new AS-REQ, populated with some default
     values.

     *Return value:* Returns the AS-REQ or NULL on failure.

shishi_tgsreq
-------------

 -- Function: Shishi_asn1 shishi_tgsreq (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new TGS-REQ, populated with some default
     values.

     *Return value:* Returns the TGS-REQ or NULL on failure.

shishi_kdcreq_print
-------------------

 -- Function: int shishi_kdcreq_print (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     KDCREQ: KDC-REQ to print.

     Print ASCII armored DER encoding of KDC-REQ to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_save
------------------

 -- Function: int shishi_kdcreq_save (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     KDCREQ: KDC-REQ to save.

     Print DER encoding of KDC-REQ to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_to_file
---------------------

 -- Function: int shishi_kdcreq_to_file (Shishi * HANDLE, Shishi_asn1
          KDCREQ, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write KDC-REQ to file in specified TYPE.  The file will be
     truncated if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_parse
-------------------

 -- Function: int shishi_kdcreq_parse (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     KDCREQ: output variable with newly allocated KDC-REQ.

     Read ASCII armored DER encoded KDC-REQ from file and populate given
     variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_read
------------------

 -- Function: int shishi_kdcreq_read (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     KDCREQ: output variable with newly allocated KDC-REQ.

     Read DER encoded KDC-REQ from file and populate given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_from_file
-----------------------

 -- Function: int shishi_kdcreq_from_file (Shishi * HANDLE, Shishi_asn1
          * KDCREQ, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: output variable with newly allocated KDC-REQ.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read KDC-REQ from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_nonce_set
-----------------------

 -- Function: int shishi_kdcreq_nonce_set (Shishi * HANDLE, Shishi_asn1
          KDCREQ, uint32_t NONCE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to set client name field in.

     NONCE: integer nonce to store in KDC-REQ.

     Store nonce number field in KDC-REQ.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_kdcreq_set_cname
-----------------------

 -- Function: int shishi_kdcreq_set_cname (Shishi * HANDLE, Shishi_asn1
          KDCREQ, Shishi_name_type NAME_TYPE, const char * PRINCIPAL)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to set client name field in.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     PRINCIPAL: input array with principal name.

     Set the client name field in the KDC-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_client
--------------------

 -- Function: int shishi_kdcreq_client (Shishi * HANDLE, Shishi_asn1
          KDCREQ, char ** CLIENT, size_t * CLIENTLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get client name from.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name.  May be `NULL' (to only populate
     `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Represent client principal name in KDC-REQ as zero-terminated
     string.  The string is allocate by this function, and it is the
     responsibility of the caller to deallocate it.  Note that the
     output length `clientlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_asreq_clientrealm
------------------------

 -- Function: int shishi_asreq_clientrealm (Shishi * HANDLE,
          Shishi_asn1 ASREQ, char ** CLIENT, size_t * CLIENTLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     ASREQ: AS-REQ variable to get client name and realm from.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name and realm.  May be `NULL' (to only
     populate `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Convert cname and realm fields from AS-REQ to printable principal
     name format.  The string is allocate by this function, and it is
     the responsibility of the caller to deallocate it.  Note that the
     output length `clientlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_realm
-------------------

 -- Function: int shishi_kdcreq_realm (Shishi * HANDLE, Shishi_asn1
          KDCREQ, char ** REALM, size_t * REALMLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get client name from.

     REALM: pointer to newly allocated zero terminated string containing
     realm.  May be `NULL' (to only populate `realmlen').

     REALMLEN: pointer to length of `realm' on output, excluding
     terminating zero.  May be `NULL' (to only populate `realmlen').

     Get realm field in KDC-REQ as zero-terminated string.  The string
     is allocate by this function, and it is the responsibility of the
     caller to deallocate it.  Note that the output length `realmlen'
     does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_set_realm
-----------------------

 -- Function: int shishi_kdcreq_set_realm (Shishi * HANDLE, Shishi_asn1
          KDCREQ, const char * REALM)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to set realm field in.

     REALM: input array with name of realm.

     Set the realm field in the KDC-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_server
--------------------

 -- Function: int shishi_kdcreq_server (Shishi * HANDLE, Shishi_asn1
          KDCREQ, char ** SERVER, size_t * SERVERLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get server name from.

     SERVER: pointer to newly allocated zero terminated string
     containing principal name.  May be `NULL' (to only populate
     `serverlen').

     SERVERLEN: pointer to length of `server' on output, excluding
     terminating zero.  May be `NULL' (to only populate `server').

     Represent server principal name in KDC-REQ as zero-terminated
     string.  The string is allocate by this function, and it is the
     responsibility of the caller to deallocate it.  Note that the
     output length `serverlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_set_sname
-----------------------

 -- Function: int shishi_kdcreq_set_sname (Shishi * HANDLE, Shishi_asn1
          KDCREQ, Shishi_name_type NAME_TYPE, const char * [] SNAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to set server name field in.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     SNAME: input array with principal name.

     Set the server name field in the KDC-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_till
------------------

 -- Function: int shishi_kdcreq_till (Shishi * HANDLE, Shishi_asn1
          KDCREQ, char ** TILL, size_t * TILLLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get client name from.

     TILL: pointer to newly allocated zero terminated string containing
     "till" field with generalized time.  May be `NULL' (to only
     populate `realmlen').

     TILLLEN: pointer to length of `till' on output, excluding
     terminating zero.  May be `NULL' (to only populate `tilllen').

     Get "till" field (i.e. "endtime") in KDC-REQ, as zero-terminated
     string.  The string is typically 15 characters long.  The string is
     allocated by this function, and it is the responsibility of the
     caller to deallocate it.  Note that the output length `realmlen'
     does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_tillc
-------------------

 -- Function: time_t shishi_kdcreq_tillc (Shishi * HANDLE, Shishi_asn1
          KDCREQ)
     HANDLE: Shishi library handle create by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get till field from.

     Extract C time corresponding to the "till" field.

     *Return value:* Returns C time interpretation of the "till" field
     in KDC-REQ.

shishi_kdcreq_etype
-------------------

 -- Function: int shishi_kdcreq_etype (Shishi * HANDLE, Shishi_asn1
          KDCREQ, int32_t * ETYPE, int NETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get etype field from.

     ETYPE: output encryption type.

     NETYPE: element number to return.

     *Return the netype:* th encryption type from KDC-REQ.  The first
     etype is number 1.

     *Return value:* Returns SHISHI_OK iff etype successful set.

shishi_kdcreq_set_etype
-----------------------

 -- Function: int shishi_kdcreq_set_etype (Shishi * HANDLE, Shishi_asn1
          KDCREQ, int32_t * ETYPE, int NETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to set etype field in.

     ETYPE: input array with encryption types.

     NETYPE: number of elements in input array with encryption types.

     Set the list of supported or wanted encryption types in the
     request.  The list should be sorted in priority order.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_options
---------------------

 -- Function: int shishi_kdcreq_options (Shishi * HANDLE, Shishi_asn1
          KDCREQ, uint32_t * FLAGS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     FLAGS: pointer to output integer with flags.

     Extract KDC-Options from KDC-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_forwardable_p
---------------------------

 -- Function: int shishi_kdcreq_forwardable_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option forwardable flag is set.

     The FORWARDABLE option indicates that the ticket to be issued is to
     have its forwardable flag set. It may only be set on the initial
     request, or in a subsequent request if the ticket-granting ticket
     on which it is based is also forwardable.

     *Return value:* Returns non-0 iff forwardable flag is set in
     KDC-REQ.

shishi_kdcreq_forwarded_p
-------------------------

 -- Function: int shishi_kdcreq_forwarded_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option forwarded flag is set.

     The FORWARDED option is only specified in a request to the
     ticket-granting server and will only be honored if the
     ticket-granting ticket in the request has its FORWARDABLE bit set.
     This option indicates that this is a request for forwarding. The
     address(es) of the host from which the resulting ticket is to be
     valid are included in the addresses field of the request.

     *Return value:* Returns non-0 iff forwarded flag is set in KDC-REQ.

shishi_kdcreq_proxiable_p
-------------------------

 -- Function: int shishi_kdcreq_proxiable_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option proxiable flag is set.

     The PROXIABLE option indicates that the ticket to be issued is to
     have its proxiable flag set. It may only be set on the initial
     request, or in a subsequent request if the ticket-granting ticket
     on which it is based is also proxiable.

     *Return value:* Returns non-0 iff proxiable flag is set in KDC-REQ.

shishi_kdcreq_proxy_p
---------------------

 -- Function: int shishi_kdcreq_proxy_p (Shishi * HANDLE, Shishi_asn1
          KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option proxy flag is set.

     The PROXY option indicates that this is a request for a proxy. This
     option will only be honored if the ticket-granting ticket in the
     request has its PROXIABLE bit set.  The address(es) of the host
     from which the resulting ticket is to be valid are included in the
     addresses field of the request.

     *Return value:* Returns non-0 iff proxy flag is set in KDC-REQ.

shishi_kdcreq_allow_postdate_p
------------------------------

 -- Function: int shishi_kdcreq_allow_postdate_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option allow-postdate flag is set.

     The ALLOW-POSTDATE option indicates that the ticket to be issued is
     to have its MAY-POSTDATE flag set. It may only be set on the
     initial request, or in a subsequent request if the ticket-granting
     ticket on which it is based also has its MAY-POSTDATE flag set.

     *Return value:* Returns non-0 iff allow-postdate flag is set in
     KDC-REQ.

shishi_kdcreq_postdated_p
-------------------------

 -- Function: int shishi_kdcreq_postdated_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option postdated flag is set.

     The POSTDATED option indicates that this is a request for a
     postdated ticket. This option will only be honored if the
     ticket-granting ticket on which it is based has its MAY-POSTDATE
     flag set. The resulting ticket will also have its INVALID flag set,
     and that flag may be reset by a subsequent request to the KDC after
     the starttime in the ticket has been reached.

     *Return value:* Returns non-0 iff postdated flag is set in KDC-REQ.

shishi_kdcreq_renewable_p
-------------------------

 -- Function: int shishi_kdcreq_renewable_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option renewable flag is set.

     The RENEWABLE option indicates that the ticket to be issued is to
     have its RENEWABLE flag set. It may only be set on the initial
     request, or when the ticket-granting ticket on which the request is
     based is also renewable. If this option is requested, then the
     rtime field in the request contains the desired absolute expiration
     time for the ticket.

     *Return value:* Returns non-0 iff renewable flag is set in KDC-REQ.

shishi_kdcreq_disable_transited_check_p
---------------------------------------

 -- Function: int shishi_kdcreq_disable_transited_check_p (Shishi *
          HANDLE, Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option disable-transited-check flag is set.

     By default the KDC will check the transited field of a
     ticket-granting-ticket against the policy of the local realm before
     it will issue derivative tickets based on the ticket-granting
     ticket. If this flag is set in the request, checking of the
     transited field is disabled. Tickets issued without the performance
     of this check will be noted by the reset (0) value of the
     TRANSITED-POLICY-CHECKED flag, indicating to the application server
     that the tranisted field must be checked locally. KDCs are
     encouraged but not required to honor the DISABLE-TRANSITED-CHECK
     option.

     This flag is new since RFC 1510

     *Return value:* Returns non-0 iff disable-transited-check flag is
     set in KDC-REQ.

shishi_kdcreq_renewable_ok_p
----------------------------

 -- Function: int shishi_kdcreq_renewable_ok_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option renewable-ok flag is set.

     The RENEWABLE-OK option indicates that a renewable ticket will be
     acceptable if a ticket with the requested life cannot otherwise be
     provided. If a ticket with the requested life cannot be provided,
     then a renewable ticket may be issued with a renew-till equal to
     the requested endtime. The value of the renew-till field may still
     be limited by local limits, or limits selected by the individual
     principal or server.

     *Return value:* Returns non-0 iff renewable-ok flag is set in
     KDC-REQ.

shishi_kdcreq_enc_tkt_in_skey_p
-------------------------------

 -- Function: int shishi_kdcreq_enc_tkt_in_skey_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option enc-tkt-in-skey flag is set.

     This option is used only by the ticket-granting service. The
     ENC-TKT-IN-SKEY option indicates that the ticket for the end server
     is to be encrypted in the session key from the additional
     ticket-granting ticket provided.

     *Return value:* Returns non-0 iff enc-tkt-in-skey flag is set in
     KDC-REQ.

shishi_kdcreq_renew_p
---------------------

 -- Function: int shishi_kdcreq_renew_p (Shishi * HANDLE, Shishi_asn1
          KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option renew flag is set.

     This option is used only by the ticket-granting service. The RENEW
     option indicates that the present request is for a renewal. The
     ticket provided is encrypted in the secret key for the server on
     which it is valid. This option will only be honored if the ticket
     to be renewed has its RENEWABLE flag set and if the time in its
     renew-till field has not passed. The ticket to be renewed is passed
     in the padata field as part of the authentication header.

     *Return value:* Returns non-0 iff renew flag is set in KDC-REQ.

shishi_kdcreq_validate_p
------------------------

 -- Function: int shishi_kdcreq_validate_p (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to get kdc-options field from.

     Determine if KDC-Option validate flag is set.

     This option is used only by the ticket-granting service. The
     VALIDATE option indicates that the request is to validate a
     postdated ticket. It will only be honored if the ticket presented
     is postdated, presently has its INVALID flag set, and would be
     otherwise usable at this time. A ticket cannot be validated before
     its starttime. The ticket presented for validation is encrypted in
     the key of the server for which it is valid and is passed in the
     padata field as part of the authentication header.

     *Return value:* Returns non-0 iff validate flag is set in KDC-REQ.

shishi_kdcreq_options_set
-------------------------

 -- Function: int shishi_kdcreq_options_set (Shishi * HANDLE,
          Shishi_asn1 KDCREQ, uint32_t OPTIONS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to set etype field in.

     OPTIONS: integer with flags to store in KDC-REQ.

     Set options in KDC-REQ.  Note that this reset any already existing
     flags.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_options_add
-------------------------

 -- Function: int shishi_kdcreq_options_add (Shishi * HANDLE,
          Shishi_asn1 KDCREQ, uint32_t OPTION)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ variable to set etype field in.

     OPTION: integer with options to add in KDC-REQ.

     Add KDC-Option to KDC-REQ.  This preserves all existing options.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_clear_padata
--------------------------

 -- Function: int shishi_kdcreq_clear_padata (Shishi * HANDLE,
          Shishi_asn1 KDCREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to remove PA-DATA from.

     Remove the padata field from KDC-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_get_padata
------------------------

 -- Function: int shishi_kdcreq_get_padata (Shishi * HANDLE,
          Shishi_asn1 KDCREQ, Shishi_padata_type PADATATYPE, char **
          OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to get PA-DATA from.

     PADATATYPE: type of PA-DATA, see Shishi_padata_type.

     OUT: output array with newly allocated PA-DATA value.

     OUTLEN: size of output array with PA-DATA value.

     Get pre authentication data (PA-DATA) from KDC-REQ.  Pre
     authentication data is used to pass various information to KDC,
     such as in case of a SHISHI_PA_TGS_REQ padatatype the AP-REQ that
     authenticates the user to get the ticket.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_get_padata_tgs
----------------------------

 -- Function: int shishi_kdcreq_get_padata_tgs (Shishi * HANDLE,
          Shishi_asn1 KDCREQ, Shishi_asn1 * APREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to get PA-TGS-REQ from.

     APREQ: Output variable with newly allocated AP-REQ.

     Extract TGS pre-authentication data from KDC-REQ.  The data is an
     AP-REQ that authenticates the request.  This function call
     `shishi_kdcreq_get_padata()' with a SHISHI_PA_TGS_REQ padatatype
     and DER decode the result (if any).

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_add_padata
------------------------

 -- Function: int shishi_kdcreq_add_padata (Shishi * HANDLE,
          Shishi_asn1 KDCREQ, int PADATATYPE, const char * DATA, size_t
          DATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to add PA-DATA to.

     PADATATYPE: type of PA-DATA, see Shishi_padata_type.

     DATA: input array with PA-DATA value.

     DATALEN: size of input array with PA-DATA value.

     Add new pre authentication data (PA-DATA) to KDC-REQ.  This is used
     to pass various information to KDC, such as in case of a
     SHISHI_PA_TGS_REQ padatatype the AP-REQ that authenticates the user
     to get the ticket.  (But also see `shishi_kdcreq_add_padata_tgs()'
     which takes an AP-REQ directly.)

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_add_padata_tgs
----------------------------

 -- Function: int shishi_kdcreq_add_padata_tgs (Shishi * HANDLE,
          Shishi_asn1 KDCREQ, Shishi_asn1 APREQ)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to add PA-DATA to.

     APREQ: AP-REQ to add as PA-DATA.

     Add TGS pre-authentication data to KDC-REQ.  The data is an AP-REQ
     that authenticates the request.  This functions simply DER encodes
     the AP-REQ and calls `shishi_kdcreq_add_padata()' with a
     SHISHI_PA_TGS_REQ padatatype.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcreq_add_padata_preauth
--------------------------------

 -- Function: int shishi_kdcreq_add_padata_preauth (Shishi * HANDLE,
          Shishi_asn1 KDCREQ, Shishi_key * KEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREQ: KDC-REQ to add pre-authentication data to.

     KEY: Key used to encrypt pre-auth data.

     Add pre-authentication data to KDC-REQ.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_asrep
------------

 -- Function: Shishi_asn1 shishi_asrep (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new AS-REP, populated with some default
     values.

     *Return value:* Returns the AS-REP or NULL on failure.

shishi_tgsrep
-------------

 -- Function: Shishi_asn1 shishi_tgsrep (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new TGS-REP, populated with some default
     values.

     *Return value:* Returns the TGS-REP or NULL on failure.

shishi_kdcrep_print
-------------------

 -- Function: int shishi_kdcrep_print (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 KDCREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     KDCREP: KDC-REP to print.

     Print ASCII armored DER encoding of KDC-REP to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_save
------------------

 -- Function: int shishi_kdcrep_save (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 KDCREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     KDCREP: KDC-REP to save.

     Print  DER encoding of KDC-REP to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_to_file
---------------------

 -- Function: int shishi_kdcrep_to_file (Shishi * HANDLE, Shishi_asn1
          KDCREP, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REP to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write KDC-REP to file in specified TYPE.  The file will be
     truncated if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_parse
-------------------

 -- Function: int shishi_kdcrep_parse (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * KDCREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     KDCREP: output variable with newly allocated KDC-REP.

     Read ASCII armored DER encoded KDC-REP from file and populate given
     variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_read
------------------

 -- Function: int shishi_kdcrep_read (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * KDCREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     KDCREP: output variable with newly allocated KDC-REP.

     Read DER encoded KDC-REP from file and populate given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_from_file
-----------------------

 -- Function: int shishi_kdcrep_from_file (Shishi * HANDLE, Shishi_asn1
          * KDCREP, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: output variable with newly allocated KDC-REP.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read KDC-REP from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_crealm_set
------------------------

 -- Function: int shishi_kdcrep_crealm_set (Shishi * HANDLE,
          Shishi_asn1 KDCREP, const char * CREALM)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: Kdcrep variable to set realm field in.

     CREALM: input array with name of realm.

     Set the client realm field in the KDC-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_cname_set
-----------------------

 -- Function: int shishi_kdcrep_cname_set (Shishi * HANDLE, Shishi_asn1
          KDCREP, Shishi_name_type NAME_TYPE, const char * [] CNAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: Kdcrep variable to set server name field in.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     CNAME: input array with principal name.

     Set the server name field in the KDC-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_client_set
------------------------

 -- Function: int shishi_kdcrep_client_set (Shishi * HANDLE,
          Shishi_asn1 KDCREP, const char * CLIENT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: Kdcrep variable to set server name field in.

     CLIENT: zero-terminated string with principal name on RFC 1964
     form.

     Set the client name field in the KDC-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_get_enc_part_etype
--------------------------------

 -- Function: int shishi_kdcrep_get_enc_part_etype (Shishi * HANDLE,
          Shishi_asn1 KDCREP, int32_t * ETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REP variable to get value from.

     ETYPE: output variable that holds the value.

     Extract KDC-REP.enc-part.etype.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_get_ticket
------------------------

 -- Function: int shishi_kdcrep_get_ticket (Shishi * HANDLE,
          Shishi_asn1 KDCREP, Shishi_asn1 * TICKET)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REP variable to get ticket from.

     TICKET: output variable to hold extracted ticket.

     Extract ticket from KDC-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_set_ticket
------------------------

 -- Function: int shishi_kdcrep_set_ticket (Shishi * HANDLE,
          Shishi_asn1 KDCREP, Shishi_asn1 TICKET)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REP to add ticket field to.

     TICKET: input ticket to copy into KDC-REP ticket field.

     Copy ticket into KDC-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_set_enc_part
--------------------------

 -- Function: int shishi_kdcrep_set_enc_part (Shishi * HANDLE,
          Shishi_asn1 KDCREP, int32_t ETYPE, uint32_t KVNO, const char
          * BUF, size_t BUFLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REP to add enc-part field to.

     ETYPE: encryption type used to encrypt enc-part.

     KVNO: key version number.

     BUF: input array with encrypted enc-part.

     BUFLEN: size of input array with encrypted enc-part.

     Set the encrypted enc-part field in the KDC-REP.  The encrypted
     data is usually created by calling `shishi_encrypt()' on the DER
     encoded enc-part.  To save time, you may want to use
     `shishi_kdcrep_add_enc_part()' instead, which calculates the
     encrypted data and calls this function in one step.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_add_enc_part
--------------------------

 -- Function: int shishi_kdcrep_add_enc_part (Shishi * HANDLE,
          Shishi_asn1 KDCREP, Shishi_key * KEY, int KEYUSAGE,
          Shishi_asn1 ENCKDCREPPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REP to add enc-part field to.

     KEY: key used to encrypt enc-part.

     KEYUSAGE: key usage to use, normally SHISHI_KEYUSAGE_ENCASREPPART,
     SHISHI_KEYUSAGE_ENCTGSREPPART_SESSION_KEY or
     SHISHI_KEYUSAGE_ENCTGSREPPART_AUTHENTICATOR_KEY.

     ENCKDCREPPART: EncKDCRepPart to add.

     Encrypts DER encoded EncKDCRepPart using key and stores it in the
     KDC-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_kdcrep_clear_padata
--------------------------

 -- Function: int shishi_kdcrep_clear_padata (Shishi * HANDLE,
          Shishi_asn1 KDCREP)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KDCREP: KDC-REP to remove PA-DATA from.

     Remove the padata field from KDC-REP.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_enckdcreppart_get_key
----------------------------

 -- Function: int shishi_enckdcreppart_get_key (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, Shishi_key ** KEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     KEY: newly allocated encryption key handle.

     Extract the key to use with the ticket sent in the KDC-REP
     associated with the EncKDCRepPart input variable.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_enckdcreppart_key_set
----------------------------

 -- Function: int shishi_enckdcreppart_key_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, Shishi_key * KEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     KEY: key handle with information to store in enckdcreppart.

     Set the EncKDCRepPart.key field to key type and value of supplied
     key.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_enckdcreppart_nonce_set
------------------------------

 -- Function: int shishi_enckdcreppart_nonce_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, uint32_t NONCE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     NONCE: nonce to set in EncKDCRepPart.

     Set the EncKDCRepPart.nonce field.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_enckdcreppart_flags_set
------------------------------

 -- Function: int shishi_enckdcreppart_flags_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, int FLAGS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     FLAGS: flags to set in EncKDCRepPart.

     Set the EncKDCRepPart.flags field.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_enckdcreppart_authtime_set
---------------------------------

 -- Function: int shishi_enckdcreppart_authtime_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, const char * AUTHTIME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     AUTHTIME: character buffer containing a generalized time string.

     Set the EncTicketPart.authtime to supplied value.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_enckdcreppart_starttime_set
----------------------------------

 -- Function: int shishi_enckdcreppart_starttime_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, const char * STARTTIME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     STARTTIME: character buffer containing a generalized time string.

     Set the EncTicketPart.starttime to supplied value.  Use a NULL
     value for `starttime' to remove the field.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_enckdcreppart_endtime_set
--------------------------------

 -- Function: int shishi_enckdcreppart_endtime_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, const char * ENDTIME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     ENDTIME: character buffer containing a generalized time string.

     Set the EncTicketPart.endtime to supplied value.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_enckdcreppart_renew_till_set
-----------------------------------

 -- Function: int shishi_enckdcreppart_renew_till_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, const char * RENEW_TILL)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     RENEW_TILL: character buffer containing a generalized time string.

     Set the EncTicketPart.renew-till to supplied value.  Use a NULL
     value for `renew_till' to remove the field.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_enckdcreppart_srealm_set
-------------------------------

 -- Function: int shishi_enckdcreppart_srealm_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, const char * SREALM)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: EncKDCRepPart variable to set realm field in.

     SREALM: input array with name of realm.

     Set the server realm field in the EncKDCRepPart.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_enckdcreppart_sname_set
------------------------------

 -- Function: int shishi_enckdcreppart_sname_set (Shishi * HANDLE,
          Shishi_asn1 ENCKDCREPPART, Shishi_name_type NAME_TYPE, char *
          [] SNAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: EncKDCRepPart variable to set server name field in.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     SNAME: input array with principal name.

     Set the server name field in the EncKDCRepPart.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_enckdcreppart_populate_encticketpart
-------------------------------------------

 -- Function: int shishi_enckdcreppart_populate_encticketpart (Shishi *
          HANDLE, Shishi_asn1 ENCKDCREPPART, Shishi_asn1 ENCTICKETPART)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ENCKDCREPPART: input EncKDCRepPart variable.

     ENCTICKETPART: input EncTicketPart variable.

     Set the flags, authtime, starttime, endtime, renew-till and caddr
     fields of the EncKDCRepPart to the corresponding values in the
     EncTicketPart.

     *Return value:* Returns SHISHI_OK iff succesful.


File: shishi.info,  Node: Authenticator Functions,  Next: KRB-ERROR Functions,  Prev: AS/TGS Functions,  Up: Programming Manual

5.11 Authenticator Functions
============================

An "Authenticator" is an ASN.1 structure that work as a proof that an
entity owns a ticket.  It is usually embedded in the AP-REQ structure
(*note AP-REQ and AP-REP Functions::), and you most likely want to use
an AP-REQ instead of a Authenticator in normal applications.  The
following illustrates the Authenticator ASN.1 structure.

Authenticator	::= [APPLICATION 2] SEQUENCE  {
	authenticator-vno	[0] INTEGER (5),
	crealm			[1] Realm,
	cname			[2] PrincipalName,
	cksum			[3] Checksum OPTIONAL,
	cusec			[4] Microseconds,
	ctime			[5] KerberosTime,
	subkey			[6] EncryptionKey OPTIONAL,
	seq-number		[7] UInt32 OPTIONAL,
	authorization-data	[8] AuthorizationData OPTIONAL
}

shishi_authenticator
--------------------

 -- Function: Shishi_asn1 shishi_authenticator (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new Authenticator, populated with some
     default values.  It uses the current time as returned by the system
     for the ctime and cusec fields.

     *Return value:* Returns the authenticator or NULL on failure.

shishi_authenticator_subkey
---------------------------

 -- Function: Shishi_asn1 shishi_authenticator_subkey (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new Authenticator, populated with some
     default values.  It uses the current time as returned by the system
     for the ctime and cusec fields. It adds a random subkey.

     *Return value:* Returns the authenticator or NULL on failure.

shishi_authenticator_print
--------------------------

 -- Function: int shishi_authenticator_print (Shishi * HANDLE, FILE *
          FH, Shishi_asn1 AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     Print ASCII armored DER encoding of authenticator to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_save
-------------------------

 -- Function: int shishi_authenticator_save (Shishi * HANDLE, FILE *
          FH, Shishi_asn1 AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     Save DER encoding of authenticator to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_to_file
----------------------------

 -- Function: int shishi_authenticator_to_file (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, int FILETYPE, const char *
          FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: Authenticator to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write Authenticator to file in specified TYPE.  The file will be
     truncated if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_parse
--------------------------

 -- Function: int shishi_authenticator_parse (Shishi * HANDLE, FILE *
          FH, Shishi_asn1 * AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     AUTHENTICATOR: output variable with newly allocated authenticator.

     Read ASCII armored DER encoded authenticator from file and populate
     given authenticator variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_read
-------------------------

 -- Function: int shishi_authenticator_read (Shishi * HANDLE, FILE *
          FH, Shishi_asn1 * AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     AUTHENTICATOR: output variable with newly allocated authenticator.

     Read DER encoded authenticator from file and populate given
     authenticator variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_from_file
------------------------------

 -- Function: int shishi_authenticator_from_file (Shishi * HANDLE,
          Shishi_asn1 * AUTHENTICATOR, int FILETYPE, const char *
          FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: output variable with newly allocated Authenticator.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read Authenticator from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_set_crealm
-------------------------------

 -- Function: int shishi_authenticator_set_crealm (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, const char * CREALM)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     CREALM: input array with realm.

     Set realm field in authenticator to specified value.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_set_cname
------------------------------

 -- Function: int shishi_authenticator_set_cname (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, Shishi_name_type NAME_TYPE, const
          char * [] CNAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     CNAME: input array with principal name.

     Set principal field in authenticator to specified value.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_client_set
-------------------------------

 -- Function: int shishi_authenticator_client_set (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, const char * CLIENT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: Authenticator to set client name field in.

     CLIENT: zero-terminated string with principal name on RFC 1964
     form.

     Set the client name field in the Authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_ctime
--------------------------

 -- Function: int shishi_authenticator_ctime (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, char ** T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: Authenticator as allocated by
     `shishi_authenticator()'.

     T: newly allocated zero-terminated character array with client
     time.

     Extract client time from Authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_ctime_set
------------------------------

 -- Function: int shishi_authenticator_ctime_set (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, const char * T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: Authenticator as allocated by
     `shishi_authenticator()'.

     T: string with generalized time value to store in Authenticator.

     Store client time in Authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_cusec_get
------------------------------

 -- Function: int shishi_authenticator_cusec_get (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, uint32_t * CUSEC)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: Authenticator as allocated by
     `shishi_authenticator()'.

     CUSEC: output integer with client microseconds field.

     Extract client microseconds field from Authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_cusec_set
------------------------------

 -- Function: int shishi_authenticator_cusec_set (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, uint32_t CUSEC)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     CUSEC: client microseconds to set in authenticator, 0-999999.

     Set the cusec field in the Authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_seqnumber_get
----------------------------------

 -- Function: int shishi_authenticator_seqnumber_get (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, uint32_t * SEQNUMBER)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     SEQNUMBER: output integer with sequence number field.

     Extract sequence number field from Authenticator.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_authenticator_seqnumber_remove
-------------------------------------

 -- Function: int shishi_authenticator_seqnumber_remove (Shishi *
          HANDLE, Shishi_asn1 AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     Remove sequence number field in Authenticator.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_authenticator_seqnumber_set
----------------------------------

 -- Function: int shishi_authenticator_seqnumber_set (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, uint32_t SEQNUMBER)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     SEQNUMBER: integer with sequence number field to store in
     Authenticator.

     Store sequence number field in Authenticator.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_authenticator_client
---------------------------

 -- Function: int shishi_authenticator_client (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, char ** CLIENT, size_t * CLIENTLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     AUTHENTICATOR: Authenticator variable to get client name from.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name.  May be `NULL' (to only populate
     `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Represent client principal name in Authenticator as zero-terminated
     string.  The string is allocate by this function, and it is the
     responsibility of the caller to deallocate it.  Note that the
     output length `clientlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_clientrealm
--------------------------------

 -- Function: int shishi_authenticator_clientrealm (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, char ** CLIENT, size_t * CLIENTLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     AUTHENTICATOR: Authenticator variable to get client name and realm
     from.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name and realm.  May be `NULL' (to only
     populate `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Convert cname and realm fields from Authenticator to printable
     principal name format.  The string is allocate by this function,
     and it is the responsibility of the caller to deallocate it.  Note
     that the output length `clientlen' does not include the terminating
     zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_cksum
--------------------------

 -- Function: int shishi_authenticator_cksum (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, int32_t * CKSUMTYPE, char **
          CKSUM, size_t * CKSUMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     CKSUMTYPE: output checksum type.

     CKSUM: newly allocated output checksum data from authenticator.

     CKSUMLEN: on output, actual size of allocated output checksum data
     buffer.

     Read checksum value from authenticator.  `cksum' is allocated by
     this function, and it is the responsibility of caller to deallocate
     it.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_set_cksum
------------------------------

 -- Function: int shishi_authenticator_set_cksum (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, int32_t CKSUMTYPE, char * CKSUM,
          size_t CKSUMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     CKSUMTYPE: input checksum type to store in authenticator.

     CKSUM: input checksum data to store in authenticator.

     CKSUMLEN: size of input checksum data to store in authenticator.

     Store checksum value in authenticator.  A checksum is usually
     created by calling `shishi_checksum()' on some application
     specific data using the key from the ticket that is being used.
     To save time, you may want to use
     `shishi_authenticator_add_cksum()' instead, which calculates the
     checksum and calls this function in one step.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_add_cksum
------------------------------

 -- Function: int shishi_authenticator_add_cksum (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, Shishi_key * KEY, int KEYUSAGE,
          char * DATA, size_t DATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     KEY: key to to use for encryption.

     KEYUSAGE: cryptographic key usage value to use in encryption.

     DATA: input array with data to calculate checksum on.

     DATALEN: size of input array with data to calculate checksum on.

     Calculate checksum for data and store it in the authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_add_cksum_type
-----------------------------------

 -- Function: int shishi_authenticator_add_cksum_type (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, Shishi_key * KEY, int KEYUSAGE,
          int CKSUMTYPE, char * DATA, size_t DATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     KEY: key to to use for encryption.

     KEYUSAGE: cryptographic key usage value to use in encryption.

     CKSUMTYPE: checksum to type to calculate checksum.

     DATA: input array with data to calculate checksum on.

     DATALEN: size of input array with data to calculate checksum on.

     Calculate checksum for data and store it in the authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_clear_authorizationdata
--------------------------------------------

 -- Function: int shishi_authenticator_clear_authorizationdata (Shishi
          * HANDLE, Shishi_asn1 AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: Authenticator as allocated by
     `shishi_authenticator()'.

     Remove the authorization-data field from Authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_add_authorizationdata
------------------------------------------

 -- Function: int shishi_authenticator_add_authorizationdata (Shishi *
          HANDLE, Shishi_asn1 AUTHENTICATOR, int32_t ADTYPE, const char
          * ADDATA, size_t ADDATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     ADTYPE: input authorization data type to add.

     ADDATA: input authorization data to add.

     ADDATALEN: size of input authorization data to add.

     Add authorization data to authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_authorizationdata
--------------------------------------

 -- Function: int shishi_authenticator_authorizationdata (Shishi *
          HANDLE, Shishi_asn1 AUTHENTICATOR, int32_t * ADTYPE, char **
          ADDATA, size_t * ADDATALEN, size_t NTH)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     ADTYPE: output authorization data type.

     ADDATA: newly allocated output authorization data.

     ADDATALEN: on output, actual size of newly allocated authorization
     data.

     NTH: element number of authorization-data to extract.

     *Extract n:* th authorization data from authenticator.  The first
     field is 1.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_remove_subkey
----------------------------------

 -- Function: int shishi_authenticator_remove_subkey (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     Remove subkey from the authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_get_subkey
-------------------------------

 -- Function: int shishi_authenticator_get_subkey (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, Shishi_key ** SUBKEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     SUBKEY: output newly allocated subkey from authenticator.

     Read subkey value from authenticator.

     *Return value:* Returns SHISHI_OK if successful or
     SHISHI_ASN1_NO_ELEMENT if subkey is not present.

shishi_authenticator_set_subkey
-------------------------------

 -- Function: int shishi_authenticator_set_subkey (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, int32_t SUBKEYTYPE, const char *
          SUBKEY, size_t SUBKEYLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     SUBKEYTYPE: input subkey type to store in authenticator.

     SUBKEY: input subkey data to store in authenticator.

     SUBKEYLEN: size of input subkey data to store in authenticator.

     Store subkey value in authenticator.  A subkey is usually created
     by calling `shishi_key_random()' using the default encryption type
     of the key from the ticket that is being used.  To save time, you
     may want to use `shishi_authenticator_add_subkey()' instead, which
     calculates the subkey and calls this function in one step.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_add_random_subkey
--------------------------------------

 -- Function: int shishi_authenticator_add_random_subkey (Shishi *
          HANDLE, Shishi_asn1 AUTHENTICATOR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     Generate random subkey, of the default encryption type from
     configuration, and store it in the authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_add_random_subkey_etype
--------------------------------------------

 -- Function: int shishi_authenticator_add_random_subkey_etype (Shishi
          * HANDLE, Shishi_asn1 AUTHENTICATOR, int ETYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     ETYPE: encryption type of random key to generate.

     Generate random subkey of indicated encryption type, and store it
     in the authenticator.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_authenticator_add_subkey
-------------------------------

 -- Function: int shishi_authenticator_add_subkey (Shishi * HANDLE,
          Shishi_asn1 AUTHENTICATOR, Shishi_key * SUBKEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     AUTHENTICATOR: authenticator as allocated by
     `shishi_authenticator()'.

     SUBKEY: subkey to add to authenticator.

     Store subkey in the authenticator.

     *Return value:* Returns SHISHI_OK iff successful.


File: shishi.info,  Node: KRB-ERROR Functions,  Next: Cryptographic Functions,  Prev: Authenticator Functions,  Up: Programming Manual

5.12 KRB-ERROR Functions
========================

The "KRB-ERROR" is an ASN.1 structure that can be returned, instead of,
e.g., KDC-REP or AP-REP, to indicate various error conditions.
Unfortunately, the semantics of several of the fields are ill
specified, so the typically procedure is to extract "e-text" and/or
"e-data" and show it to the user.  The following illustrates the
KRB-ERROR ASN.1 structure.

KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (30),
        ctime           [2] KerberosTime OPTIONAL,
        cusec           [3] Microseconds OPTIONAL,
        stime           [4] KerberosTime,
        susec           [5] Microseconds,
        error-code      [6] Int32,
        crealm          [7] Realm OPTIONAL,
        cname           [8] PrincipalName OPTIONAL,
        realm           [9] Realm -- service realm --,
        sname           [10] PrincipalName -- service name --,
        e-text          [11] KerberosString OPTIONAL,
        e-data          [12] OCTET STRING OPTIONAL
}

shishi_krberror
---------------

 -- Function: Shishi_asn1 shishi_krberror (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     This function creates a new KRB-ERROR, populated with some default
     values.

     *Return value:* Returns the KRB-ERROR or NULL on failure.

shishi_krberror_print
---------------------

 -- Function: int shishi_krberror_print (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     KRBERROR: KRB-ERROR to print.

     Print ASCII armored DER encoding of KRB-ERROR to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_save
--------------------

 -- Function: int shishi_krberror_save (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for writing.

     KRBERROR: KRB-ERROR to save.

     Save DER encoding of KRB-ERROR to file.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_to_file
-----------------------

 -- Function: int shishi_krberror_to_file (Shishi * HANDLE, Shishi_asn1
          KRBERROR, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: KRB-ERROR to save.

     FILETYPE: input variable specifying type of file to be written,
     see Shishi_filetype.

     FILENAME: input variable with filename to write to.

     Write KRB-ERROR to file in specified TYPE.  The file will be
     truncated if it exists.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_parse
---------------------

 -- Function: int shishi_krberror_parse (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     KRBERROR: output variable with newly allocated KRB-ERROR.

     Read ASCII armored DER encoded KRB-ERROR from file and populate
     given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_read
--------------------

 -- Function: int shishi_krberror_read (Shishi * HANDLE, FILE * FH,
          Shishi_asn1 * KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle open for reading.

     KRBERROR: output variable with newly allocated KRB-ERROR.

     Read DER encoded KRB-ERROR from file and populate given variable.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_from_file
-------------------------

 -- Function: int shishi_krberror_from_file (Shishi * HANDLE,
          Shishi_asn1 * KRBERROR, int FILETYPE, const char * FILENAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: output variable with newly allocated KRB-ERROR.

     FILETYPE: input variable specifying type of file to be read, see
     Shishi_filetype.

     FILENAME: input variable with filename to read from.

     Read KRB-ERROR from file in specified TYPE.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_build
---------------------

 -- Function: int shishi_krberror_build (Shishi * HANDLE, Shishi_asn1
          KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     Finish KRB-ERROR, called before e.g. shishi_krberror_der.  This
     function removes empty but OPTIONAL fields (such as cname), and

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_der
-------------------

 -- Function: int shishi_krberror_der (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     OUT: output array with newly allocated DER encoding of KRB-ERROR.

     OUTLEN: length of output array with DER encoding of KRB-ERROR.

     DER encode KRB-ERROR.  The caller must deallocate the OUT buffer.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_crealm
----------------------

 -- Function: int shishi_krberror_crealm (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** REALM, size_t * REALMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     REALM: output array with newly allocated name of realm in
     KRB-ERROR.

     REALMLEN: size of output array.

     Extract client realm from KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_remove_crealm
-----------------------------

 -- Function: int shishi_krberror_remove_crealm (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     Remove client realm field in KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_set_crealm
--------------------------

 -- Function: int shishi_krberror_set_crealm (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, const char * CREALM)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     CREALM: input array with realm.

     Set realm field in krberror to specified value.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_client
----------------------

 -- Function: int shishi_krberror_client (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** CLIENT, size_t * CLIENTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     CLIENT: pointer to newly allocated zero terminated string
     containing principal name.  May be `NULL' (to only populate
     `clientlen').

     CLIENTLEN: pointer to length of `client' on output, excluding
     terminating zero.  May be `NULL' (to only populate `client').

     Return client principal name in KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_set_cname
-------------------------

 -- Function: int shishi_krberror_set_cname (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, Shishi_name_type NAME_TYPE, const char
          * [] CNAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     CNAME: input array with principal name.

     Set principal field in krberror to specified value.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_remove_cname
----------------------------

 -- Function: int shishi_krberror_remove_cname (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     Remove client realm field in KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_client_set
--------------------------

 -- Function: int shishi_krberror_client_set (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, const char * CLIENT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror to set client name field in.

     CLIENT: zero-terminated string with principal name on RFC 1964
     form.

     Set the client name field in the Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_realm
---------------------

 -- Function: int shishi_krberror_realm (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** REALM, size_t * REALMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     REALM: output array with newly allocated name of realm in
     KRB-ERROR.

     REALMLEN: size of output array.

     Extract (server) realm from KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_set_realm
-------------------------

 -- Function: int shishi_krberror_set_realm (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, const char * REALM)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     REALM: input array with (server) realm.

     Set (server) realm field in krberror to specified value.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_server
----------------------

 -- Function: int shishi_krberror_server (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** SERVER, size_t * SERVERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     SERVER: pointer to newly allocated zero terminated string
     containing server name.  May be `NULL' (to only populate
     `serverlen').

     SERVERLEN: pointer to length of `server' on output, excluding
     terminating zero.  May be `NULL' (to only populate `server').

     Return server principal name in KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_remove_sname
----------------------------

 -- Function: int shishi_krberror_remove_sname (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror to set server name field in.

     Remove server name field in KRB-ERROR.  (Since it is not marked
     OPTIONAL in the ASN.1 profile, what is done is to set the name-type
     to UNKNOWN and make sure the name-string sequence is empty.)

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_set_sname
-------------------------

 -- Function: int shishi_krberror_set_sname (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, Shishi_name_type NAME_TYPE, const char
          * [] SNAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     SNAME: input array with principal name.

     Set principal field in krberror to specified value.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_server_set
--------------------------

 -- Function: int shishi_krberror_server_set (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, const char * SERVER)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror to set server name field in.

     SERVER: zero-terminated string with principal name on RFC 1964
     form.

     Set the server name field in the Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_ctime
---------------------

 -- Function: int shishi_krberror_ctime (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror to set client name field in.

     T: newly allocated zero-terminated output array with client time.

     Extract client time from KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_ctime_set
-------------------------

 -- Function: int shishi_krberror_ctime_set (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, const char * T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror as allocated by `shishi_krberror()'.

     T: string with generalized time value to store in Krberror.

     Store client time in Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_remove_ctime
----------------------------

 -- Function: int shishi_krberror_remove_ctime (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror as allocated by `shishi_krberror()'.

     Remove client time field in Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_cusec
---------------------

 -- Function: int shishi_krberror_cusec (Shishi * HANDLE, Shishi_asn1
          KRBERROR, uint32_t * CUSEC)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror as allocated by `shishi_krberror()'.

     CUSEC: output integer with client microseconds field.

     Extract client microseconds field from Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_cusec_set
-------------------------

 -- Function: int shishi_krberror_cusec_set (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, uint32_t CUSEC)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     CUSEC: client microseconds to set in krberror, 0-999999.

     Set the cusec field in the Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_remove_cusec
----------------------------

 -- Function: int shishi_krberror_remove_cusec (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror as allocated by `shishi_krberror()'.

     Remove client usec field in Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_stime
---------------------

 -- Function: int shishi_krberror_stime (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror to set client name field in.

     T: newly allocated zero-terminated output array with server time.

     Extract server time from KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_stime_set
-------------------------

 -- Function: int shishi_krberror_stime_set (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, const char * T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror as allocated by `shishi_krberror()'.

     T: string with generalized time value to store in Krberror.

     Store server time in Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_susec
---------------------

 -- Function: int shishi_krberror_susec (Shishi * HANDLE, Shishi_asn1
          KRBERROR, uint32_t * SUSEC)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: Krberror as allocated by `shishi_krberror()'.

     SUSEC: output integer with server microseconds field.

     Extract server microseconds field from Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_susec_set
-------------------------

 -- Function: int shishi_krberror_susec_set (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, uint32_t SUSEC)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     SUSEC: server microseconds to set in krberror, 0-999999.

     Set the susec field in the Krberror.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_errorcode
-------------------------

 -- Function: int shishi_krberror_errorcode (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, int32_t * ERRORCODE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: KRB-ERROR structure with error code.

     ERRORCODE: output integer KRB-ERROR error code.

     Extract error code from KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_errorcode_fast
------------------------------

 -- Function: int shishi_krberror_errorcode_fast (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: KRB-ERROR structure with error code.

     Get error code from KRB-ERROR, without error checking.

     *Return value:* Return error code (see
     `shishi_krberror_errorcode()') directly, or -1 on error.

shishi_krberror_errorcode_set
-----------------------------

 -- Function: int shishi_krberror_errorcode_set (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, int ERRORCODE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: KRB-ERROR structure with error code to set.

     ERRORCODE: new error code to set in krberror.

     Set the error-code field to a new error code.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_etext
---------------------

 -- Function: int shishi_krberror_etext (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** ETEXT, size_t * ETEXTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: KRB-ERROR structure with error code.

     ETEXT: output array with newly allocated error text.

     ETEXTLEN: output length of error text.

     Extract additional error text from server (possibly empty).

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_set_etext
-------------------------

 -- Function: int shishi_krberror_set_etext (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, const char * ETEXT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     ETEXT: input array with error text to set.

     Set error text (e-text) field in KRB-ERROR to specified value.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_remove_etext
----------------------------

 -- Function: int shishi_krberror_remove_etext (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     Remove error text (e-text) field in KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_edata
---------------------

 -- Function: int shishi_krberror_edata (Shishi * HANDLE, Shishi_asn1
          KRBERROR, char ** EDATA, size_t * EDATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: KRB-ERROR structure with error code.

     EDATA: output array with newly allocated error data.

     EDATALEN: output length of error data.

     Extract additional error data from server (possibly empty).

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_methoddata
--------------------------

 -- Function: int shishi_krberror_methoddata (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, Shishi_asn1 * METHODDATA)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: KRB-ERROR structure with error code.

     METHODDATA: output ASN.1 METHOD-DATA.

     Extract METHOD-DATA ASN.1 object from the e-data field.  The e-data
     field will only contain a METHOD-DATA if the krberror error code is
     `SHISHI_KDC_ERR_PREAUTH_REQUIRED'.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_set_edata
-------------------------

 -- Function: int shishi_krberror_set_edata (Shishi * HANDLE,
          Shishi_asn1 KRBERROR, const char * EDATA)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     EDATA: input array with error text to set.

     Set error text (e-data) field in KRB-ERROR to specified value.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_remove_edata
----------------------------

 -- Function: int shishi_krberror_remove_edata (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: krberror as allocated by `shishi_krberror()'.

     Remove error text (e-data) field in KRB-ERROR.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_pretty_print
----------------------------

 -- Function: int shishi_krberror_pretty_print (Shishi * HANDLE, FILE *
          FH, Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FH: file handle opened for writing.

     KRBERROR: KRB-ERROR structure with error code.

     Print KRB-ERROR error condition and some explanatory text to file
     descriptor.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_krberror_errorcode_message
---------------------------------

 -- Function: const char * shishi_krberror_errorcode_message (Shishi *
          HANDLE, int ERRORCODE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ERRORCODE: integer KRB-ERROR error code.

     Get human readable string describing KRB-ERROR code.

     *Return value:* Return a string describing error code.  This
     function will always return a string even if the error code isn't
     known.

shishi_krberror_message
-----------------------

 -- Function: const char * shishi_krberror_message (Shishi * HANDLE,
          Shishi_asn1 KRBERROR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KRBERROR: KRB-ERROR structure with error code.

     Extract error code (see `shishi_krberror_errorcode_fast()') and
     return error message (see `shishi_krberror_errorcode_message()').

     *Return value:* Return a string describing error code.  This
     function will always return a string even if the error code isn't
     known.


File: shishi.info,  Node: Cryptographic Functions,  Next: X.509 Functions,  Prev: KRB-ERROR Functions,  Up: Programming Manual

5.13 Cryptographic Functions
============================

Underneath the high-level functions described earlier, cryptographic
operations are happening.  If you need to access these cryptographic
primitives directly, this section describes the functions available.

   Most cryptographic operations need keying material, and cryptographic
keys have been isolated into it's own data structure `Shishi_key'.  The
following illustrates it's contents, but note that you cannot access
it's elements directly but must use the accessor functions described
below.

struct Shishi_key
{
  int type;    /* RFC 1510 encryption integer type */
  char *value; /* Cryptographic key data */
  int version; /* RFC 1510 ``kvno'' */
};

   All functions that operate on this data structure are described now.

shishi_key_principal
--------------------

 -- Function: const char * shishi_key_principal (const Shishi_key * KEY)
     KEY: structure that holds key information

     Get the principal part of the key owner principal name, i.e.,
     except the realm.

     *Return value:* Returns the principal owning the key.  (Not a copy
     of it, so don't modify or deallocate it.)

shishi_key_principal_set
------------------------

 -- Function: void shishi_key_principal_set (Shishi_key * KEY, const
          char * PRINCIPAL)
     KEY: structure that holds key information

     PRINCIPAL: string with new principal name.

     Set the principal owning the key. The string is copied into the
     key, so you can dispose of the variable immediately after calling
     this function.

shishi_key_realm
----------------

 -- Function: const char * shishi_key_realm (const Shishi_key * KEY)
     KEY: structure that holds key information

     Get the realm part of the key owner principal name.

     *Return value:* Returns the realm for the principal owning the key.
     (Not a copy of it, so don't modify or deallocate it.)

shishi_key_realm_set
--------------------

 -- Function: void shishi_key_realm_set (Shishi_key * KEY, const char *
          REALM)
     KEY: structure that holds key information

     REALM: string with new realm name.

     Set the realm for the principal owning the key. The string is
     copied into the key, so you can dispose of the variable immediately
     after calling this function.

shishi_key_type
---------------

 -- Function: int shishi_key_type (const Shishi_key * KEY)
     KEY: structure that holds key information

     Get key type.

     *Return value:* Returns the type of key as an integer as described
     in the standard.

shishi_key_type_set
-------------------

 -- Function: void shishi_key_type_set (Shishi_key * KEY, int32_t TYPE)
     KEY: structure that holds key information

     TYPE: type to set in key.

     Set the type of key in key structure.

shishi_key_value
----------------

 -- Function: const char * shishi_key_value (const Shishi_key * KEY)
     KEY: structure that holds key information

     Get the raw key bytes.

     *Return value:* Returns the key value as a pointer which is valid
     throughout the lifetime of the key structure.

shishi_key_value_set
--------------------

 -- Function: void shishi_key_value_set (Shishi_key * KEY, const char *
          VALUE)
     KEY: structure that holds key information

     VALUE: input array with key data.

     Set the key value and length in key structure.  The value is copied
     into the key (in other words, you can deallocate `value' right
     after calling this function without modifying the value inside the
     key).

shishi_key_version
------------------

 -- Function: uint32_t shishi_key_version (const Shishi_key * KEY)
     KEY: structure that holds key information

     Get the "kvno" (key version) of key.  It will be UINT32_MAX if the
     key is not long-lived.

     *Return value:* Returns the version of key ("kvno").

shishi_key_version_set
----------------------

 -- Function: void shishi_key_version_set (Shishi_key * KEY, uint32_t
          KVNO)
     KEY: structure that holds key information

     KVNO: new version integer.

     Set the version of key ("kvno") in key structure.  Use UINT32_MAX
     for non-ptermanent keys.

shishi_key_name
---------------

 -- Function: const char * shishi_key_name (Shishi_key * KEY)
     KEY: structure that holds key information

     Calls shishi_cipher_name for key type.

     *Return value:* Return name of key.

shishi_key_length
-----------------

 -- Function: size_t shishi_key_length (const Shishi_key * KEY)
     KEY: structure that holds key information

     Calls shishi_cipher_keylen for key type.

     *Return value:* Returns the length of the key value.

shishi_key
----------

 -- Function: int shishi_key (Shishi * HANDLE, Shishi_key ** KEY)
     HANDLE: Shishi library handle create by `shishi_init()'.

     KEY: pointer to structure that will hold newly created key
     information

     Create a new Key information structure.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_key_done
---------------

 -- Function: void shishi_key_done (Shishi_key * KEY)
     KEY: pointer to structure that holds key information.

     Deallocates key information structure.

shishi_key_copy
---------------

 -- Function: void shishi_key_copy (Shishi_key * DSTKEY, Shishi_key *
          SRCKEY)
     DSTKEY: structure that holds destination key information

     SRCKEY: structure that holds source key information

     Copies source key into existing allocated destination key.

shishi_key_from_value
---------------------

 -- Function: int shishi_key_from_value (Shishi * HANDLE, int32_t TYPE,
          const char * VALUE, Shishi_key ** KEY)
     HANDLE: Shishi library handle create by `shishi_init()'.

     TYPE: type of key.

     VALUE: input array with key value, or NULL.

     KEY: pointer to structure that will hold newly created key
     information

     Create a new Key information structure, and set the key type and
     key value. KEY contains a newly allocated structure only if this
     function is successful.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_key_from_base64
----------------------

 -- Function: int shishi_key_from_base64 (Shishi * HANDLE, int32_t
          TYPE, const char * VALUE, Shishi_key ** KEY)
     HANDLE: Shishi library handle create by `shishi_init()'.

     TYPE: type of key.

     VALUE: input string with base64 encoded key value, or NULL.

     KEY: pointer to structure that will hold newly created key
     information

     Create a new Key information structure, and set the key type and
     key value. KEY contains a newly allocated structure only if this
     function is successful.

     *Return value:* Returns SHISHI_INVALID_KEY if the base64 encoded
     key length doesn't match the key type, and SHISHI_OK on success.

shishi_key_random
-----------------

 -- Function: int shishi_key_random (Shishi * HANDLE, int32_t TYPE,
          Shishi_key ** KEY)
     HANDLE: Shishi library handle create by `shishi_init()'.

     TYPE: type of key.

     KEY: pointer to structure that will hold newly created key
     information

     Create a new Key information structure for the key type and some
     random data.  KEY contains a newly allocated structure only if this
     function is successful.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_key_from_random
----------------------

 -- Function: int shishi_key_from_random (Shishi * HANDLE, int32_t
          TYPE, const char * RND, size_t RNDLEN, Shishi_key ** OUTKEY)
     HANDLE: Shishi library handle create by `shishi_init()'.

     TYPE: type of key.

     RND: random data.

     RNDLEN: length of random data.

     OUTKEY: pointer to structure that will hold newly created key
     information

     Create a new Key information structure, and set the key type and
     key value using `shishi_random_to_key()'.  KEY contains a newly
     allocated structure only if this function is successful.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_key_from_string
----------------------

 -- Function: int shishi_key_from_string (Shishi * HANDLE, int32_t
          TYPE, const char * PASSWORD, size_t PASSWORDLEN, const char *
          SALT, size_t SALTLEN, const char * PARAMETER, Shishi_key **
          OUTKEY)
     HANDLE: Shishi library handle create by `shishi_init()'.

     TYPE: type of key.

     PASSWORD: input array containing password.

     PASSWORDLEN: length of input array containing password.

     SALT: input array containing salt.

     SALTLEN: length of input array containing salt.

     PARAMETER: input array with opaque encryption type specific
     information.

     OUTKEY: pointer to structure that will hold newly created key
     information

     Create a new Key information structure, and set the key type and
     key value using `shishi_string_to_key()'.  KEY contains a newly
     allocated structure only if this function is successful.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_key_from_name
--------------------

 -- Function: int shishi_key_from_name (Shishi * HANDLE, int32_t TYPE,
          const char * NAME, const char * PASSWORD, size_t PASSWORDLEN,
          const char * PARAMETER, Shishi_key ** OUTKEY)
     HANDLE: Shishi library handle create by `shishi_init()'.

     TYPE: type of key.

     NAME: principal name of user.

     PASSWORD: input array containing password.

     PASSWORDLEN: length of input array containing password.

     PARAMETER: input array with opaque encryption type specific
     information.

     OUTKEY: pointer to structure that will hold newly created key
     information

     Create a new Key information structure, and derive the key from
     principal name and password using `shishi_key_from_name()'.  The
     salt is derived from the principal name by concatenating the
     decoded realm and principal.

     *Return value:* Returns SHISHI_OK iff successful.

   Applications that run uninteractively may need keying material.  In
these cases, the keys are stored in a file, a file that is normally
stored on the local host.  The file should be protected from
unauthorized access.  The file is in ASCII format and contains keys as
outputed by `shishi_key_print'.  All functions that handle these keys
sets are described now.

shishi_keys
-----------

 -- Function: int shishi_keys (Shishi * HANDLE, Shishi_keys ** KEYS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEYS: output pointer to newly allocated keys handle.

     Get a new key set handle.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_keys_done
----------------

 -- Function: void shishi_keys_done (Shishi_keys ** KEYS)
     KEYS: key set handle as allocated by `shishi_keys()'.

     Deallocates all resources associated with key set.  The key set
     handle must not be used in calls to other shishi_keys_*() functions
     after this.

shishi_keys_size
----------------

 -- Function: int shishi_keys_size (Shishi_keys * KEYS)
     KEYS: key set handle as allocated by `shishi_keys()'.

     Get size of key set.

     *Return value:* Returns number of keys stored in key set.

shishi_keys_nth
---------------

 -- Function: const Shishi_key * shishi_keys_nth (Shishi_keys * KEYS,
          int KEYNO)
     KEYS: key set handle as allocated by `shishi_keys()'.

     KEYNO: integer indicating requested key in key set.

     *Get the n:* th ticket in key set.

     *Return value:* Returns a key handle to the keyno:th key in the key
     set, or NULL if `keys' is invalid or `keyno' is out of bounds.  The
     first key is `keyno' 0, the second key `keyno' 1, and so on.

shishi_keys_remove
------------------

 -- Function: void shishi_keys_remove (Shishi_keys * KEYS, int KEYNO)
     KEYS: key set handle as allocated by `shishi_keys()'.

     KEYNO: key number of key in the set to remove.  The first key is
     key number 0.

     Remove a key, indexed by `keyno', in given key set.

shishi_keys_add
---------------

 -- Function: int shishi_keys_add (Shishi_keys * KEYS, Shishi_key * KEY)
     KEYS: key set handle as allocated by `shishi_keys()'.

     KEY: key to be added to key set.

     Add a key to the key set.  A deep copy of the key is stored, so
     changing `key', or deallocating it, will not modify the value
     stored in the key set.

     *Return value:* Returns SHISHI_OK iff succesful.

shishi_keys_print
-----------------

 -- Function: int shishi_keys_print (Shishi_keys * KEYS, FILE * FH)
     KEYS: key set to print.

     FH: file handle, open for writing, to print keys to.

     Print all keys in set using shishi_key_print.

     *Returns:* Returns `SHISHI_OK' on success.

shishi_keys_to_file
-------------------

 -- Function: int shishi_keys_to_file (Shishi * HANDLE, const char *
          FILENAME, Shishi_keys * KEYS)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FILENAME: filename to append key to.

     KEYS: set of keys to print.

     Print an ASCII representation of a key structure to a file, for
     each key in the key set.  The file is appended to if it exists.
     See `shishi_key_print()' for the format of the output.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_keys_for_serverrealm_in_file
-----------------------------------

 -- Function: Shishi_key * shishi_keys_for_serverrealm_in_file (Shishi
          * HANDLE, const char * FILENAME, const char * SERVER, const
          char * REALM)
     HANDLE: Shishi library handle create by `shishi_init()'.

     FILENAME: file to read keys from.

     SERVER: server name to get key for.

     REALM: realm of server to get key for.

     Get keys that match specified `server' and `realm' from the key set
     file `filename'.

     *Return value:* Returns the key for specific server and realm, read
     from the indicated file, or NULL if no key could be found or an
     error encountered.

shishi_keys_for_server_in_file
------------------------------

 -- Function: Shishi_key * shishi_keys_for_server_in_file (Shishi *
          HANDLE, const char * FILENAME, const char * SERVER)
     HANDLE: Shishi library handle create by `shishi_init()'.

     FILENAME: file to read keys from.

     SERVER: server name to get key for.

     Get key for specified `server' from `filename'.

     *Return value:* Returns the key for specific server, read from the
     indicated file, or NULL if no key could be found or an error
     encountered.

shishi_keys_for_localservicerealm_in_file
-----------------------------------------

 -- Function: Shishi_key * shishi_keys_for_localservicerealm_in_file
          (Shishi * HANDLE, const char * FILENAME, const char *
          SERVICE, const char * REALM)
     HANDLE: Shishi library handle create by `shishi_init()'.

     FILENAME: file to read keys from.

     SERVICE: service to get key for.

     REALM: realm of server to get key for, or NULL for default realm.

     Get key for specified `service' and `realm' from `filename'.

     *Return value:* Returns the key for the server
     "SERVICE/HOSTNAME`REALM'" (where HOSTNAME is the current system's
     hostname), read from the default host keys file (see
     `shishi_hostkeys_default_file()'), or NULL if no key could be found
     or an error encountered.

   The previous functions require that the filename is known.  For some
applications, servers, it makes sense to provide a system default.
These key sets used by server applications are known as "hostkeys".
Here are the functions that operate on hostkeys (they are mostly
wrappers around generic key sets).

shishi_hostkeys_default_file
----------------------------

 -- Function: const char * shishi_hostkeys_default_file (Shishi *
          HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Get file name of default host key file.

     *Return value:* Returns the default host key filename used in the
     library.  (Not a copy of it, so don't modify or deallocate it.)

shishi_hostkeys_default_file_set
--------------------------------

 -- Function: void shishi_hostkeys_default_file_set (Shishi * HANDLE,
          const char * HOSTKEYSFILE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     HOSTKEYSFILE: string with new default hostkeys file name, or NULL
     to reset to default.

     Set the default host key filename used in the library.  The string
     is copied into the library, so you can dispose of the variable
     immediately after calling this function.

shishi_hostkeys_for_server
--------------------------

 -- Function: Shishi_key * shishi_hostkeys_for_server (Shishi * HANDLE,
          const char * SERVER)
     HANDLE: Shishi library handle create by `shishi_init()'.

     SERVER: server name to get key for

     Get host key for `server'.

     *Return value:* Returns the key for specific server, read from the
     default host keys file (see `shishi_hostkeys_default_file()'), or
     NULL if no key could be found or an error encountered.

shishi_hostkeys_for_serverrealm
-------------------------------

 -- Function: Shishi_key * shishi_hostkeys_for_serverrealm (Shishi *
          HANDLE, const char * SERVER, const char * REALM)
     HANDLE: Shishi library handle create by `shishi_init()'.

     SERVER: server name to get key for

     REALM: realm of server to get key for.

     Get host key for `server' in `realm'.

     *Return value:* Returns the key for specific server and realm, read
     from the default host keys file (see
     `shishi_hostkeys_default_file()'), or NULL if no key could be found
     or an error encountered.

shishi_hostkeys_for_localservicerealm
-------------------------------------

 -- Function: Shishi_key * shishi_hostkeys_for_localservicerealm
          (Shishi * HANDLE, const char * SERVICE, const char * REALM)
     HANDLE: Shishi library handle create by `shishi_init()'.

     SERVICE: service to get key for.

     REALM: realm of server to get key for, or NULL for default realm.

     Get host key for `service' on current host in `realm'.

     *Return value:* Returns the key for the server
     "SERVICE/HOSTNAME`REALM'" (where HOSTNAME is the current system's
     hostname), read from the default host keys file (see
     `shishi_hostkeys_default_file()'), or NULL if no key could be found
     or an error encountered.

shishi_hostkeys_for_localservice
--------------------------------

 -- Function: Shishi_key * shishi_hostkeys_for_localservice (Shishi *
          HANDLE, const char * SERVICE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     SERVICE: service to get key for.

     Get host key for `service' on current host in default realm.

     *Return value:* Returns the key for the server "SERVICE/HOSTNAME"
     (where HOSTNAME is the current system's hostname), read from the
     default host keys file (see `shishi_hostkeys_default_file()'), or
     NULL if no key could be found or an error encountered.

   After creating the key structure, it can be used to encrypt and
decrypt data, calculate checksum on data etc.  All available functions
are described now.

shishi_cipher_supported_p
-------------------------

 -- Function: int shishi_cipher_supported_p (int32_t TYPE)
     TYPE: encryption type, see Shishi_etype.

     Find out if cipher is supported.

     *Return value:* Return 0 iff cipher is unsupported.

shishi_cipher_name
------------------

 -- Function: const char * shishi_cipher_name (int32_t TYPE)
     TYPE: encryption type, see Shishi_etype.

     Read humanly readable string for cipher.

     *Return value:* Return name of encryption type, e.g.
     "des3-cbc-sha1-kd", as defined in the standards.

shishi_cipher_blocksize
-----------------------

 -- Function: int shishi_cipher_blocksize (int32_t TYPE)
     TYPE: encryption type, see Shishi_etype.

     Get block size for cipher.

     *Return value:* Return block size for encryption type, as defined
     in the standards.

shishi_cipher_confoundersize
----------------------------

 -- Function: int shishi_cipher_confoundersize (int32_t TYPE)
     TYPE: encryption type, see Shishi_etype.

     Get length of confounder for cipher.

     *Return value:* Returns the size of the confounder (random data)
     for encryption type, as defined in the standards, or (size_t)-1 on
     error (e.g., unsupported encryption type).

shishi_cipher_keylen
--------------------

 -- Function: size_t shishi_cipher_keylen (int32_t TYPE)
     TYPE: encryption type, see Shishi_etype.

     Get key length for cipher.

     *Return value:* Return length of key used for the encryption type,
     as defined in the standards.

shishi_cipher_randomlen
-----------------------

 -- Function: size_t shishi_cipher_randomlen (int32_t TYPE)
     TYPE: encryption type, see Shishi_etype.

     Get length of random data for cipher.

     *Return value:* Return length of random used for the encryption
     type, as defined in the standards, or (size_t)-1 on error (e.g.,
     unsupported encryption type).

shishi_cipher_defaultcksumtype
------------------------------

 -- Function: int shishi_cipher_defaultcksumtype (int32_t TYPE)
     TYPE: encryption type, see Shishi_etype.

     Get the default checksum associated with cipher.

     *Return value:* Return associated checksum mechanism for the
     encryption type, as defined in the standards.

shishi_cipher_parse
-------------------

 -- Function: int shishi_cipher_parse (const char * CIPHER)
     CIPHER: name of encryption type, e.g. "des3-cbc-sha1-kd".

     Get cipher number by parsing string.

     *Return value:* Return encryption type corresponding to a string.

shishi_checksum_supported_p
---------------------------

 -- Function: int shishi_checksum_supported_p (int32_t TYPE)
     TYPE: checksum type, see Shishi_cksumtype.

     Find out whether checksum is supported.

     *Return value:* Return 0 iff checksum is unsupported.

shishi_checksum_name
--------------------

 -- Function: const char * shishi_checksum_name (int32_t TYPE)
     TYPE: checksum type, see Shishi_cksumtype.

     Get name of checksum.

     *Return value:* Return name of checksum type, e.g.
     "hmac-sha1-96-aes256", as defined in the standards.

shishi_checksum_cksumlen
------------------------

 -- Function: size_t shishi_checksum_cksumlen (int32_t TYPE)
     TYPE: checksum type, see Shishi_cksumtype.

     Get length of checksum output.

     *Return value:* Return length of checksum used for the checksum
     type, as defined in the standards.

shishi_checksum_parse
---------------------

 -- Function: int shishi_checksum_parse (const char * CHECKSUM)
     CHECKSUM: name of checksum type, e.g. "hmac-sha1-96-aes256".

     Get checksum number by parsing a string.

     *Return value:* Return checksum type, see Shishi_cksumtype,
     corresponding to a string.

shishi_string_to_key
--------------------

 -- Function: int shishi_string_to_key (Shishi * HANDLE, int32_t
          KEYTYPE, const char * PASSWORD, size_t PASSWORDLEN, const
          char * SALT, size_t SALTLEN, const char * PARAMETER,
          Shishi_key * OUTKEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEYTYPE: cryptographic encryption type, see Shishi_etype.

     PASSWORD: input array with password.

     PASSWORDLEN: length of input array with password.

     SALT: input array with salt.

     SALTLEN: length of input array with salt.

     PARAMETER: input array with opaque encryption type specific
     information.

     OUTKEY: allocated key handle that will contain new key.

     Derive key from a string (password) and salt (commonly
     concatenation of realm and principal) for specified key type, and
     set the type and value in the given key to the computed values.
     The parameter value is specific for each keytype, and can be set if
     the parameter information is not available.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_random_to_key
--------------------

 -- Function: int shishi_random_to_key (Shishi * HANDLE, int32_t
          KEYTYPE, const char * RND, size_t RNDLEN, Shishi_key * OUTKEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEYTYPE: cryptographic encryption type, see Shishi_etype.

     RND: input array with random data.

     RNDLEN: length of input array with random data.

     OUTKEY: allocated key handle that will contain new key.

     Derive key from random data for specified key type, and set the
     type and value in the given key to the computed values.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_checksum
---------------

 -- Function: int shishi_checksum (Shishi * HANDLE, Shishi_key * KEY,
          int KEYUSAGE, int CKSUMTYPE, const char * IN, size_t INLEN,
          char ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to compute checksum with.

     KEYUSAGE: integer specifying what this key is used for.

     CKSUMTYPE: the checksum algorithm to use.

     IN: input array with data to integrity protect.

     INLEN: size of input array with data to integrity protect.

     OUT: output array with newly allocated integrity protected data.

     OUTLEN: output variable with length of output array with checksum.

     Integrity protect data using key, possibly altered by supplied key
     usage.  If key usage is 0, no key derivation is used.  The OUT
     buffer must be deallocated by the caller.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_verify
-------------

 -- Function: int shishi_verify (Shishi * HANDLE, Shishi_key * KEY, int
          KEYUSAGE, int CKSUMTYPE, const char * IN, size_t INLEN, const
          char * CKSUM, size_t CKSUMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to verify checksum with.

     KEYUSAGE: integer specifying what this key is used for.

     CKSUMTYPE: the checksum algorithm to use.

     IN: input array with data that was integrity protected.

     INLEN: size of input array with data that was integrity protected.

     CKSUM: input array with alleged checksum of data.

     CKSUMLEN: size of input array with alleged checksum of data.

     Verify checksum of data using key, possibly altered by supplied key
     usage.  If key usage is 0, no key derivation is used.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_encrypt_ivupdate_etype
-----------------------------

 -- Function: int shishi_encrypt_ivupdate_etype (Shishi * HANDLE,
          Shishi_key * KEY, int KEYUSAGE, int32_t ETYPE, const char *
          IV, size_t IVLEN, char ** IVOUT, size_t * IVOUTLEN, const
          char * IN, size_t INLEN, char ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to encrypt with.

     KEYUSAGE: integer specifying what this key is encrypting.

     ETYPE: integer specifying what cipher to use.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     IVOUT: output array with newly allocated updated initialization
     vector.

     IVOUTLEN: size of output array with updated initialization vector.

     IN: input array with data to encrypt.

     INLEN: size of input array with data to encrypt.

     OUT: output array with newly allocated encrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Encrypts data as per encryption method using specified
     initialization vector and key.  The key actually used is derived
     using the key usage.  If key usage is 0, no key derivation is used.
     The OUT buffer must be deallocated by the caller.  If IVOUT or
     IVOUTLEN is NULL, the updated IV is not saved anywhere.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_encrypt_iv_etype
-----------------------

 -- Function: int shishi_encrypt_iv_etype (Shishi * HANDLE, Shishi_key
          * KEY, int KEYUSAGE, int32_t ETYPE, const char * IV, size_t
          IVLEN, const char * IN, size_t INLEN, char ** OUT, size_t *
          OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to encrypt with.

     KEYUSAGE: integer specifying what this key is encrypting.

     ETYPE: integer specifying what cipher to use.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     IN: input array with data to encrypt.

     INLEN: size of input array with data to encrypt.

     OUT: output array with newly allocated encrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Encrypts data as per encryption method using specified
     initialization vector and key.  The key actually used is derived
     using the key usage.  If key usage is 0, no key derivation is used.
     The OUT buffer must be deallocated by the caller.  The next IV is
     lost, see shishi_encrypt_ivupdate_etype if you need it.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_encrypt_etype
--------------------

 -- Function: int shishi_encrypt_etype (Shishi * HANDLE, Shishi_key *
          KEY, int KEYUSAGE, int32_t ETYPE, const char * IN, size_t
          INLEN, char ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to encrypt with.

     KEYUSAGE: integer specifying what this key is encrypting.

     ETYPE: integer specifying what cipher to use.

     IN: input array with data to encrypt.

     INLEN: size of input array with data to encrypt.

     OUT: output array with newly allocated encrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Encrypts data as per encryption method using specified
     initialization vector and key.  The key actually used is derived
     using the key usage.  If key usage is 0, no key derivation is used.
     The OUT buffer must be deallocated by the caller.  The default IV
     is used, see shishi_encrypt_iv_etype if you need to alter it. The
     next IV is lost, see shishi_encrypt_ivupdate_etype if you need it.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_encrypt_ivupdate
-----------------------

 -- Function: int shishi_encrypt_ivupdate (Shishi * HANDLE, Shishi_key
          * KEY, int KEYUSAGE, const char * IV, size_t IVLEN, char **
          IVOUT, size_t * IVOUTLEN, const char * IN, size_t INLEN, char
          ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to encrypt with.

     KEYUSAGE: integer specifying what this key is encrypting.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     IVOUT: output array with newly allocated updated initialization
     vector.

     IVOUTLEN: size of output array with updated initialization vector.

     IN: input array with data to encrypt.

     INLEN: size of input array with data to encrypt.

     OUT: output array with newly allocated encrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Encrypts data using specified initialization vector and key.  The
     key actually used is derived using the key usage.  If key usage is
     0, no key derivation is used.  The OUT buffer must be deallocated
     by the caller.  If IVOUT or IVOUTLEN is NULL, the updated IV is not
     saved anywhere.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_encrypt_iv
-----------------

 -- Function: int shishi_encrypt_iv (Shishi * HANDLE, Shishi_key * KEY,
          int KEYUSAGE, const char * IV, size_t IVLEN, const char * IN,
          size_t INLEN, char ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to encrypt with.

     KEYUSAGE: integer specifying what this key is encrypting.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     IN: input array with data to encrypt.

     INLEN: size of input array with data to encrypt.

     OUT: output array with newly allocated encrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Encrypts data using specified initialization vector and key.  The
     key actually used is derived using the key usage.  If key usage is
     0, no key derivation is used.  The OUT buffer must be deallocated
     by the caller.  The next IV is lost, see shishi_encrypt_ivupdate if
     you need it.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_encrypt
--------------

 -- Function: int shishi_encrypt (Shishi * HANDLE, Shishi_key * KEY,
          int KEYUSAGE, char * IN, size_t INLEN, char ** OUT, size_t *
          OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to encrypt with.

     KEYUSAGE: integer specifying what this key is encrypting.

     IN: input array with data to encrypt.

     INLEN: size of input array with data to encrypt.

     OUT: output array with newly allocated encrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Encrypts data using specified key.  The key actually used is
     derived using the key usage.  If key usage is 0, no key derivation
     is used.  The OUT buffer must be deallocated by the caller.  The
     default IV is used, see shishi_encrypt_iv if you need to alter it.
     The next IV is lost, see shishi_encrypt_ivupdate if you need it.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_decrypt_ivupdate_etype
-----------------------------

 -- Function: int shishi_decrypt_ivupdate_etype (Shishi * HANDLE,
          Shishi_key * KEY, int KEYUSAGE, int32_t ETYPE, const char *
          IV, size_t IVLEN, char ** IVOUT, size_t * IVOUTLEN, const
          char * IN, size_t INLEN, char ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to decrypt with.

     KEYUSAGE: integer specifying what this key is decrypting.

     ETYPE: integer specifying what cipher to use.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     IVOUT: output array with newly allocated updated initialization
     vector.

     IVOUTLEN: size of output array with updated initialization vector.

     IN: input array with data to decrypt.

     INLEN: size of input array with data to decrypt.

     OUT: output array with newly allocated decrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Decrypts data as per encryption method using specified
     initialization vector and key.  The key actually used is derived
     using the key usage.  If key usage is 0, no key derivation is used.
     The OUT buffer must be deallocated by the caller.  If IVOUT or
     IVOUTLEN is NULL, the updated IV is not saved anywhere.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_decrypt_iv_etype
-----------------------

 -- Function: int shishi_decrypt_iv_etype (Shishi * HANDLE, Shishi_key
          * KEY, int KEYUSAGE, int32_t ETYPE, const char * IV, size_t
          IVLEN, const char * IN, size_t INLEN, char ** OUT, size_t *
          OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to decrypt with.

     KEYUSAGE: integer specifying what this key is decrypting.

     ETYPE: integer specifying what cipher to use.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     IN: input array with data to decrypt.

     INLEN: size of input array with data to decrypt.

     OUT: output array with newly allocated decrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Decrypts data as per encryption method using specified
     initialization vector and key.  The key actually used is derived
     using the key usage.  If key usage is 0, no key derivation is used.
     The OUT buffer must be deallocated by the caller.  The next IV is
     lost, see shishi_decrypt_ivupdate_etype if you need it.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_decrypt_etype
--------------------

 -- Function: int shishi_decrypt_etype (Shishi * HANDLE, Shishi_key *
          KEY, int KEYUSAGE, int32_t ETYPE, const char * IN, size_t
          INLEN, char ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to decrypt with.

     KEYUSAGE: integer specifying what this key is decrypting.

     ETYPE: integer specifying what cipher to use.

     IN: input array with data to decrypt.

     INLEN: size of input array with data to decrypt.

     OUT: output array with newly allocated decrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Decrypts data as per encryption method using specified key.  The
     key actually used is derived using the key usage.  If key usage is
     0, no key derivation is used.  The OUT buffer must be deallocated
     by the caller.  The default IV is used, see shishi_decrypt_iv_etype
     if you need to alter it.  The next IV is lost, see
     shishi_decrypt_ivupdate_etype if you need it.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_decrypt_ivupdate
-----------------------

 -- Function: int shishi_decrypt_ivupdate (Shishi * HANDLE, Shishi_key
          * KEY, int KEYUSAGE, const char * IV, size_t IVLEN, char **
          IVOUT, size_t * IVOUTLEN, const char * IN, size_t INLEN, char
          ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to decrypt with.

     KEYUSAGE: integer specifying what this key is decrypting.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     IVOUT: output array with newly allocated updated initialization
     vector.

     IVOUTLEN: size of output array with updated initialization vector.

     IN: input array with data to decrypt.

     INLEN: size of input array with data to decrypt.

     OUT: output array with newly allocated decrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Decrypts data using specified initialization vector and key.  The
     key actually used is derived using the key usage.  If key usage is
     0, no key derivation is used.  The OUT buffer must be deallocated
     by the caller.  If IVOUT or IVOUTLEN is NULL, the updated IV is not
     saved anywhere.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_decrypt_iv
-----------------

 -- Function: int shishi_decrypt_iv (Shishi * HANDLE, Shishi_key * KEY,
          int KEYUSAGE, const char * IV, size_t IVLEN, const char * IN,
          size_t INLEN, char ** OUT, size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to decrypt with.

     KEYUSAGE: integer specifying what this key is decrypting.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     IN: input array with data to decrypt.

     INLEN: size of input array with data to decrypt.

     OUT: output array with newly allocated decrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Decrypts data using specified initialization vector and key.  The
     key actually used is derived using the key usage.  If key usage is
     0, no key derivation is used.  The OUT buffer must be deallocated
     by the caller.  The next IV is lost, see
     shishi_decrypt_ivupdate_etype if you need it.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_decrypt
--------------

 -- Function: int shishi_decrypt (Shishi * HANDLE, Shishi_key * KEY,
          int KEYUSAGE, const char * IN, size_t INLEN, char ** OUT,
          size_t * OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to decrypt with.

     KEYUSAGE: integer specifying what this key is decrypting.

     IN: input array with data to decrypt.

     INLEN: size of input array with data to decrypt.

     OUT: output array with newly allocated decrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Decrypts data specified key.  The key actually used is derived
     using the key usage.  If key usage is 0, no key derivation is used.
     The OUT buffer must be deallocated by the caller.  The default IV
     is used, see shishi_decrypt_iv if you need to alter it.  The next
     IV is lost, see shishi_decrypt_ivupdate if you need it.

     Note that DECRYPT(ENCRYPT(data)) does not necessarily yield data
     exactly.  Some encryption types add pad to make the data fit into
     the block size of the encryption algorithm.  Furthermore, the pad
     is not guaranteed to look in any special way, although existing
     implementations often pad with the zero byte.  This means that you
     may have to "frame" data, so it is possible to infer the original
     length after decryption.  Compare ASN.1 DER which contains such
     information.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_n_fold
-------------

 -- Function: int shishi_n_fold (Shishi * HANDLE, const char * IN,
          size_t INLEN, char * OUT, size_t OUTLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     IN: input array with data to decrypt.

     INLEN: size of input array with data to decrypt ("M").

     OUT: output array with decrypted data.

     OUTLEN: size of output array ("N").

     Fold data into a fixed length output array, with the intent to give
     each input bit approximately equal weight in determining the value
     of each output bit.

     The algorithm is from "A Better Key Schedule For DES-like Ciphers"
     by Uri Blumenthal and Steven M. Bellovin,
     http://www.research.att.com/~smb/papers/ides.pdf, although the
     sample vectors provided by the paper are incorrect.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_dr
---------

 -- Function: int shishi_dr (Shishi * HANDLE, Shishi_key * KEY, const
          char * PRFCONSTANT, size_t PRFCONSTANTLEN, char *
          DERIVEDRANDOM, size_t DERIVEDRANDOMLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: input array with cryptographic key to use.

     PRFCONSTANT: input array with the constant string.

     PRFCONSTANTLEN: size of input array with the constant string.

     DERIVEDRANDOM: output array with derived random data.

     DERIVEDRANDOMLEN: size of output array with derived random data.

     Derive "random" data from a key and a constant thusly: DR(KEY,
     PRFCONSTANT) = TRUNCATE(DERIVEDRANDOMLEN, SHISHI_ENCRYPT(KEY,
     PRFCONSTANT)).

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_dk
---------

 -- Function: int shishi_dk (Shishi * HANDLE, Shishi_key * KEY, const
          char * PRFCONSTANT, size_t PRFCONSTANTLEN, Shishi_key *
          DERIVEDKEY)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: input cryptographic key to use.

     PRFCONSTANT: input array with the constant string.

     PRFCONSTANTLEN: size of input array with the constant string.

     DERIVEDKEY: pointer to derived key (allocated by caller).

     *Derive a key from a key and a constant thusly:* DK(KEY,
     PRFCONSTANT) = SHISHI_RANDOM-TO-KEY(SHISHI_DR(KEY, PRFCONSTANT)).

     *Return value:* Returns `SHISHI_OK' iff successful.

   An easier way to use encryption and decryption if your application
repeatedly calls, e.g., `shishi_encrypt_ivupdate', is to use the
following functions.  They store the key, initialization vector, etc,
in a context, and the encryption and decryption operations update the
IV within the context automatically.

shishi_crypto
-------------

 -- Function: Shishi_crypto * shishi_crypto (Shishi * HANDLE,
          Shishi_key * KEY, int KEYUSAGE, int32_t ETYPE, const char *
          IV, size_t IVLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: key to encrypt with.

     KEYUSAGE: integer specifying what this key will encrypt/decrypt.

     ETYPE: integer specifying what cipher to use.

     IV: input array with initialization vector

     IVLEN: size of input array with initialization vector.

     Initialize a crypto context.  This store a key, keyusage,
     encryption type and initialization vector in a "context", and the
     caller can then use this context to perform encryption via
     `shishi_crypto_encrypt()' and decryption via
     `shishi_crypto_encrypt()' without supplying all those details
     again.  The functions also takes care of propagating the IV
     between calls.

     When the application no longer need to use the context, it should
     deallocate resources associated with it by calling
     `shishi_crypto_done()'.

     *Return value:* Return a newly allocated crypto context.

shishi_crypto_encrypt
---------------------

 -- Function: int shishi_crypto_encrypt (Shishi_crypto * CTX, const
          char * IN, size_t INLEN, char ** OUT, size_t * OUTLEN)
     CTX: crypto context as returned by `shishi_crypto()'.

     IN: input array with data to encrypt.

     INLEN: size of input array with data to encrypt.

     OUT: output array with newly allocated encrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Encrypt data, using information (e.g., key and initialization
     vector) from context.  The IV is updated inside the context after
     this call.

     When the application no longer need to use the context, it should
     deallocate resources associated with it by calling
     `shishi_crypto_done()'.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_crypto_decrypt
---------------------

 -- Function: int shishi_crypto_decrypt (Shishi_crypto * CTX, const
          char * IN, size_t INLEN, char ** OUT, size_t * OUTLEN)
     CTX: crypto context as returned by `shishi_crypto()'.

     IN: input array with data to decrypt.

     INLEN: size of input array with data to decrypt.

     OUT: output array with newly allocated decrypted data.

     OUTLEN: output variable with size of newly allocated output array.

     Decrypt data, using information (e.g., key and initialization
     vector) from context.  The IV is updated inside the context after
     this call.

     When the application no longer need to use the context, it should
     deallocate resources associated with it by calling
     `shishi_crypto_done()'.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_crypto_close
-------------------

 -- Function: void shishi_crypto_close (Shishi_crypto * CTX)
     CTX: crypto context as returned by `shishi_crypto()'.

     Deallocate resources associated with the crypto context.

   Also included in Shishi is an interface to the really low-level
cryptographic primitives.  They map directly on the underlying
cryptographic library used (i.e., Gnulib or Libgcrypt) and is used
internally by Shishi.

shishi_randomize
----------------

 -- Function: int shishi_randomize (Shishi * HANDLE, int STRONG, void *
          DATA, size_t DATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     STRONG: 0 iff operation should not block, non-0 for very strong
     randomness.

     DATA: output array to be filled with random data.

     DATALEN: size of output array.

     Store cryptographically random data of given size in the provided
     buffer.

     *Return value:* Returns `SHISHI_OK' iff successful.

shishi_crc
----------

 -- Function: int shishi_crc (Shishi * HANDLE, const char * IN, size_t
          INLEN, char * OUT[4])
     HANDLE: shishi handle as allocated by `shishi_init()'.

     IN: input character array of data to checksum.

     INLEN: length of input character array of data to checksum.

     Compute checksum of data using CRC32 modified according to RFC
     1510.  The `out' buffer must be deallocated by the caller.

     The modifications compared to standard CRC32 is that no initial and
     final XOR is performed, and that the output is returned in
     LSB-first order.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_md4
----------

 -- Function: int shishi_md4 (Shishi * HANDLE, const char * IN, size_t
          INLEN, char * OUT[16])
     HANDLE: shishi handle as allocated by `shishi_init()'.

     IN: input character array of data to hash.

     INLEN: length of input character array of data to hash.

     Compute hash of data using MD4.  The `out' buffer must be
     deallocated by the caller.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_md5
----------

 -- Function: int shishi_md5 (Shishi * HANDLE, const char * IN, size_t
          INLEN, char * OUT[16])
     HANDLE: shishi handle as allocated by `shishi_init()'.

     IN: input character array of data to hash.

     INLEN: length of input character array of data to hash.

     Compute hash of data using MD5.  The `out' buffer must be
     deallocated by the caller.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_hmac_md5
---------------

 -- Function: int shishi_hmac_md5 (Shishi * HANDLE, const char * KEY,
          size_t KEYLEN, const char * IN, size_t INLEN, char *
          OUTHASH[16])
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: input character array with key to use.

     KEYLEN: length of input character array with key to use.

     IN: input character array of data to hash.

     INLEN: length of input character array of data to hash.

     Compute keyed checksum of data using HMAC-MD5.  The `outhash'
     buffer must be deallocated by the caller.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_hmac_sha1
----------------

 -- Function: int shishi_hmac_sha1 (Shishi * HANDLE, const char * KEY,
          size_t KEYLEN, const char * IN, size_t INLEN, char *
          OUTHASH[20])
     HANDLE: shishi handle as allocated by `shishi_init()'.

     KEY: input character array with key to use.

     KEYLEN: length of input character array with key to use.

     IN: input character array of data to hash.

     INLEN: length of input character array of data to hash.

     Compute keyed checksum of data using HMAC-SHA1.  The `outhash'
     buffer must be deallocated by the caller.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_des_cbc_mac
------------------

 -- Function: int shishi_des_cbc_mac (Shishi * HANDLE, const char
          KEY[8], const char IV[8], const char * IN, size_t INLEN, char
          * OUT[8])
     HANDLE: shishi handle as allocated by `shishi_init()'.

     IN: input character array of data to hash.

     INLEN: length of input character array of data to hash.

     Computed keyed checksum of data using DES-CBC-MAC.  The `out'
     buffer must be deallocated by the caller.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_arcfour
--------------

 -- Function: int shishi_arcfour (Shishi * HANDLE, int DECRYPTP, const
          char * KEY, size_t KEYLEN, const char IV[258], char *
          IVOUT[258], const char * IN, size_t INLEN, char ** OUT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DECRYPTP: 0 to indicate encryption, non-0 to indicate decryption.

     KEY: input character array with key to use.

     KEYLEN: length of input key array.

     IN: input character array of data to encrypt/decrypt.

     INLEN: length of input character array of data to encrypt/decrypt.

     OUT: newly allocated character array with encrypted/decrypted data.

     Encrypt or decrypt data (depending on `decryptp') using ARCFOUR.
     The `out' buffer must be deallocated by the caller.

     The "initialization vector" used here is the concatenation of the
     sbox and i and j, and is thus always of size 256 + 1 + 1.  This is
     a slight abuse of terminology, and assumes you know what you are
     doing.  Don't use it if you can avoid to.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_des
----------

 -- Function: int shishi_des (Shishi * HANDLE, int DECRYPTP, const char
          KEY[8], const char IV[8], char * IVOUT[8], const char * IN,
          size_t INLEN, char ** OUT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DECRYPTP: 0 to indicate encryption, non-0 to indicate decryption.

     IN: input character array of data to encrypt/decrypt.

     INLEN: length of input character array of data to encrypt/decrypt.

     OUT: newly allocated character array with encrypted/decrypted data.

     Encrypt or decrypt data (depending on `decryptp') using DES in CBC
     mode.  The `out' buffer must be deallocated by the caller.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_3des
-----------

 -- Function: int shishi_3des (Shishi * HANDLE, int DECRYPTP, const
          char KEY[8], const char IV[8], char * IVOUT[8], const char *
          IN, size_t INLEN, char ** OUT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DECRYPTP: 0 to indicate encryption, non-0 to indicate decryption.

     IN: input character array of data to encrypt/decrypt.

     INLEN: length of input character array of data to encrypt/decrypt.

     OUT: newly allocated character array with encrypted/decrypted data.

     Encrypt or decrypt data (depending on `decryptp') using 3DES in CBC
     mode.  The `out' buffer must be deallocated by the caller.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_aes_cts
--------------

 -- Function: int shishi_aes_cts (Shishi * HANDLE, int DECRYPTP, const
          char * KEY, size_t KEYLEN, const char IV[16], char *
          IVOUT[16], const char * IN, size_t INLEN, char ** OUT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DECRYPTP: 0 to indicate encryption, non-0 to indicate decryption.

     KEY: input character array with key to use.

     KEYLEN: length of input character array with key to use.

     IN: input character array of data to encrypt/decrypt.

     INLEN: length of input character array of data to encrypt/decrypt.

     OUT: newly allocated character array with encrypted/decrypted data.

     Encrypt or decrypt data (depending on `decryptp') using AES in
     CBC-CTS mode.  The length of the key, `keylen', decide if AES 128
     or AES 256 should be used.  The `out' buffer must be deallocated
     by the caller.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_pbkdf2_sha1
------------------

 -- Function: int shishi_pbkdf2_sha1 (Shishi * HANDLE, const char * P,
          size_t PLEN, const char * S, size_t SLEN, unsigned int C,
          unsigned int DKLEN, char * DK)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     P: input password, an octet string

     PLEN: length of password, an octet string

     S: input salt, an octet string

     SLEN: length of salt, an octet string

     C: iteration count, a positive integer

     DKLEN: intended length in octets of the derived key, a positive
     integer, at most (2^32 - 1) * hLen.  The DK array must have room
     for this many characters.

     DK: output derived key, a dkLen-octet string

     Derive key using the PBKDF2 defined in PKCS5.  PBKDF2 applies a
     pseudorandom function to derive keys. The length of the derived key
     is essentially unbounded. (However, the maximum effective search
     space for the derived key may be limited by the structure of the
     underlying pseudorandom function, which is this function is always
     SHA1.)

     *Return value:* Returns SHISHI_OK iff successful.


File: shishi.info,  Node: X.509 Functions,  Next: Utility Functions,  Prev: Cryptographic Functions,  Up: Programming Manual

5.14 X.509 Functions
====================

The functions described in this section are used by the STARTTLS
functionality, see *note Kerberos via TLS::.

shishi_x509ca_default_file_guess
--------------------------------

 -- Function: char * shishi_x509ca_default_file_guess (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Guesses the default X.509 CA certificate filename; it is
     $HOME/.shishi/client.ca.

     *Return value:* Returns default X.509 client certificate filename
     as a string that has to be deallocated with `free()' by the caller.

shishi_x509ca_default_file_set
------------------------------

 -- Function: void shishi_x509ca_default_file_set (Shishi * HANDLE,
          const char * X509CAFILE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     X509CAFILE: string with new default x509 client certificate file
     name, or NULL to reset to default.

     Set the default X.509 CA certificate filename used in the library.
     The certificate is used during TLS connections with the KDC to
     authenticate the KDC.  The string is copied into the library, so
     you can dispose of the variable immediately after calling this
     function.

shishi_x509ca_default_file
--------------------------

 -- Function: const char * shishi_x509ca_default_file (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Get filename for default X.509 CA certificate.

     *Return value:* Returns the default X.509 CA certificate filename
     used in the library.  The certificate is used during TLS
     connections with the KDC to authenticate the KDC.  The string is
     not a copy, so don't modify or deallocate it.

shishi_x509cert_default_file_guess
----------------------------------

 -- Function: char * shishi_x509cert_default_file_guess (Shishi *
          HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Guesses the default X.509 client certificate filename; it is
     $HOME/.shishi/client.certs.

     *Return value:* Returns default X.509 client certificate filename
     as a string that has to be deallocated with `free()' by the caller.

shishi_x509cert_default_file_set
--------------------------------

 -- Function: void shishi_x509cert_default_file_set (Shishi * HANDLE,
          const char * X509CERTFILE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     X509CERTFILE: string with new default x509 client certificate file
     name, or NULL to reset to default.

     Set the default X.509 client certificate filename used in the
     library.  The certificate is used during TLS connections with the
     KDC to authenticate the client.  The string is copied into the
     library, so you can dispose of the variable immediately after
     calling this function.

shishi_x509cert_default_file
----------------------------

 -- Function: const char * shishi_x509cert_default_file (Shishi *
          HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Get filename for default X.509 certificate.

     *Return value:* Returns the default X.509 client certificate
     filename used in the library.  The certificate is used during TLS
     connections with the KDC to authenticate the client.  The string is
     not a copy, so don't modify or deallocate it.

shishi_x509key_default_file_guess
---------------------------------

 -- Function: char * shishi_x509key_default_file_guess (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Guesses the default X.509 client key filename; it is
     $HOME/.shishi/client.key.

     *Return value:* Returns default X.509 client key filename as a
     string that has to be deallocated with `free()' by the caller.

shishi_x509key_default_file_set
-------------------------------

 -- Function: void shishi_x509key_default_file_set (Shishi * HANDLE,
          const char * X509KEYFILE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     X509KEYFILE: string with new default x509 client key file name, or
     NULL to reset to default.

     Set the default X.509 client key filename used in the library.  The
     key is used during TLS connections with the KDC to authenticate the
     client.  The string is copied into the library, so you can dispose
     of the variable immediately after calling this function.

shishi_x509key_default_file
---------------------------

 -- Function: const char * shishi_x509key_default_file (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Get filename for default X.509 key.

     *Return value:* Returns the default X.509 client key filename used
     in the library.  The key is used during TLS connections with the
     KDC to authenticate the client.  The string is not a copy, so
     don't modify or deallocate it.


File: shishi.info,  Node: Utility Functions,  Next: ASN.1 Functions,  Prev: X.509 Functions,  Up: Programming Manual

5.15 Utility Functions
======================

shishi_realm_default_guess
--------------------------

 -- Function: char * shishi_realm_default_guess ( VOID)
     Guesses a realm based on `getdomainname()' (which really is NIS/YP
     domain, but if it is set it might be a good guess), or if it fails,
     based on `gethostname()', or if it fails, the string
     "could-not-guess-default-realm". Note that the hostname is not
     trimmed off of the data returned by `gethostname()' to get the
     domain name and use that as the realm.

     *Return value:* Returns guessed realm for host as a string that has
     to be deallocated with `free()' by the caller.

shishi_realm_default
--------------------

 -- Function: const char * shishi_realm_default (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     Get name of default realm.

     *Return value:* Returns the default realm used in the library.
     (Not a copy of it, so don't modify or deallocate it.)

shishi_realm_default_set
------------------------

 -- Function: void shishi_realm_default_set (Shishi * HANDLE, const
          char * REALM)
     HANDLE: Shishi library handle create by `shishi_init()'.

     REALM: string with new default realm name, or NULL to reset to
     default.

     Set the default realm used in the library.  The string is copied
     into the library, so you can dispose of the variable immediately
     after calling this function.

shishi_realm_for_server_file
----------------------------

 -- Function: char * shishi_realm_for_server_file (Shishi * HANDLE,
          char * SERVER)
     HANDLE: Shishi library handle create by `shishi_init()'.

     SERVER: hostname to find realm for.

     Find realm for a host using configuration file.

     *Return value:* Returns realm for host, or NULL if not found.

shishi_realm_for_server_dns
---------------------------

 -- Function: char * shishi_realm_for_server_dns (Shishi * HANDLE, char
          * SERVER)
     HANDLE: Shishi library handle create by `shishi_init()'.

     SERVER: hostname to find realm for.

     Find realm for a host using DNS lookups, according to
     draft-ietf-krb-wg-krb-dns-locate-03.txt.  Since DNS lookups may be
     spoofed, relying on the realm information may result in a
     redirection attack.  In a single-realm scenario, this only achieves
     a denial of service, but with cross-realm trust it may redirect you
     to a compromised realm.  For this reason, Shishi prints a warning,
     suggesting that the user should add the proper 'server-realm'
     configuration tokens instead.

     To illustrate the DNS information used, here is an extract from a
     zone file for the domain ASDF.COM:

     _kerberos.asdf.com.             IN      TXT     "ASDF.COM"
     _kerberos.mrkserver.asdf.com.   IN      TXT
     "MARKETING.ASDF.COM" _kerberos.salesserver.asdf.com. IN      TXT
      "SALES.ASDF.COM"

     Let us suppose that in this case, a client wishes to use a service
     on the host foo.asdf.com.  It would first query:

     _kerberos.foo.asdf.com. IN TXT

     Finding no match, it would then query:

     _kerberos.asdf.com. IN TXT

     *Return value:* Returns realm for host, or NULL if not found.

shishi_realm_for_server
-----------------------

 -- Function: char * shishi_realm_for_server (Shishi * HANDLE, char *
          SERVER)
     HANDLE: Shishi library handle create by `shishi_init()'.

     SERVER: hostname to find realm for.

     Find realm for a host, using various methods.  Currently this
     includes static configuration files (see
     `shishi_realm_for_server_file()') and DNS (see
     `shishi_realm_for_server_dns()').

     *Return value:* Returns realm for host, or NULL if not found.

shishi_principal_default_guess
------------------------------

 -- Function: char * shishi_principal_default_guess ( VOID)
     Guesses the principal name for the user, looking at environment
     variables SHISHI_USER and USER, or if that fails, returns the
     string "user".

     *Return value:* Returns guessed default principal for user as a
     string that has to be deallocated with `free()' by the caller.

shishi_principal_default
------------------------

 -- Function: const char * shishi_principal_default (Shishi * HANDLE)
     HANDLE: Shishi library handle create by `shishi_init()'.

     The default principal name is the name in the environment variable
     USER, but can be overridden by specifying the environment variable
     SHISHI_USER.

     *Return value:* Returns the default principal name used in the
     library.  (Not a copy of it, so don't modify or deallocate it.)

shishi_principal_default_set
----------------------------

 -- Function: void shishi_principal_default_set (Shishi * HANDLE, const
          char * PRINCIPAL)
     HANDLE: Shishi library handle create by `shishi_init()'.

     PRINCIPAL: string with new default principal name, or NULL to
     reset to default.

     Set the default realm used in the library.  The string is copied
     into the library, so you can dispose of the variable immediately
     after calling this function.

shishi_parse_name
-----------------

 -- Function: int shishi_parse_name (Shishi * HANDLE, const char *
          NAME, char ** PRINCIPAL, char ** REALM)
     HANDLE: Shishi library handle create by `shishi_init()'.

     NAME: Input principal name string, e.g. imap/mail.gnu.org`GNU'.ORG.

     PRINCIPAL: newly allocated output string with principal name.

     REALM: newly allocated output string with realm name.

     Split up principal name (e.g., "simon`JOSEFSSON'.ORG") into two
     newly allocated strings, the principal ("simon") and realm
     ("JOSEFSSON.ORG").  If there is no realm part in NAME, REALM is set
     to NULL.

     *Return value:* Returns SHISHI_INVALID_PRINCIPAL_NAME if NAME is
     NULL or ends with the escape character "\", or SHISHI_OK iff
     successful

shishi_principal_name
---------------------

 -- Function: int shishi_principal_name (Shishi * HANDLE, Shishi_asn1
          NAMENODE, const char * NAMEFIELD, char ** OUT, size_t *
          OUTLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     NAMENODE: ASN.1 structure with principal in `namefield'.

     NAMEFIELD: name of field in `namenode' containing principal name.

     OUT: pointer to newly allocated zero terminated string containing
     principal name.  May be `NULL' (to only populate `outlen').

     OUTLEN: pointer to length of `out' on output, excluding terminating
     zero.  May be `NULL' (to only populate `out').

     Represent principal name in ASN.1 structure as zero-terminated
     string.  The string is allocate by this function, and it is the
     responsibility of the caller to deallocate it.  Note that the
     output length `outlen' does not include the terminating zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_principal_name_realm
---------------------------

 -- Function: int shishi_principal_name_realm (Shishi * HANDLE,
          Shishi_asn1 NAMENODE, const char * NAMEFIELD, Shishi_asn1
          REALMNODE, const char * REALMFIELD, char ** OUT, size_t *
          OUTLEN)
     HANDLE: Shishi library handle create by `shishi_init()'.

     NAMENODE: ASN.1 structure with principal name in `namefield'.

     NAMEFIELD: name of field in `namenode' containing principal name.

     REALMNODE: ASN.1 structure with principal realm in `realmfield'.

     REALMFIELD: name of field in `realmnode' containing principal
     realm.

     OUT: pointer to newly allocated zero terminated string containing
     principal name.  May be `NULL' (to only populate `outlen').

     OUTLEN: pointer to length of `out' on output, excluding terminating
     zero.  May be `NULL' (to only populate `out').

     Represent principal name and realm in ASN.1 structure as
     zero-terminated string.  The string is allocate by this function,
     and it is the responsibility of the caller to deallocate it.  Note
     that the output length `outlen' does not include the terminating
     zero.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_principal_name_set
-------------------------

 -- Function: int shishi_principal_name_set (Shishi * HANDLE,
          Shishi_asn1 NAMENODE, const char * NAMEFIELD,
          Shishi_name_type NAME_TYPE, const char * [] NAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NAMENODE: ASN.1 structure with principal in `namefield'.

     NAMEFIELD: name of field in namenode containing principal name.

     NAME_TYPE: type of principial, see Shishi_name_type, usually
     SHISHI_NT_UNKNOWN.

     NAME: zero-terminated input array with principal name.

     Set the given principal name field to given name.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_principal_set
--------------------

 -- Function: int shishi_principal_set (Shishi * HANDLE, Shishi_asn1
          NAMENODE, const char * NAMEFIELD, const char * NAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NAMENODE: ASN.1 structure with principal in `namefield'.

     NAMEFIELD: name of field in namenode containing principal name.

     NAME: zero-terminated string with principal name on RFC 1964 form.

     Set principal name field in ASN.1 structure to given name.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_derive_default_salt
--------------------------

 -- Function: int shishi_derive_default_salt (Shishi * HANDLE, const
          char * NAME, char ** SALT)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NAME: principal name of user.

     SALT: output variable with newly allocated salt string.

     Derive the default salt from a principal.  The default salt is the
     concatenation of the decoded realm and principal.

     *Return value:* Return SHISHI_OK if successful.

shishi_server_for_local_service
-------------------------------

 -- Function: char * shishi_server_for_local_service (Shishi * HANDLE,
          const char * SERVICE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     SERVICE: zero terminated string with name of service, e.g., "host".

     Construct a service principal (e.g., "imap/yxa.extuno.com") based
     on supplied service name (i.e., "imap") and the system hostname as
     returned by `hostname()' (i.e., "yxa.extundo.com").  The string
     must be deallocated by the caller.

     *Return value:* Return newly allocated service name string.

shishi_authorization_parse
--------------------------

 -- Function: int shishi_authorization_parse (const char *
          AUTHORIZATION)
     AUTHORIZATION: name of authorization type, e.g. "basic".

     Parse authorization type name.

     *Return value:* Return authorization type corresponding to a
     string.

shishi_authorized_p
-------------------

 -- Function: int shishi_authorized_p (Shishi * HANDLE, Shishi_tkt *
          TKT, const char * AUTHZNAME)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TKT: input variable with ticket info.

     AUTHZNAME: authorization name.

     Simplistic authorization of `authzname' against encrypted client
     principal name inside ticket.  Currently this function only compare
     the principal name with `authzname' using `strcmp()'.

     *Return value:* Returns 1 if authzname is authorized for services
     by authenticated client principal, or 0 otherwise.

shishi_generalize_time
----------------------

 -- Function: const char * shishi_generalize_time (Shishi * HANDLE,
          time_t T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     T: C time to convert.

     Convert C time to KerberosTime.  The string must not be deallocate
     by caller.

     *Return value:* Return a KerberosTime time string corresponding to
     C time t.

shishi_generalize_now
---------------------

 -- Function: const char * shishi_generalize_now (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Convert current time to KerberosTime.  The string must not be
     deallocate by caller.

     *Return value:* Return a KerberosTime time string corresponding to
     current time.

shishi_generalize_ctime
-----------------------

 -- Function: time_t shishi_generalize_ctime (Shishi * HANDLE, const
          char * T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     T: KerberosTime to convert.

     Convert KerberosTime to C time.

     *Return value:* Returns C time corresponding to KerberosTime t.

shishi_time
-----------

 -- Function: int shishi_time (Shishi * HANDLE, Shishi_asn1 NODE, const
          char * FIELD, char ** T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 node to get time from.

     FIELD: Name of field in ASN.1 node to get time from.

     T: newly allocated output array with zero terminated time string.

     Extract time from ASN.1 structure.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_ctime
------------

 -- Function: int shishi_ctime (Shishi * HANDLE, Shishi_asn1 NODE,
          const char * FIELD, time_t * T)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 variable to read field from.

     FIELD: name of field in `node' to read.

     T: pointer to time field to set.

     Extract time from ASN.1 structure.

     *Return value:* Returns SHISHI_OK if successful,
     SHISHI_ASN1_NO_ELEMENT if the element do not exist,
     SHISHI_ASN1_NO_VALUE if the field has no value, ot
     SHISHI_ASN1_ERROR otherwise.

shishi_prompt_password_callback_set
-----------------------------------

 -- Function: void shishi_prompt_password_callback_set (Shishi *
          HANDLE, shishi_prompt_password_func CB)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     CB: function pointer to application password callback, a
     `shishi_prompt_password_func' type.

     Set a callback function that will be used by
     `shishi_prompt_password()' to query the user for a password.  The
     function pointer can be retrieved using
     `shishi_prompt_password_callback_get()'.

     The `cb' function should follow the `shishi_prompt_password_func'
     prototype:

     int prompt_password (Shishi * `handle', char **`s', const char
     *`format', va_list `ap');

     If the function returns 0, the `s' variable should contain a newly
     allocated string with the password read from the user.

shishi_prompt_password_callback_get
-----------------------------------

 -- Function: shishi_prompt_password_func
shishi_prompt_password_callback_get (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Get the application password prompt function callback as set by
     `shishi_prompt_password_callback_set()'.

     *Returns:* Returns the callback, a `shishi_prompt_password_func'
     type, or `NULL'.

shishi_prompt_password
----------------------

 -- Function: int shishi_prompt_password (Shishi * HANDLE, char ** S,
          const char * FORMAT, ...)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     S: pointer to newly allocated output string with read password.

     FORMAT: printf(3) style format string.  ...: printf(3) style
     arguments.

     Format and print a prompt, and read a password from user.  The
     password is possibly converted (e.g., converted from Latin-1 to
     UTF-8, or processed using Stringprep profile) following any
     "stringprocess" keywords in configuration files.

     *Return value:* Returns SHISHI_OK iff successful.

shishi_resolv
-------------

 -- Function: Shishi_dns shishi_resolv (const char * ZONE, uint16_t
          QUERYTYPE)
     ZONE: owner name of data, e.g. "EXAMPLE.ORG"

     QUERYTYPE: type of data to query for, e.g., SHISHI_DNS_TXT.

     Query DNS resolver for data of type `querytype' at owner name
     `zone'.  Currently TXT and SRV types are supported.

     *Return value:* Returns linked list of DNS records, or NULL if
     query failed.

shishi_resolv_free
------------------

 -- Function: void shishi_resolv_free (Shishi_dns RRS)
     RRS: list of DNS RR as returned by `shishi_resolv()'.

     Deallocate list of DNS RR as returned by `shishi_resolv()'.


File: shishi.info,  Node: ASN.1 Functions,  Next: Error Handling,  Prev: Utility Functions,  Up: Programming Manual

5.16 ASN.1 Functions
====================

shishi_asn1_read_inline
-----------------------

 -- Function: int shishi_asn1_read_inline (Shishi * HANDLE, Shishi_asn1
          NODE, const char * FIELD, char * DATA, size_t * DATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 variable to read field from.

     FIELD: name of field in `node' to read.

     DATA: pre-allocated output buffer that will hold ASN.1 field data.

     DATALEN: on input, maximum size of output buffer, on output,
     actual size of output buffer.

     Extract data stored in a ASN.1 field into a fixed size buffer
     allocated by caller.

     Note that since it is difficult to predict the length of the field,
     it is often better to use `shishi_asn1_read()' instead.

     *Return value:* Returns SHISHI_OK if successful,
     SHISHI_ASN1_NO_ELEMENT if the element do not exist,
     SHISHI_ASN1_NO_VALUE if the field has no value, ot
     SHISHI_ASN1_ERROR otherwise.

shishi_asn1_read
----------------

 -- Function: int shishi_asn1_read (Shishi * HANDLE, Shishi_asn1 NODE,
          const char * FIELD, char ** DATA, size_t * DATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 variable to read field from.

     FIELD: name of field in `node' to read.

     DATA: newly allocated output buffer that will hold ASN.1 field
     data.

     DATALEN: actual size of output buffer.

     Extract data stored in a ASN.1 field into a newly allocated buffer.
     The buffer will always be zero terminated, even though `datalen'
     will not include the added zero.

     *Return value:* Returns SHISHI_OK if successful,
     SHISHI_ASN1_NO_ELEMENT if the element do not exist,
     SHISHI_ASN1_NO_VALUE if the field has no value, ot
     SHISHI_ASN1_ERROR otherwise.

shishi_asn1_read_optional
-------------------------

 -- Function: int shishi_asn1_read_optional (Shishi * HANDLE,
          Shishi_asn1 NODE, const char * FIELD, char ** DATA, size_t *
          DATALEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 variable to read field from.

     FIELD: name of field in `node' to read.

     DATA: newly allocated output buffer that will hold ASN.1 field
     data.

     DATALEN: actual size of output buffer.

     Extract data stored in a ASN.1 field into a newly allocated buffer.
     If the field does not exist (i.e., SHISHI_ASN1_NO_ELEMENT), this
     function set datalen to 0 and succeeds.  Can be useful to read
     ASN.1 fields which are marked OPTIONAL in the grammar, if you want
     to avoid special error handling in your code.

     *Return value:* Returns SHISHI_OK if successful,
     SHISHI_ASN1_NO_VALUE if the field has no value, ot
     SHISHI_ASN1_ERROR otherwise.

shishi_asn1_done
----------------

 -- Function: void shishi_asn1_done (Shishi * HANDLE, Shishi_asn1 NODE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 node to dellocate.

     Deallocate resources associated with ASN.1 structure.  Note that
     the node must not be used after this call.

shishi_asn1_pa_enc_ts_enc
-------------------------

 -- Function: Shishi_asn1 shishi_asn1_pa_enc_ts_enc (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for PA-ENC-TS-ENC.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_encrypteddata
-------------------------

 -- Function: Shishi_asn1 shishi_asn1_encrypteddata (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for EncryptedData

     *Return value:* Returns ASN.1 structure.

shishi_asn1_padata
------------------

 -- Function: Shishi_asn1 shishi_asn1_padata (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for PA-DATA.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_methoddata
----------------------

 -- Function: Shishi_asn1 shishi_asn1_methoddata (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for METHOD-DATA.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_etype_info
----------------------

 -- Function: Shishi_asn1 shishi_asn1_etype_info (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for ETYPE-INFO.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_etype_info2
-----------------------

 -- Function: Shishi_asn1 shishi_asn1_etype_info2 (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for ETYPE-INFO2.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_asreq
-----------------

 -- Function: Shishi_asn1 shishi_asn1_asreq (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for AS-REQ.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_asrep
-----------------

 -- Function: Shishi_asn1 shishi_asn1_asrep (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for AS-REP.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_tgsreq
------------------

 -- Function: Shishi_asn1 shishi_asn1_tgsreq (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for TGS-REQ.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_tgsrep
------------------

 -- Function: Shishi_asn1 shishi_asn1_tgsrep (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for TGS-REP.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_apreq
-----------------

 -- Function: Shishi_asn1 shishi_asn1_apreq (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for AP-REQ.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_aprep
-----------------

 -- Function: Shishi_asn1 shishi_asn1_aprep (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for AP-REP.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_encapreppart
------------------------

 -- Function: Shishi_asn1 shishi_asn1_encapreppart (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for AP-REP.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_ticket
------------------

 -- Function: Shishi_asn1 shishi_asn1_ticket (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for Ticket.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_encticketpart
-------------------------

 -- Function: Shishi_asn1 shishi_asn1_encticketpart (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for EncTicketPart.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_authenticator
-------------------------

 -- Function: Shishi_asn1 shishi_asn1_authenticator (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for Authenticator.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_enckdcreppart
-------------------------

 -- Function: Shishi_asn1 shishi_asn1_enckdcreppart (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for EncKDCRepPart.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_encasreppart
------------------------

 -- Function: Shishi_asn1 shishi_asn1_encasreppart (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for EncASRepPart.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_krberror
--------------------

 -- Function: Shishi_asn1 shishi_asn1_krberror (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for KRB-ERROR.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_krbsafe
-------------------

 -- Function: Shishi_asn1 shishi_asn1_krbsafe (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for KRB-SAFE.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_priv
----------------

 -- Function: Shishi_asn1 shishi_asn1_priv (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for KRB-PRIV.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_encprivpart
-----------------------

 -- Function: Shishi_asn1 shishi_asn1_encprivpart (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Create new ASN.1 structure for EncKrbPrivPart.

     *Return value:* Returns ASN.1 structure.

shishi_asn1_to_der_field
------------------------

 -- Function: int shishi_asn1_to_der_field (Shishi * HANDLE,
          Shishi_asn1 NODE, const char * FIELD, char ** DER, size_t *
          LEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 data that have field to extract.

     FIELD: name of field in `node' to extract.

     DER: output array that holds DER encoding of `field' in `node'.

     LEN: output variable with length of `der' output array.

     Extract newly allocated DER representation of specified ASN.1
     field.

     *Return value:* Returns SHISHI_OK if successful, or
     SHISHI_ASN1_ERROR if DER encoding fails (common reasons for this
     is that the ASN.1 is missing required values).

shishi_asn1_to_der
------------------

 -- Function: int shishi_asn1_to_der (Shishi * HANDLE, Shishi_asn1
          NODE, char ** DER, size_t * LEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 data to convert to DER.

     DER: output array that holds DER encoding of `node'.

     LEN: output variable with length of `der' output array.

     Extract newly allocated DER representation of specified ASN.1 data.

     *Return value:* Returns SHISHI_OK if successful, or
     SHISHI_ASN1_ERROR if DER encoding fails (common reasons for this
     is that the ASN.1 is missing required values).

shishi_asn1_msgtype
-------------------

 -- Function: Shishi_msgtype shishi_asn1_msgtype (Shishi * HANDLE,
          Shishi_asn1 NODE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 type to get msg type for.

     Determine msg-type of ASN.1 type of a packet. Currently this uses
     the msg-type field instead of the APPLICATION tag, but this may be
     changed in the future.

     *Return value:* Returns msg-type of ASN.1 type, 0 on failure.

shishi_der_msgtype
------------------

 -- Function: Shishi_msgtype shishi_der_msgtype (Shishi * HANDLE, const
          char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Determine msg-type of DER coded data of a packet.

     *Return value:* Returns msg-type of DER data, 0 on failure.

shishi_der2asn1
---------------

 -- Function: Shishi_asn1 shishi_der2asn1 (Shishi * HANDLE, const char
          * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Convert arbitrary DER data of a packet to a ASN.1 type.

     *Return value:* Returns newly allocate ASN.1 corresponding to DER
     data, or `NULL' on failure.

shishi_der2asn1_padata
----------------------

 -- Function: Shishi_asn1 shishi_der2asn1_padata (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of PA-DATA and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_methoddata
--------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_methoddata (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of METHOD-DATA and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_etype_info
--------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_etype_info (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of ETYPE-INFO and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_etype_info2
---------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_etype_info2 (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of ETYPE-INFO2 and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_ticket
----------------------

 -- Function: Shishi_asn1 shishi_der2asn1_ticket (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of Ticket and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_encticketpart
-----------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_encticketpart (Shishi *
          HANDLE, const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of EncTicketPart and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_asreq
---------------------

 -- Function: Shishi_asn1 shishi_der2asn1_asreq (Shishi * HANDLE, const
          char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of AS-REQ and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_tgsreq
----------------------

 -- Function: Shishi_asn1 shishi_der2asn1_tgsreq (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of TGS-REQ and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_asrep
---------------------

 -- Function: Shishi_asn1 shishi_der2asn1_asrep (Shishi * HANDLE, const
          char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of AS-REP and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_tgsrep
----------------------

 -- Function: Shishi_asn1 shishi_der2asn1_tgsrep (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of TGS-REP and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_kdcrep
----------------------

 -- Function: Shishi_asn1 shishi_der2asn1_kdcrep (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of KDC-REP and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_encasreppart
----------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_encasreppart (Shishi *
          HANDLE, const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of EncASRepPart and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_enctgsreppart
-----------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_enctgsreppart (Shishi *
          HANDLE, const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of EncTGSRepPart and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_enckdcreppart
-----------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_enckdcreppart (Shishi *
          HANDLE, const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of EncKDCRepPart and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_authenticator
-----------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_authenticator (Shishi *
          HANDLE, const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of Authenticator and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_krberror
------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_krberror (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of KRB-ERROR and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_krbsafe
-----------------------

 -- Function: Shishi_asn1 shishi_der2asn1_krbsafe (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of KRB-SAFE and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_priv
--------------------

 -- Function: Shishi_asn1 shishi_der2asn1_priv (Shishi * HANDLE, const
          char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of KRB-PRIV and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_encprivpart
---------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_encprivpart (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of EncKrbPrivPart and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_apreq
---------------------

 -- Function: Shishi_asn1 shishi_der2asn1_apreq (Shishi * HANDLE, const
          char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of AP-REQ and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_aprep
---------------------

 -- Function: Shishi_asn1 shishi_der2asn1_aprep (Shishi * HANDLE, const
          char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of AP-REP and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_encapreppart
----------------------------

 -- Function: Shishi_asn1 shishi_der2asn1_encapreppart (Shishi *
          HANDLE, const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of EncAPRepPart and create a ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_der2asn1_kdcreq
----------------------

 -- Function: Shishi_asn1 shishi_der2asn1_kdcreq (Shishi * HANDLE,
          const char * DER, size_t DERLEN)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     DER: input character array with DER encoding.

     DERLEN: length of input character array with DER encoding.

     Decode DER encoding of AS-REQ, TGS-REQ or KDC-REQ and create a
     ASN.1 structure.

     *Return value:* Returns ASN.1 structure corresponding to DER data.

shishi_asn1_print
-----------------

 -- Function: void shishi_asn1_print (Shishi * HANDLE, Shishi_asn1
          NODE, FILE * FH)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     NODE: ASN.1 data that have field to extract.

     FH: file descriptor to print to, e.g. stdout.

     Print ASN.1 structure in human readable form, typically for
     debugging purposes.


File: shishi.info,  Node: Error Handling,  Next: Examples,  Prev: ASN.1 Functions,  Up: Programming Manual

5.17 Error Handling
===================

Most functions in `Libshishi' are returning an error if they fail.  For
this reason, the application should always catch the error condition
and take appropriate measures, for example by releasing the resources
and passing the error up to the caller, or by displaying a descriptive
message to the user and cancelling the operation.

   Some error values do not indicate a system error or an error in the
operation, but the result of an operation that failed properly.

* Menu:

* Error Values::                A list of all error values used.
* Error Functions::             Error handling related functions.


File: shishi.info,  Node: Error Values,  Next: Error Functions,  Up: Error Handling

5.17.1 Error Values
-------------------

Errors are returned as an `int'.  Except for the SHISHI_OK case, an
application should always use the constants instead of their numeric
value.  Applications are encouraged to use the constants even for
SHISHI_OK as it improves readability.  Possible values are:

`SHISHI_OK'
     This value indicates success.  The value of this error is
     guaranteed to always be `0' so you may use it in boolean
     constructs.

`SHISHI_ASN1_ERROR'
     Error in ASN.1 function (corrupt data?)

`SHISHI_FOPEN_ERROR'
     Could not open file

`SHISHI_IO_ERROR'
     File input/output error

`SHISHI_MALLOC_ERROR'
     Memory allocation error in shishi library.

`SHISHI_BASE64_ERROR'
     Base64 encoding or decoding failed. Data corrupt?

`SHISHI_REALM_MISMATCH'
     Client realm value differ between request and reply.

`SHISHI_CNAME_MISMATCH'
     Client name value differ between request and reply.

`SHISHI_NONCE_MISMATCH'
     Replay protection value (nonce) differ between request and reply.

`SHISHI_TICKET_BAD_KEYTYPE'
     Keytype used to encrypt ticket doesn't match provided key. This
     usually indicates an internal application error.

`SHISHI_CRYPTO_INTERNAL_ERROR'
     Internal error in low-level crypto routines.

`SHISHI_CRYPTO_ERROR'
     Low-level cryptographic primitive failed.  This usually indicates
     bad password or data corruption.

`SHISHI_KDC_TIMEOUT'
     Timedout talking to KDC. This usually indicates a network or KDC
     address problem.

`SHISHI_KDC_NOT_KNOWN_FOR_REALM'
     No KDC for realm known.

`SHISHI_SOCKET_ERROR'
     The system call socket() failed.  This usually indicates that your
     system does not support the socket type.

`SHISHI_BIND_ERROR'
     The system call bind() failed.  This usually indicates
     insufficient permissions.

`SHISHI_SENDTO_ERROR'
     The system call sendto() failed.

`SHISHI_CLOSE_ERROR'
     The system call close() failed.

`SHISHI_GOT_KRBERROR'
     Server replied with an error message to request.

`SHISHI_INVALID_TKTS'
     Ticketset not initialized.  This usually indicates an internal
     application error.

`SHISHI_APREQ_DECRYPT_FAILED'
     Could not decrypt AP-REQ using provided key. This usually
     indicates an internal application error.

`SHISHI_TICKET_DECRYPT_FAILED'
     Could not decrypt Ticket using provided key. This usually
     indicates an internal application error.

`SHISHI_KEYTAB_ERROR'
     Failed to parse keytab file

`SHISHI_CCACHE_ERROR'
     Failed to parse credential cache file



File: shishi.info,  Node: Error Functions,  Prev: Error Values,  Up: Error Handling

5.17.2 Error Functions
----------------------

shishi_strerror
---------------

 -- Function: const char * shishi_strerror (int ERR)
     ERR: shishi error code.

     Convert return code to human readable string.

     *Return value:* Returns a pointer to a statically allocated string
     containing a description of the error with the error value `err'.
     This string can be used to output a diagnostic message to the user.

shishi_error
------------

 -- Function: const char * shishi_error (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Extract detailed error information string.  Note that the memory is
     managed by the Shishi library, so you must not deallocate the
     string.

     *Return value:* Returns pointer to error information string, that
     must not be deallocate by caller.

shishi_error_clear
------------------

 -- Function: void shishi_error_clear (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Clear the detailed error information string.  See `shishi_error()'
     for how to access the error string, and `shishi_error_set()' and
     `shishi_error_printf()' for how to set the error string.  This
     function is mostly for Shishi internal use, but if you develop an
     extension of Shishi, it may be useful to use the same error
     handling infrastructure.

shishi_error_set
----------------

 -- Function: void shishi_error_set (Shishi * HANDLE, const char *
          ERRSTR)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     ERRSTR: Zero terminated character array containing error
     description, or NULL to clear the error description string.

     Set the detailed error information string to specified string.  The
     string is copied into the Shishi internal structure, so you can
     deallocate the string passed to this function after the call.  This
     function is mostly for Shishi internal use, but if you develop an
     extension of Shishi, it may be useful to use the same error
     handling infrastructure.

shishi_error_printf
-------------------

 -- Function: void shishi_error_printf (Shishi * HANDLE, const char *
          FORMAT, ...)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FORMAT: printf style format string.  ...: print style arguments.

     Set the detailed error information string to a printf formatted
     string.  This function is mostly for Shishi internal use, but if
     you develop an extension of Shishi, it may be useful to use the
     same error handling infrastructure.

shishi_error_outputtype
-----------------------

 -- Function: int shishi_error_outputtype (Shishi * HANDLE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     Get the current output type for logging messages.

     *Return value:* Return output type (NULL, stderr or syslog) for
     informational and warning messages.

shishi_error_set_outputtype
---------------------------

 -- Function: void shishi_error_set_outputtype (Shishi * HANDLE, int
          TYPE)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     TYPE: output type.

     Set output type (NULL, stderr or syslog) for informational and
     warning messages.

shishi_info
-----------

 -- Function: void shishi_info (Shishi * HANDLE, const char * FORMAT,
          ...)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FORMAT: printf style format string.  ...: print style arguments.

     Print informational message to output as defined in handle.

shishi_warn
-----------

 -- Function: void shishi_warn (Shishi * HANDLE, const char * FORMAT,
          ...)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FORMAT: printf style format string.  ...: print style arguments.

     Print a warning to output as defined in handle.

shishi_verbose
--------------

 -- Function: void shishi_verbose (Shishi * HANDLE, const char *
          FORMAT, ...)
     HANDLE: shishi handle as allocated by `shishi_init()'.

     FORMAT: printf style format string.  ...: print style arguments.

     Print a diagnostic message to output as defined in handle.


File: shishi.info,  Node: Examples,  Next: Kerberos Database Functions,  Prev: Error Handling,  Up: Programming Manual

5.18 Examples
=============

This section will be extended to contain walk-throughs of example code
that demonstrate how `Shishi' is used to write your own applications
that support Kerberos 5.  The rest of the current section consists of
some crude hints for the example client/server applications that is
part of Shishi, taken from an email but saved here for lack of a better
place to put it.

   There are two programs: 'client' and 'server' in src/.

   The client output an AP-REQ, waits for an AP-REP, and then simply
reads data from stdin.

   The server waits for an AP-REQ, parses it and prints an AP-REP, and
then read data from stdin.

   Both programs accept a Kerberos server name as the first command line
argument.  Your KDC must know this server, since the client tries to
get a ticket for it (first it gets a ticket granting ticket for the
default username), and you must write the key for the server into
/usr/local/etc/shishi.keys on the Shishi format, e.g.:

     -----BEGIN SHISHI KEY-----
     Keytype: 16 (des3-cbc-sha1-kd)
     Principal: sample/latte.josefsson.org
     Realm: JOSEFSSON.ORG

     8W0VrQQBpxlACPQEqN91EHxbvFFo2ltt
     -----END SHISHI KEY-----

   You must extract the proper encryption key from the KDC in some way.
(This part will be easier when Shishi include a KDC, a basic one isn't
far away, give me a week or to.)

   The intention is that the data read, after the authentication phase,
should be protected using KRB_SAFE (see RFC) but I haven't added this
yet.


File: shishi.info,  Node: Kerberos Database Functions,  Next: Generic Security Service,  Prev: Examples,  Up: Programming Manual

5.19 Kerberos Database Functions
================================

Shisa is a separate and standalone library from Shishi (*note
Introduction to Shisa::).  If you only wish to manipulate the
information stored in the Kerberos user database used by Shishi, you do
not need to link or use the Shishi library at all.  However, you may
find it useful to combine the two libraries.

   For two real world examples on using the Shisa library, refer to
`src/shisa.c' (Shisa command line tool) and `src/kdc.c' (part of
Shishid server).

   Shisa uses two `struct's to carry information.  The first,
`Shisa_principal', is used to hold information about principals.  The
struct does not contain pointers to strings etc, so the library assumes
the caller is responsible for allocating and deallocating the struct
itself.  Each such struct is (uniquely) identified by the combination
of principal name and realm name.

     struct Shisa_principal
     {
       int isdisabled;
       uint32_t kvno;
       time_t notusedbefore;
       time_t lastinitialtgt;      /* time of last initial request for a TGT */
       time_t lastinitialrequest;  /* time of last initial request */
       time_t lasttgt;             /* time of issue for the newest TGT used */
       time_t lastrenewal;         /* time of the last renewal */
       time_t passwordexpire;      /* time when the password will expire */
       time_t accountexpire;       /* time when the account will expire. */
     };
     typedef struct Shisa_principal Shisa_principal;

   The second structure is called `Shisa_key' and hold information
about cryptographic keys.  Because the struct contain pointers, and the
caller cannot know how many keys a principal have, the Shisa library
manages memory for the struct.  The library allocate the structs, and
the pointers within them.  The caller may deallocate them, but it is
recommended to use `shisa_key_free' or `shisa_keys_free' instead.  Note
that each principal may have multiple keys.

     struct Shisa_key
     {
       uint32_t kvno;
       int32_t etype;
       int priority;
       char *key;
       size_t keylen;
       char *salt;
       size_t saltlen;
       char *str2keyparam;
       size_t str2keyparamlen;
       char *password;
     };
     typedef struct Shisa_key Shisa_key;

   Shisa is typically initialized by calling `shisa_init', and
deinitialized (when the application no longer need to use Shisa,
typically when it shuts down) by calling `shisa_done', but here are the
complete (de)initialization interface functions.

shisa
-----

 -- Function: Shisa * shisa ( VOID)
     Initializes the Shisa library.  If this function fails, it may
     print diagnostic errors to stderr.

     *Return value:* Returns Shisa library handle, or `NULL' on error.

shisa_done
----------

 -- Function: void shisa_done (Shisa * DBH)
     Deallocates the shisa library handle.  The handle must not be used
     in any calls to shisa functions after this.

shisa_init
----------

 -- Function: int shisa_init (Shisa ** DBH)
     DBH: pointer to library handle to be created.

     Create a Shisa library handle, using `shisa()', and read the system
     configuration file from their default locations.  The paths to the
     default system configuration file is decided at compile time
     ($sysconfdir/shisa.conf).

     The handle is allocated regardless of return values, except for
     SHISA_INIT_ERROR which indicates a problem allocating the handle.
     (The other error conditions comes from reading the files.)

     *Return value:* Returns `SHISA_OK' iff successful.

shisa_init_with_paths
---------------------

 -- Function: int shisa_init_with_paths (Shisa ** DBH, const char *
          FILE)
     DBH: pointer to library handle to be created.

     FILE: Filename of system configuration, or NULL.

     Create a Shisa library handle, using `shisa()', and read the system
     configuration file indicated location (or the default location, if
     `NULL').  The paths to the default system configuration file is
     decided at compile time ($sysconfdir/shisa.conf).

     The handle is allocated regardless of return values, except for
     SHISA_INIT_ERROR which indicates a problem allocating the handle.
     (The other error conditions comes from reading the files.)

     *Return value:* Returns `SHISA_OK' iff successful.

   The default configuration file is typically read automatically by
calling `shisa_init', but if you wish to manually access the Shisa
configuration file functions, here is the complete interface.

shisa_cfg_db
------------

 -- Function: int shisa_cfg_db (Shisa * DBH, const char * VALUE)
     DBH: Shisa library handle created by `shisa()'.

     VALUE: string with database definition.

     Setup and open a new database.  The syntax of the `value' parameter
     is "TYPE[ LOCATION[ PARAMETER]]", where TYPE is one of the
     supported database types (e.g., "file") and LOCATION and PARAMETER
     are optional strings passed to the database during initialization.
     Neither TYPE nor LOCATION can contain " " (SPC), but PARAMETER may.

     *Return Value:* Returns `SHISA_OK' if database was parsed and open
     successfully.

shisa_cfg
---------

 -- Function: int shisa_cfg (Shisa * DBH, const char * OPTION)
     DBH: Shisa library handle created by `shisa()'.

     OPTION: string with shisa library option.

     Configure shisa library with given option.

     *Return Value:* Returns SHISA_OK if option was valid.

shisa_cfg_from_file
-------------------

 -- Function: int shisa_cfg_from_file (Shisa * DBH, const char * CFG)
     DBH: Shisa library handle created by `shisa()'.

     CFG: filename to read configuration from.

     Configure shisa library using configuration file.

     *Return Value:* Returns `SHISA_OK' iff succesful.

shisa_cfg_default_systemfile
----------------------------

 -- Function: const char * shisa_cfg_default_systemfile (Shisa * DBH)
     DBH: Shisa library handle created by `shisa()'.

     *Return value:* Return system configuration filename.

   The core part of the Shisa interface follows.  The typical procedure
is to use `shisa_principal_find' to verify that a specific principal
exists, and to extract some information about it, and then use
`shisa_keys_find' to get the cryptographic keys for the principal,
usually suppliying some hints as to which of all keys you are
interested in (e.g., key version number and encryption algorithm
number).

shisa_enumerate_realms
----------------------

 -- Function: int shisa_enumerate_realms (Shisa * DBH, char *** REALMS,
          size_t * NREALMS)
     DBH: Shisa library handle created by `shisa()'.

     REALMS: Pointer to newly allocated array of newly allocated
     zero-terminated UTF-8 strings indicating name of realm.

     NREALMS: Pointer to number indicating number of allocated realm
     strings.

     Extract a list of all realm names in backend, as zero-terminated
     UTF-8 strings.  The caller must deallocate the strings.

     *Return value:* Returns SHISA_OK on success, or error code.

shisa_enumerate_principals
--------------------------

 -- Function: int shisa_enumerate_principals (Shisa * DBH, const char *
          REALM, char *** PRINCIPALS, size_t * NPRINCIPALS)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm, as zero-terminated UTF-8 string.

     NPRINCIPALS: Pointer to number indicating number of allocated
     realm strings.

     Extract a list of all principal names in realm in backend, as
     zero-terminated UTF-8 strings.  The caller must deallocate the
     strings.

     *Return value:* Returns SHISA_OK on success, SHISA_NO_REALM if the
     specified realm does not exist, or error code.

shisa_principal_find
--------------------

 -- Function: int shisa_principal_find (Shisa * DBH, const char *
          REALM, const char * PRINCIPAL, Shisa_principal * PH)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm the principal belongs in.

     PRINCIPAL: Name of principal to get information on.

     PH: Pointer to previously allocated principal structure to fill
     out with information about principal.

     Extract information about given PRINCIPAL`REALM'.

     *Return value:* Returns `SHISA_OK' iff successful,
     `SHISA_NO_REALM' if the indicated realm does not exist,
     `SHISA_NO_PRINCIPAL' if the indicated principal does not exist, or
     an error code.

shisa_principal_update
----------------------

 -- Function: int shisa_principal_update (Shisa * DBH, const char *
          REALM, const char * PRINCIPAL, const Shisa_principal * PH)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm the principal belongs in.

     PRINCIPAL: Name of principal to get information on.

     PH: Pointer to principal structure with information to store in
     database.

     Modify information stored for given PRINCIPAL`REALM'.  Note that it
     is usually a good idea to only set the fields in `ph' that you
     actually want to update.  Specifically, first calling
     `shisa_principal_find()' to get the current information, then
     modifying one field, and calling `shisa_principal_update()' is not
     recommended in general, as this will 1) overwrite any modifications
     made to other fields between the two calls (by other processes) and
     2) will cause all values to be written again, which may generate
     more overhead.

     *Return value:* Returns SHISA_OK if successful, `SHISA_NO_REALM' if
     the indicated realm does not exist, `SHISA_NO_PRINCIPAL' if the
     indicated principal does not exist, or an error code.

shisa_principal_add
-------------------

 -- Function: int shisa_principal_add (Shisa * DBH, const char * REALM,
          const char * PRINCIPAL, const Shisa_principal * PH, const
          Shisa_key * KEY)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm the principal belongs in.

     PRINCIPAL: Name of principal to add, may be `NULL' to indicate that
     the `realm' should be created, in which case `ph' and `key' are
     not used.

     PH: Pointer to principal structure with information to store in
     database.

     KEY: Pointer to key structure with information to store in
     database.

     Add given information to database as PRINCIPAL`REALM'.

     *Return value:* Returns SHISA_OK iff successfully added, or an
     error code.

shisa_principal_remove
----------------------

 -- Function: int shisa_principal_remove (Shisa * DBH, const char *
          REALM, const char * PRINCIPAL)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm the principal belongs in.

     PRINCIPAL: Name of principal to remove, may be `NULL' to indicate
     that the `realm' itself should be removed (requires that the realm
     to be empty).

     Remove all information stored in the database for given
     PRINCIPAL`REALM'.

     *Return value:* Returns `SHISA_OK' if successful, or an error code.

shisa_keys_find
---------------

 -- Function: int shisa_keys_find (Shisa * DBH, const char * REALM,
          const char * PRINCIPAL, const Shisa_key * HINT, Shisa_key ***
          KEYS, size_t * NKEYS)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm the principal belongs in.

     PRINCIPAL: Name of principal to add key for.

     HINT: Pointer to Shisa key structure with hints on matching the key
     to modify, may be `NULL' to match all keys.

     KEYS: pointer to newly allocated array with Shisa key structures.

     NKEYS: pointer to number of newly allocated Shisa key structures
     in `keys'.

     Iterate through keys for given PRINCIPAL`REALM' and extract any
     keys that match `hint'.  Not all elements of `hint' need to be
     filled out, only use the fields you are interested in.  For
     example, if you want to extract all keys with an etype of 3
     (DES-CBC-MD5), set the `key'->etype field to 3, and set all other
     fields to 0.

     *Return value:* Returns `SHISA_OK' iff successful, or an error
     code.

shisa_key_add
-------------

 -- Function: int shisa_key_add (Shisa * DBH, const char * REALM, const
          char * PRINCIPAL, const Shisa_key * KEY)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm the principal belongs in.

     PRINCIPAL: Name of principal to add key for.

     KEY: Pointer to Shisa key structure with key to add.

     Add key to database for given PRINCIPAL`REALM'.

     *Return value:* Returns `SHISA_OK' iff successful, or an error
     code.

shisa_key_update
----------------

 -- Function: int shisa_key_update (Shisa * DBH, const char * REALM,
          const char * PRINCIPAL, const Shisa_key * OLDKEY, const
          Shisa_key * NEWKEY)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm the principal belongs in.

     PRINCIPAL: Name of principal to remove key for.

     OLDKEY: Pointer to Shisa key structure with hints on matching the
     key to modify.

     NEWKEY: Pointer to Shisa key structure with new values for the
     key, note that all fields are used (and not just the ones specified
     by `oldkey').

     Modify data about a key in the database, for the given
     PRINCIPAL`REALM'.  First the `oldkey' is used to locate the key to
     update (similar to `shisa_keys_find()'), then that key is modified
     to contain whatever information is stored in `newkey'.  Not all
     elements of `oldkey' need to be filled out, only enough as to
     identify the key uniquely.  For example, if you want to modify the
     information stored for the only key with an etype of 3
     (DES-CBC-MD5), set the `key'->etype field to 3, and set all other
     fields to 0.

     *Return value:* Returns `SHISA_OK' on success, `SHISA_NO_KEY' if
     no key could be identified, and `SHISA_MULTIPLE_KEY_MATCH' if more
     than one key matched the given criteria, or an error code.

shisa_key_remove
----------------

 -- Function: int shisa_key_remove (Shisa * DBH, const char * REALM,
          const char * PRINCIPAL, const Shisa_key * KEY)
     DBH: Shisa library handle created by `shisa()'.

     REALM: Name of realm the principal belongs in.

     PRINCIPAL: Name of principal to remove key for.

     KEY: Pointer to Shisa key structure with hints on matching the key
     to remove.

     Remove a key, matching the hints in `key', from the Shisa database
     for the user PRINCIPAL`REALM'.  Not all elements of `key' need to
     be filled out, only those you are interested in.  For example, if
     you want to remove the only key with an etype of 3 (DES-CBC-MD5),
     set the `key'->etype field to 3, and set all other fields to 0.

     *Return value:* Returns `SHISA_OK' on success, `SHISA_NO_KEY' if
     no key could be identified, and `SHISA_MULTIPLE_KEY_MATCH' if more
     than one key matched the given criteria, or an error code.

shisa_key_free
--------------

 -- Function: void shisa_key_free (Shisa * DBH, Shisa_key * KEY)
     DBH: Shisa library handle created by `shisa()'.

     KEY: Pointer to Shisa key structure to deallocate.

     Deallocate the fields of a Shisa key structure, and the structure
     itself.

shisa_keys_free
---------------

 -- Function: void shisa_keys_free (Shisa * DBH, Shisa_key ** KEYS,
          size_t NKEYS)
     DBH: Shisa library handle created by `shisa()'.

     KEYS: Pointer to array with `nkeys' elements of keys.

     NKEYS: Number of key elements in `keys' array.

     Deallocate each element of an array with Shisa database keys, using
     `shisa_key_free()'.

   Error handling is similar to that for Shishi in general (*note Error
Handling::), i.e., you invoke `shisa_strerror' on the integer return
value received by some function, if the return value is non-zero.
Below is the complete interface.

shisa_strerror
--------------

 -- Function: const char * shisa_strerror (int ERR)
     ERR: shisa error code

     *Return value:* Returns a pointer to a statically allocated string
     containing a description of the error with the error value `err'.
     This string can be used to output a diagnostic message to the user.

shisa_info
----------

 -- Function: void shisa_info (Shisa * DBH, const char * FORMAT, ...)
     DBH: Shisa library handle created by `shisa()'.

     FORMAT: printf style format string.  ...: print style arguments.

     Print informational message to standard error.


File: shishi.info,  Node: Generic Security Service,  Prev: Kerberos Database Functions,  Up: Programming Manual

5.20 Generic Security Service
=============================

As an alternative to the native Shishi programming API, it is possible
to program Shishi through the Generic Security Services (GSS) API.  The
advantage of using GSS-API in your security application, instead of the
native Shishi API, is that it will be easier to port your application
between different Kerberos 5 implementations, and even beyond Kerberos
5 to different security systems, that support GSS-API.  In the free
software world, however, almost the only widely used security system
that supports GSS-API is Kerberos 5, so the last advantage is somewhat
academic.  But if you are porting applications using GSS-API for other
Kerberos 5 implementations, or want a more mature and stable API than
the native Shishi API, you may find using Shishi's GSS-API interface
compelling.  Note that GSS-API only offer basic services, for more
advanced uses you must use the native API.

   Since the GSS-API is not specific to Shishi, it is distributed
independently from Shishi.  Further information on the GSS project can
be found at `http://www.gnu.org/software/gss/'.


File: shishi.info,  Node: Acknowledgements,  Next: Criticism of Kerberos,  Prev: Programming Manual,  Up: Top

6 Acknowledgements
******************

Shishi uses Libtasn1 by Fabio Fiorina, Libgcrypt and Libgpg-error by
Werner Koch, Libidn by Simon Josefsson, cvs2cl by Karl Fogel, and gdoc
by Michael Zucchi.

   Several GNU packages simplified development considerably, those
packages include Autoconf, Automake, Libtool, Gnulib, Gettext, Indent,
CVS, Texinfo, Help2man and Emacs.

   Several people reported bugs, sent patches or suggested improvements,
see the file THANKS.

   Nicolas Pouvesle wrote the section about the Kerberos rsh/rlogin
protocol.

   This manual borrows text from the Kerberos 5 specification.


File: shishi.info,  Node: Criticism of Kerberos,  Next: Protocol Extensions,  Prev: Acknowledgements,  Up: Top

Appendix A Criticism of Kerberos
********************************

The intention with this section is to discuss various problems with
Kerberos 5, so you can form a conscious decision how to deploy and use
Shishi correctly in your organization.  Currently the issues below are
condensed, and mostly serve as a reminder for the author to elaborate
on them.

   No encryption scheme with security proof.

   No standardized API, and GSS mechanism lack important functionality.

   Lack of authorization system.  (krb5_kuserok())

   Host to realm mapping relies on insecure DNS or static configuration
files.

   Informational model and user database administration.

   Non-formal specification.  Unclear on the etype to use for session
keys (etype in request or database?).  Unclear on how to populate some
"evident" fields (e.g., cname in tickets for AS-REQ, or crealm, cname,
realm, sname, ctime and cusec in KRB-ERROR).  Unclear error code
semantics (e.g., logic for when to use S_PRINCIPAL_UNKNOWN absent).
Some KRB-ERROR fields are required, but can't be usefully populated in
some situations, and no guidance is given on what they should contain.

   RFC 1510/1510bis incompatibilities.  NULL enctype removed without
discussion, and it is still used by some 1964 GSSAPI implementations.
KRB_SAFE text (3.4.1) says the checksum is generated using the session
or sub-session key, which contradicts itself (compare section 3.2.6)
and also RFC 1510, which both allow the application to define the key.
Verification of KRB_SAFE now require the key to be compatible with the
(sub-)session key, in 1510 the only requirement was that it was
collision proof.

   Problems with RFC 1510bis.  Uses bignum INTEGER for TYPED-DATA and
AD-AND-OR.

   Problems with crypto specification.  It uses the word "random" many
times, but there is no discussion on the randomness requirements.
Practical experience indicate it is impossible to use true randomness
for all "random" fields, and no implementation does this.  A post by
Don Davis on the ietf-krb-wg list tried to provide insight, but the
information was never added to the specification.


File: shishi.info,  Node: Protocol Extensions,  Next: Copying Information,  Prev: Criticism of Kerberos,  Up: Top

Appendix B Protocol Extensions
******************************

This appendix specifies the non-standard protocol elements implemented
by Shishi.  By nature of being non-standard, everything described here
is experimental.  Comments and feedback is appreciated.

* Menu:

* STARTTLS protected KDC exchanges::	How Shishi talks to KDC protected by TLS.
* Telnet encryption with AES-CCM::      Integrity and privacy protected telnet.
* Kerberized rsh and rlogin::           Description of KCMD protocol.
* Key as initialization vector::        Some cryptography discussion.
* The Keytab Binary File Format::       Format of keytab files.
* The Credential Cache Binary File Format:: Format of ccache files.


File: shishi.info,  Node: STARTTLS protected KDC exchanges,  Next: Telnet encryption with AES-CCM,  Up: Protocol Extensions

B.1 STARTTLS protected KDC exchanges
====================================

Shishi is able to "upgrade" TCP communications with the KDC to use the
Transport Layer Security (TLS) protocol.  The TLS protocol offers
integrity and privacy protected exchanges.  TLS also offers
authentication using username and passwords, X.509 certificates, or
OpenPGP certificates.  Kerberos 5 claims to offer some of these
features, although it is not as rich as the TLS protocol.  An
inconclusive list of the motivation for using TLS is given below.

   * Server authentication of the KDC to the client.  In traditional
     Kerberos 5, KDC authentication is only proved as a side effect
     that the KDC knows your encryption key (i.e., your password).

   * Client authentication against KDC.  Kerberos 5 assume the user
     knows a key (usually in the form of a password).  Sometimes
     external factors make this hard to fulfill.  In some situations,
     users are equipped with smart cards with a RSA authentication key.
     In others, users have a OpenPGP client on their desktop, with a
     public OpenPGP key known to the server.  In some situations, the
     policy may be that password authentication may only be done
     through SRP.

   * Kerberos exchanges are privacy protected.  Part of many Kerberos
     packets are transfered without privacy protection (i.e.,
     encryption).  That part contains information, such as the client
     principal name, the server principal name, the encryption types
     supported by the client, the lifetime of tickets, etc.  Revealing
     such information is, in some threat models, considered a problem.
     Thus, this enables "anonymity".

   * Prevents downgrade attacks affecting encryption types.  The
     encryption type of the ticket in KDC-REQ are sent in the clear in
     Kerberos 5.  This allows an attacker to replace the encryption type
     with a compromised mechanisms, e.g. 56-bit DES.  Since clients in
     general cannot know the encryption types other servers support, it
     is difficult for the client to detect if there was a
     man-in-the-middle or if the remote server simply did not support a
     stronger mechanism.  Clients may chose to refuse 56-bit DES
     altogether, but in some environments this leads to operational
     difficulties.

   * TLS is well-proved and the protocol is studied by many parties.
     This is an advantage in network design, where TLS is often already
     assumed as part of the solution since it is used to protect HTTP,
     IMAP, SMTP etc.  In some threat models, the designer prefer to
     reduce the number of protocols that can hurt the overall system
     security if they are compromised.


   Other reasons for using TLS exists.

B.1.1 TCP/IP transport with TLS upgrade (STARTTLS)
--------------------------------------------------

RFC 1510bis requires Kerberos servers (KDCs) to accept TCP requests.
Each request and response is prefixed by a 4 octet integer in network
byte order, indicating the length of the packet.  The high bit of the
length was reserved for future expansion, and servers that do not
understand how to interpret a set high bit must return a `KRB-ERROR'
with a `KRB_ERR_FIELD_TOOLONG' and close the TCP stream.

   The TCP/IP transport with TLS upgrade (STARTTLS) uses this reserved
bit as follows.  First we define a new extensible typed hole for
Kerberos 5 messages, because we used the only reserved bit.  It is thus
prudent to offer future extensions on our proposal.  Secondly we
reserve two values in this new typed hole, and described how they are
used to implement STARTTLS.

B.1.2 Extensible typed hole based on reserved high bit
------------------------------------------------------

When the high bit is set, the remaining 31 bits of the 4 octets are
treated as an extensible typed hole, and thus form a 31 bit integer
enumerating various extensions.  Each of the values indicate a specific
extended operation mode, two of which are used and defined here, and
the rest are left for others to use.  If the KDC do not understand a
requested extension, it MUST return a `KRB-ERROR' with a
`KRB_ERR_FIELD_TOOLONG' value (prefixed by the 4 octet length integer,
with the high bit clear, as usual) and close the TCP stream.

   Meaning of the 31 lower bits in the 4 octet field, when the high bit
is set:

 0               RESERVED.
 1               STARTTLS requested by client.
 2               STARTTLS request accepted by server.
 3...2147483647  AVAILABLE for registration (via bug-shishi@josefsson.org).
 2147483648      RESERVED.

B.1.3 STARTTLS requested by client (extension mode 1)
-----------------------------------------------------

When this is sent by the client, the client is requesting the server to
start TLS negotiation on the TCP stream.  The client MUST NOT start TLS
negotiation immediately.  Instead, the client wait for either a
KRB-ERROR (sent normally, prefixed by a 4 octet length integer)
indicating the server do not understand the set high bit, or 4 octet
which is to interpreted as an integer in network byte order, where the
high bit is set and the remaining 31 bit are interpreted as an integer
specifying the "STARTTLS request accepted by server".  In the first
case, the client infer that the server do not understand (or wish to
support) STARTTLS, and can re-try using normal TCP, if unprotected
Kerberos 5 exchanges are acceptable to the client policy.  In the
latter case, it should invoke TLS negotiation on the stream.  If any
other data is received, the client MUST close the TCP stream.

B.1.4 STARTTLS request accepted by server (extension mode 2)
------------------------------------------------------------

This 4 octet message should be sent by the server when it has received
the previous 4 octet message.  The message is an acknowledgment of the
client's request to initiate STARTTLS on the channel.  The server MUST
then invoke a TLS negotiation.

B.1.5 Proceeding after successful TLS negotiation
-------------------------------------------------

If the TLS negotiation ended successfully, possibly also considering
client or server policies, the exchange within the TLS protected stream
is performed like normal UDP Kerberos 5 exchanges, i.e., there is no
TCP 4 octet length field before each packet.  Instead each Kerberos
packet MUST be sent within one TLS record, so the application can use
the TLS record length as the Kerberos 5 packet length.

B.1.6 Proceeding after failed TLS negotiation
---------------------------------------------

If the TLS negotiation fails, possibly due to client or server policy
(e.g., inadequate support of encryption types in TLS, or lack of client
or server authentication) the entity that detect the failure MUST
disconnected the connection.  It is expected that any error messages
that explain the error condition is transfered by TLS.

B.1.7 Interaction with KDC addresses in DNS
-------------------------------------------

Administrators for a KDC may announce the KDC address by placing SRV
records in DNS for the realm, as described in
`draft-ietf-krb-wg-krb-dns-locate-03.txt'.  That document mention TLS,
but do not reference any work that describe how KDCs uses TLS.  Until
further clarified, consider the TLS field in that document to refer to
implementation supporting this STARTTLS protocol.

B.1.8 Using TLS authentication logic in Kerberos
------------------------------------------------

The server MAY consider the authentication performed by the TLS
exchange as sufficient to issue Kerberos 5 tickets to the client,
without requiring, e.g., pre-authentication.  However, it is not an
error to require or use pre-authentication as well.

   The client may also indicate that it wishes to use TLS both for
authentication and data protection by using the `NULL' encryption type
in its request.  The server can decide from its local policy whether or
not issuing tickets based solely on TLS authentication, and whether
`NULL' encryption within TLS, is acceptable or not.  This mode is
currently under investigation.

B.1.9 Security considerations
-----------------------------

Because the initial token is not protected, it is possible for an
active attacker to make it appear to the client that the server do not
support this extension.  It is up to client configuration to disallow
non-TLS connections, if this vulnerability is deemed unacceptable.  For
interoperability, we suggest the default behaviour should be to allow
automatic fallback to TCP or UDP.

   The security considerations of both TLS and Kerberos 5 are inherited.
Using TLS for authentication and/or data protection together with
Kerberos alter the authentication logic fundamentally.  Thus, it may be
that even if the TLS and Kerberos 5 protocols and implementations were
secure, the combination of TLS and Kerberos 5 described here could be
insecure.

   No channel bindings are provided in the Kerberos messages.  It is an
open question whether, and how, this should be fixed.


File: shishi.info,  Node: Telnet encryption with AES-CCM,  Next: Kerberized rsh and rlogin,  Prev: STARTTLS protected KDC exchanges,  Up: Protocol Extensions

B.2 Telnet encryption with AES-CCM
==================================

This appendix describe how Shishi use the Advanced Encryption Standard
(AES) encryption algorithm in Counter with CBC-MAC mode (RFC 3610) with
the telnet encryption option (RFC 2946).

B.2.1 Command Names and Codes
-----------------------------

Encryption Type

      AES_CCM             12

Suboption Commands

      AES_CCM_INFO         1
      AES_CCM_INFO_OK      2
      AES_CCM_INFO_BAD     3

B.2.2 Command Meanings
----------------------

   IAC SB ENCRYPT IS AES_CCM AES_CCM_INFO <M> <L> <nonce> IAC SE

The sender of this command select desired M and L parameters, and
nonce, as described in RFC 3610, and sends it to the other side of the
connection.  The parameters and the nonce are sent in clear text.  Only
the side of the connection that is WILL ENCRYPT may send the
AES_CCM_INFO command.

   IAC SB ENCRYPT REPLY AES_CCM AES_CCM_INFO_BAD IAC SE

   The sender of this command reject the parameters received in the
AES_CCM_INFO command.  Only the side of the connection that is DO
ENCRYPT may send the AES_CCM_INFO_BAD command.  The command MUST be
sent if the nonce field length does not match the selected value for L.
The command MAY be sent if the receiver do not accept the parameters
for reason such as policy.  No capability is provided to negotiate
these parameters.

   IAC SB ENCRYPT REPLY AES_CCM AES_CCM_INFO_OK IAC SE

   The sender of this command accepts the parameters received in the
AES_CCM_INFO command.  Only the side of the connection that is DO
ENCRYPT may send the AES_CCM_INFO_BAD command.  The command MUST NOT be
sent if the nonce field length does not match the selected value for L.

B.2.3 Implementation Rules
--------------------------

Once a AES_CCM_INFO_OK command has been received, the WILL ENCRYPT side
of the connection should do keyid negotiation using the ENC_KEYID
command.  Once the keyid negotiation has successfully identified a
common keyid, then START and END commands may be sent by the side of
the connection that is WILL ENCRYPT.  Data will be encrypted using the
AES-CCM algorithm, with the negotiated nonce and parameters M and L.
After each successful encryption and decryption, the nonce is treated
as an integer in network byte order, and incremented by one.

   If encryption (decryption) is turned off and back on again, and the
same keyid is used when re-starting the encryption (decryption), the
intervening clear text must not change the state of the encryption
(decryption) machine.  In particular, the AES-CCM nonce must not be
re-set.

   If a START command is sent (received) with a different keyid, the
encryption (decryption) machine must be re-initialized immediately
following the end of the START command with the new key and the
parameters sent (received) in the last AES_CCM_INFO command.

   If a new AES_CCM_INFO command is sent (received), and encryption
(decryption) is enabled, the encryption (decryption) machine must be
re-initialized immediately following the end of the AES_CCM_INFO
command with the new nonce and parameters, and the keyid sent
(received) in the last START command.

   If encryption (decryption) is not enabled when a AES_CCM_INFO command
is sent (received), the encryption (decryption) machine must be re-
initialized after the next START command, with the keyid sent
(received) in that START command, and the nonce and parameters sent
(received) in this AES_CCM_INFO command.

   At all times MUST each end make sure that a AES-CCM nonce is not used
twice under the same encryption key.  The rules above help accomplish
this in an interoperable way.

B.2.4 Integration with the AUTHENTICATION telnet option
-------------------------------------------------------

<<This section is slightly complicated.  Can't we simplify this?>>

   As noted in the telnet ENCRYPTION option specifications, a keyid
value of zero indicates the default encryption key, as might be derived
from the telnet AUTHENTICATION option.  If the default encryption key
negotiated as a result of the telnet AUTHENTICATION option contains
less than 32 bytes (corresponding to two 128 bit keys), then the
AES_CCM option MUST NOT be offered or used as a valid telnet encryption
option.  Furthermore, depending on policy for key lengths, the AES_CCM
option MAY be disabled if the default encryption key contain less than
48 bytes (for two 192 bit keys), or less than 64 bytes (for two 256 bit
keys), as well.

   The available encrypt key data is divided on two halves, where the
first half is used to encrypt data sent from the server (decrypt data
received by the client), and the second half is used to encrypt data
sent from the client (decrypt data received by the server).

   Note that the above algorithm assumes that the AUTHENTICATION
mechanism generate keying material suitable for AES-CCM as used in this
specification.  This is not necessarily true in general, but we specify
this behaviour as the default since it is true for most authentication
systems in popular use today.  New telnet AUTHENTICATION mechanisms may
specify alternative methods for determining the keys to be used for
this cipher suite in their specification, if the session key negotiated
by that authentication mechanism is not a DES key and and where this
algorithm may not be safely used.

   Kerberos 5 authentication clarification: The key used to encrypt data
from the client to the server is taken from the sub-session key in the
AP-REQ.  The key used to decrypt data from the server to the client is
taken from the sub-session key in the AP-REP.  If mutual authentication
is not negotiated, the key used to encrypt data from the client to the
server is taken from the session key in the ticket, and the key used to
decrypt data from the server to the client is taken from the
sub-session key in the AP-REQ.  Leaving the AP-REQ sub-key field empty
MUST disable the AES_CCM option.

B.2.5 Security Considerations
-----------------------------

The protocol must be properly and securely implemented.  For example,
an implementation should not be vulnerable to various
implementation-specific attacks such as buffer overflows or
side-channel analysis.

   We wish to repeat the suggestion from RFC 2946, to investigate in a
STARTTLS approach for Telnet encryption (and also authentication), when
the security level provided by this specification is not adequate.

B.2.5.1 Telnet Encryption Protocol Security Considerations
..........................................................

The security consideration of the Telnet encryption protocol are
inherited.

   It should be noted that the it is up to the authentication protocol
used, if any, to bind the authenticity of the peers to a specific
session.

   The Telnet encryption protocol does not, in general, protect against
possibly malicious downgrading to any mutually acceptable, but not
preferred, encryption type.  This places a requirement on each peer to
only accept encryption types it trust fully.  In other words, the
Telnet encryption protocol do not guarantee that the strongest mutually
acceptable encryption type is always selected.

B.2.5.2 AES-CCM Security Considerations
.......................................

The integrity and privacy claims are inherited from AES-CCM.  In
particular, the implementation must make sure a nonce is not used more
than once together with the same key.

   Furthermore, the encryption key is assumed to be random, i.e., it
should not be possible to guess it with probability of success higher
than guessing any uniformly selected random key.  RFC 1750 gives an
overview of issues and recommendations related to randomness.

B.2.6 Acknowledgments
---------------------

This document is based on the various Telnet Encryption RFCs (RFC 2946,
RFC 2947, RFC 2948, RFC 2952 and RFC 2953).


File: shishi.info,  Node: Kerberized rsh and rlogin,  Next: Key as initialization vector,  Prev: Telnet encryption with AES-CCM,  Up: Protocol Extensions

B.3 Kerberized rsh and rlogin
=============================

This appendix describe the KCMDV0.2 protocol used in shishi patched
version of inetutils. The KCMD protocol was developped by the MIT
Kerberos team for kerberized rsh an rlogin programs. Differences
between rlogin an rsh will be explained, like those between v0.1 and
v0.2 of the protocol for compatibility reasons.  It is possible that
some parts of this document are not in conformity with original KCMD
protocol because there is no official specification about it. However,
it seems that shishi implementation is compatible with MIT's one.

   *Warning:* If you are seriously considering using Kerberos rsh or
rlogin, instead of more robust remote access protocols such as SSH, you
may first want to explore
`http://www.cs.berkeley.edu/~hildrum/kerberos/' and the full paper at
`http://www.cs.berkeley.edu/~hildrum/043.pdf'.

B.3.1 Establish connection
--------------------------

First the client should establish a TCP connection with the server.
Default ports are 543 (klogin), 544 (kshell), 2105 (eklogin).  eklogin
is the same as klogin but with encryption. Their is no longer ekshell
port because encrypted and normal connection use the same port (kshell).
Kshell need a second connection for stderr. The client should send a
null terminated string that represent the port of this second
connection.  Klogin and eklogin does not use a second connection for
stderr so the client must send a null byte to the server.  Contrary to
classic rsh/rlogin, server must not check if the client port is in the
range 0-1023.

B.3.2 Kerberos identification
-----------------------------

When connections are established, first thing to do is to indicate
kerberos authentication must be used.  So the client will send a string
to indicate it will used kerberos 5. It will call a length-string
"strl" the couple (lenght of the string strl, null terminated string
strl). Length of the string is an int32 (32bits int) in MSB order (for
the network).  So the client send this length-string strl :

   KRB5_SENDAUTH_V1.0

   After that the client must indicate which version of the protocol it
will used by sending this length-string strl :

   KCMDV0.2

   It can be V0.1 for older versions.  If indentification from client
is good, server will send a null byte (0x00). Else if authentication
message is wrong, server send byte 0x01, else if protocol version
message is wrong server send byte 0x02.

B.3.3 Kerberos authentication
-----------------------------

When client is indentified, kerberos authentication can begin. The
client must send an AP-REQ to the server. AP-REQ authenticator must
have a subkey (only for KCMDV0.2) and a checksum.  Authenticator
checksum is created on following string :

     "serverport:""terminaltype""remoteusername"

   for example :

     543:linux/38400user

   remoteusername corresponds to the identity of the client on remote
machine.

   AP-REQ is sended in der encoded format. The length (int32) of der
encoded AP-REQ is sended in network format (MSB), following by the der
encoded AP-REQ.  If all is correct, server send a null int32 (MSB
format but like it is null it is not important).  KCMD protocol use
mutual authentication, so server must now send and AP-REP : (in32
lenght in MSB of der encoded AP-REP)(der encoded AP-REP).

   Now server and client are partially authenticated.

B.3.4 Extended authentication
-----------------------------

Client must now send 3 different null terminated strings (without
lenght) :

   * remote user name (user identity on remote machine)

   * terminal type for rlogin or command for rsh

   * local user name (user identity on client machine)

   example for rsh :

     "rname\0"
     "cat /usr/local/etc/shishi.conf"
     "lname\0"

   Server must verify that checksum in AP-REQ authenticator is correct
by computing a new hash like client has done.

   Server must verify that principal (in AP-REQ) has right to log in on
the remote user account.  For the moment shishi only check if remote
user name is equal to principal. A more complex authorization code is
planned.  Look at the end to know how MIT/Heimdal do to check
authorization.

   If all is correct server send a null byte, else an error message
string (null terminated string) is sent. User read the first byte. If
it is equal to zero, authentication is correct and is logged on the
remote host. Else user can read the error messsage send by the server.

B.3.5 Window size
-----------------

For rlogin protocol, when authentication is complete, the server can
optionnaly send a message to ask for window terminal size of user. Then
the user can respond but it is not an obligation.

   In KCMDV0.1 server send an urgent TCP message (MSG_OOB) with one byte
:

     TIOCPKT_WINDOW = 0x80

   In KCMDV0.2 server does not send an urgent message but write on the
socket 5 bytes :

     '\377', '\377', 'o', 'o', TIOCPKT_WINDOW

   If encryption is enabled (eklogin) server must send this 5 bytes
encrypted.

   Client can answer in both protocol version with :

     '\377', '\377', 's', 's', "struct winsize"

   The winsize structure is filled with corresponding setting to
client's terminal.  If encryption is enabled this answer must be send
encrypted.

B.3.6 End of authentication
---------------------------

The "classic" rsh/rlogin can be used now.

B.3.7 Encryption
----------------

Encryption mode is used when a connection with eklogin is established.
Encryption with krsh can be used too. Before, there was a specific port
for that (ekshell), but now to indicate that encryption must be used
with krsh, client must add "-x " before the command when it send it
between remote user name and local user name.  When the client compute
the checksum for AP-REQ authenticator the "- x" must not be included.

   Encryption in KCMDV0.2 is not the same as in KCMDV0.1.  KCMDV0.1
uses ticket session key as encryption key, and use standard Kerberos
encryption functions. This protocol only supports des-cbc-crc,
des-cbc-md4, des-cbc-md5 and does not use initialisation vectors.

   For example on each encryption/decryption calls, the following
prototype kerberos function should be used :

     kerberos_encrypt (key, keyusage, in, out)  (or decrypt)

   KCMDV0.2 can be used with all kerberos encryption modes (des, 3des,
aes, arcfour) and use AP-REQ authenticator subkey. In opposite to
KCMDV0.1 initialisation vectors are used. All encryptions/descryptions
must be made using a cryptographic context (for example to use the
updated iv, or sbox) :

     kerberos_init(ctx, iv, key, keyusage)
     kerberos_encrypt (ctx, in, out)

   For both protocols, keyusage id for des-cbc-md5, des-cbc-md4,
des-cbc-crc and des3-cbc-sha1 (for KCMDV0.2) :

     keyusage = 1026

   For other KCMDV0.2 modes keyusage is different for each
encryption/decryption usage.  To understand, eklogin use 1 socket. It
encrypts data (output 1) to send and decrypts (input 1) received data.
Kshell use 2 sockets (1 for transmit data, 1 for stderr). So there are
four modes :

   transmit  : input  1
	       output 1

   stderr    : input  2
	       output 2

   There is a keyusage for each modes. The keyusage must correspond on
client and server side. For example in klogin client input 1 keyusage
will be server output 1 keyusage.

I/O         Client      Server
intput 1    1028        1030
output 1    1030        1028
intput 2    1032        1034
output 2    1034        1032

   Those keyusages must be used with AES and ARCFOUR modes.

   KCMDV0.2 uses IV (initialisation vector). Like for keyusage, client
IV must correspond to server IV. IV size is equal to key type,
blocksize. All bytes of IV must be initialised to :

I/O         Client      Server
intput 1    0           1
output 1    1           0
intput 2    2           3
output 2    3           2

   ARCFOUR mode does not use IV. However, like it is said before, a
context must be used to keep the updated sbox.

   Normal message with klogin and kshell are sent like that :

     (int 32 lenght of message in MSB order)
     (message)

   In encrypted mode it is a bit different :

     (int 32 length of unencrypted message in MSB order)
     (encrypted message)

   In KCMDV0.2 encrypted message is create like that :

     encrypt (
     (int 32 length of message in MSB order)
     (message)
     )

   A check on message size can be made in second version of the
protocol.

B.3.8 KCMDV0.3
--------------

This part only gives possible ways to extend KCMD protocol. Does not
take that as must have in KCMD implementation.

   Extensions of KCMV0.2 could be made. For example kshell supposes
there are no files with name "-x *". I think the same thing can be
supposed with terminal name for klogin. So client could add "-x " to
terminal type it sends to server to indicate it will use encryption.
Like that there will be only one port for klogin/eklogin : 543.

   In encrypted mode kshell send command in clear on the network, this
could be considered as insecure as user have decided to use encryption.
This is not really a problem for klogin because it just sends terminal
type.

   In encrypted mode, klogin and kshell clients could only send "-x" as
command or terminal type.  After that encryption is activated, and the
client could send terminal type or command encrypted.  The server will
send the null byte to say that all is correct, or error message in
encrypted form.

B.3.9 MIT/Heimdal authorization
-------------------------------

This part describes how MIT/Heimdal version check authorization of the
user to log in on the remote machine.

   Authorization check is made by looking if the file .k5login exists on
the account of the remote user.  If this file does not exist, remote
user name must be the same as principal in AP-REQ to valid
authorization.  Else if this file exists, check first verify that
remote user or root are the owner of .k5login.  If it is not the case,
the check fails.  If it is good, check reads each line of that file and
compare each readed name to principal.  If principal is found in
.k5login, authorization is valid, else user is not allowed to connect
on remote host with the specified remote user name (that can be the
same as principal).

   So someone (for example user "user1") can remote log into "user2"
account if .k5login is present in user2 home dir and this file is owned
by user2 or root and user1 name is present in this file.


File: shishi.info,  Node: Key as initialization vector,  Next: The Keytab Binary File Format,  Prev: Kerberized rsh and rlogin,  Up: Protocol Extensions

B.4 Key as initialization vector
================================

The `des-cbc-crc' algorithm (*note Cryptographic Overview::) uses the
DES key as the initialization vector.  This is problematic in general
(see below(1)), but may be mitigated in Kerberos by the CRC checksum
that is also included.

From daw@espresso.CS.Berkeley.EDU Fri Mar  1 13:32:34 PST 1996
Article: 50440 of sci.crypt
Path: agate!daw
From: daw@espresso.CS.Berkeley.EDU (David A Wagner)
Newsgroups: sci.crypt
Subject: Re: DES-CBC and Initialization Vectors
Date: 29 Feb 1996 21:48:16 GMT
Organization: University of California, Berkeley
Lines: 31
Message-ID: <4h56v0$3no@agate.berkeley.edu>
References: <4h39li$33o@gaia.ns.utk.edu>
NNTP-Posting-Host: espresso.cs.berkeley.edu

In article <4h39li$33o@gaia.ns.utk.edu>,
Nair Venugopal <venu@mars.utcc.utk.edu> wrote:
> Is there anything wrong in using the key as the I.V. in DES-CBC mode?

Yes, you're open to a chosen-ciphertext attack which recovers the key.

Alice is sending stuff DES-CBC encrypted with key K to Bob.  Mary is an
active adversary in the middle.  Suppose Alice encrypts some plaintext
blocks P_1, P_2, P_3, ... in DES-CBC mode with K as the IV, and sends off
the resulting ciphertext
	A->B: C_1, C_2, C_3, ...
where each C_j is a 8-byte DES ciphertext block.  Mary wants to discover
the key K, but doesn't even know any of the P_j's.  She replaces the above
message by
	M->B: C_1, 0, C_1
where 0 is the 8-byte all-zeros block.  Bob will decrypt under DES-CBC,
recovering the blocks
	Q_1, Q_2, Q_3
where
	Q_1 = DES-decrypt(K, C_1) xor K = P_1
	Q_2 = DES-decrypt(K, C_2) xor C_1 = (some unimportant junk)
	Q_3 = DES-decrypt(K, C_1) xor 0 = P_1 xor K
Bob gets this garbage-looking message Q_1,Q_2,Q_3 which Mary recovers
(under the chosen-ciphertext assumption: this is like a known-plaintext
attack, which isn't too implausible).  Notice that Mary can recover K by
	K = Q_1 xor Q_3;
so after this one simple active attack, Mary gets the key back!

So, if you must use a fixed IV, don't use the key-- use 0 or something
like that.  Even better, don't use a fixed IV-- use the DES encryption
of a counter, or something like that.

   ---------- Footnotes ----------

   (1) The post is copyrighted by David Wagner, included here with
permission, the canonical location is
`http://www.cs.berkeley.edu/~daw/my-posts/key-as-iv-broken'


File: shishi.info,  Node: The Keytab Binary File Format,  Next: The Credential Cache Binary File Format,  Prev: Key as initialization vector,  Up: Protocol Extensions

B.5 The Keytab Binary File Format
=================================

The keytab file format is described in the file `keytab.txt', included
in verbatim below.

The Kerberos Keytab Binary File Format
Copyright (C) 2006 Michael B Allen <mba2000 ioplex.com>
http://www.ioplex.com/utilities/keytab.txt
Last updated: Fri May  5 13:39:40 EDT 2006

The MIT keytab binary format is not a standard format, nor is it
documented anywhere in detail. The format has evolved and may continue
to. It is however understood by several Kerberos implementations including
Heimdal and of course MIT and keytab files are created by the ktpass.exe
utility from Windows. So it has established itself as the defacto format
for storing Kerberos keys.

The following C-like structure definitions illustrate the MIT keytab
file format. All values are in network byte order. All text is ASCII.

  keytab {
      uint16_t file_format_version;                    /* 0x502 */
      keytab_entry entries[*];
  };

  keytab_entry {
      int32_t size;
      uint16_t num_components;    /* sub 1 if version 0x501 */
      counted_octet_string realm;
      counted_octet_string components[num_components];
      uint32_t name_type;   /* not present if version 0x501 */
      uint32_t timestamp;
      uint8_t vno8;
      keyblock key;
      uint32_t vno; /* only present if >= 4 bytes left in entry */
  };

  counted_octet_string {
      uint16_t length;
      uint8_t data[length];
  };

  keyblock {
      uint16_t type;
      counted_octet_string;
  };

The keytab file format begins with the 16 bit file_format_version which
at the time this document was authored is 0x502. The format of older
keytabs is described at the end of this document.

The file_format_version is immediately followed by an array of
keytab_entry structures which are prefixed with a 32 bit size indicating
the number of bytes that follow in the entry. Note that the size should be
evaluated as signed. This is because a negative value indicates that the
entry is in fact empty (e.g. it has been deleted) and that the negative
value of that negative value (which is of course a positive value) is
the offset to the next keytab_entry. Based on these size values alone
the entire keytab file can be traversed.

The size is followed by a 16 bit num_components field indicating the
number of counted_octet_string components in the components array.

The num_components field is followed by a counted_octet_string
representing the realm of the principal.

A counted_octet_string is simply an array of bytes prefixed with a 16
bit length. For the realm and name components, the counted_octet_string
bytes are ASCII encoded text with no zero terminator.

Following the realm is the components array that represents the name of
the principal. The text of these components may be joined with slashs
to construct the typical SPN representation. For example, the service
principal HTTP/www.foo.net@FOO.NET would consist of name components
"HTTP" followed by "www.foo.net".

Following the components array is the 32 bit name_type (e.g. 1 is
KRB5_NT_PRINCIPAL, 2 is KRB5_NT_SRV_INST, 5 is KRB5_NT_UID, etc). In
practice the name_type is almost certainly 1 meaning KRB5_NT_PRINCIPAL.

The 32 bit timestamp indicates the time the key was established for that
principal. The value represents the number of seconds since Jan 1, 1970.

The 8 bit vno8 field is the version number of the key. This value is
overridden by the 32 bit vno field if it is present.

The keyblock structure consists of a 16 bit value indicating the keytype
(e.g. 3 is des-cbc-md5, 23 is arcfour-hmac-md5, 16 is des3-cbc-sha1,
etc). This is followed by a counted_octet_string containing the key.

The last field of the keytab_entry structure is optional. If the size of
the keytab_entry indicates that there are at least 4 bytes remaining,
a 32 bit value representing the key version number is present. This
value supersedes the 8 bit vno8 value preceeding the keyblock.

Older keytabs with a file_format_version of 0x501 are different in
three ways:

  1) All integers are in host byte order [1].
  2) The num_components field is 1 too large (i.e. after decoding,
     decrement by 1).
  3) The 32 bit name_type field is not present.

[1] The file_format_version field should really be treated as two
    separate 8 bit quantities representing the major and minor version
    number respectively.

Permission to copy, modify, and distribute this document, with or
without modification, for any purpose and without fee or royalty is
hereby granted, provided that you include this copyright notice in ALL
copies of the document or portions thereof, including modifications.


File: shishi.info,  Node: The Credential Cache Binary File Format,  Prev: The Keytab Binary File Format,  Up: Protocol Extensions

B.6 The Credential Cache Binary File Format
===========================================

The credential cache file format is described in the file `keytab.txt',
included in verbatim below.

The Kerberos Credential Cache Binary File Format
Copyright (C) 2006 Simon Josefsson <simon josefsson.org>
http://josefsson.org/shishi/ccache.txt
Last updated: Sat Sep 23 12:04:11 CEST 2006

Like the MIT keytab binary format (see Michael B Allen's reverse
engineered description in keytab.txt), the credential cache format is
not standard nor documented anywhere.

In C style notation, the MIT credential cache file format is as
follows.  All values are in network byte order.  All text is ASCII.

ccache {
          uint16_t file_format_version; /* 0x0504 */
          uint16_t headerlen;           /* only if version is 0x0504 */
          header headers[];             /* only if version is 0x0504 */
          principal primary_principal;
          credential credentials[*];
};

header {
       uint16_t tag;                    /* 1 = DeltaTime */
       uint16_t taglen;
       uint8_t tagdata[taglen]
};

The ccache.taglen and ccache.tags fields are only present in 0x0504
versions, not in earlier.  Both MIT and Heimdal appear to correctly
ignore unknown tags, so it appears safe to add them (although there is
no central place to "register" tags).

Currently only one tag is widely implemented, DeltaTime (0x0001).  Its
taglen is always 8, and tagdata will contain:

DeltaTime {
       uint32_t time_offset;
       uint32_t usec_offset;
};

After reading the file_format_version, header tags, and default
principal, a list of credentials follow.  You deduce from the file
length when there are no more credentials.

credential {
           principal client;
           principal server;
           keyblock key;
           times    time;
           uint8_t  is_skey;            /* 1 if skey, 0 otherwise */
           uint32_t tktflags;           /* stored in reversed byte order */
           uint32_t num_address;
           address  addrs[num_address];
           uint32_t num_authdata;
           authdata authdata[num_authdata];
           countet_octet_string ticket;
           countet_octet_string second_ticket;
};

keyblock {
         uint16_t keytype;
         uint16_t etype;                /* only present if version 0x0503 */
         uint16_t keylen;
         uint8_t keyvalue[keylen];
};

times {
      uint32_t  authtime;
      uint32_t  starttime;
      uint32_t  endtime;
      uint32_t  renew_till;
};

address {
        uint16_t addrtype;
        counted_octet_string addrdata;
};

authdata {
         uint16_t authtype;
         counted_octet_string authdata;
};

principal {
          uint32_t name_type;           /* not present if version 0x0501 */
          uint32_t num_components;      /* sub 1 if version 0x501 */
          counted_octet_string realm;
          counted_octet_string components[num_components];
};

counted_octet_string {
    uint32_t length;
    uint8_t data[length];
};

Permission to copy, modify, and distribute this document, with or
without modification, for any purpose and without fee or royalty is
hereby granted, provided that you include this copyright notice in ALL
copies of the document or portions thereof, including modifications.


File: shishi.info,  Node: Copying Information,  Next: Function and Data Index,  Prev: Protocol Extensions,  Up: Top

Appendix C Copying Information
******************************

* Menu:

* GNU Free Documentation License::   License for copying this manual.
* GNU GPL::                          License for copying the programs.

